[{"title":"递归转动态规划","date":"2017-08-25T05:19:51.306Z","path":"2017/08/25/递归转动态规划/","text":"题目12345一排有N个位置，一个机器人在最开始停留在P位置上，如果 p==0位置，下一分钟机器人一定向右移动到1位置；如果p==N一1， 下一分钟机器人一定向左移动到N一2位置。如果P在0和N一1之间， 下一分钟机器人一定会向左或者向右移动。求K分钟的时候，机 器人到达T位置有多少种走法。 求解算法思路123456根据题目可知机器人有多动症，必须动，1. 当机器人在最左边时，只能向右走一步，k为时间，t为最终位置，即由(k,0)→(k-1,1)2. 当机器人在最右边时，只能向左走一步，即(k,n-1)→(k-1,n-2)3. 当机器人在其他位置，可以有两种选择: 1) 向右走:(k,t)→(k-1,t+1) 2) 向左走:(k,t)→(k-1,t-1) 代码1234567891011121314private static int sumMove(int n, int p, int k, int t) &#123; //当只有一个位置时，机器人无法动，直接返回0 //当p，t 处于0~n之间才有效 //当时间&gt;=0才有效 if (n &lt; 2 || p &gt;= n || p &lt; 0 || k &lt; 0 || t &gt;= n || t &lt; 0) return 0; if(k==0)//当结束时 位置必须在p位置 return t==p?1:0; //如果机器人在最左边或者最右边 if(t == n-1 || t == 0) return t==0?sumMove(n, p, k-1, t+1):sumMove(n, p, k-1, t-1); else//其他情况 return sumMove(n, p, k-1, t+1)+sumMove(n, p, k-1, t-1); &#125; 递归到动态规划的转换分析有递归代码可知，sumMove函数一共有四个参数(n,p,k,t)其中只有k,t是变量，其他两个为定值，我们以k为横坐标，t为纵坐标，建立一张表: 第一行第p列对应着机器人开始的位置: dp[0][1] 第一列就对应着左边界: dp[k][0]=dp[k-1][1] 最后一列就对应着右边界: dp[k][n-1] = dp[k-1][n-2] 其他位置对应的值为: dp[k][n-1] = dp[k-1][n-2] 代码123456789101112131415private static int sumMoveDP(int n, int p, int k, int t) &#123; if (n &lt; 2 || p &gt;= n || p &lt; 0 || k &lt; 0 || t &gt;= n || t &lt; 0) return 0; int[][] dp = new int[k+1][n]; dp[0][p] = 1;//机器人开始的位置 for (int i = 1; i &lt; k+1; i++) &#123; dp[i][0] = dp[i-1][1];//机器人在左边界 dp[i][n-1] = dp[i-1][n-2];//机器人在右边界 for (int j = 1; j &lt; n-1; j++) &#123; //机器人在其他位置 dp[i][j] = dp[i-1][j-1]+dp[i-1][j+1]; &#125; &#125; return dp[k][t]; &#125; 优化时间复杂度上倒是不能优化了，我们可以从空间复杂度上优化:从dp数组来看 本行数据会利用到上一行数据某一个数或者某两个数，而我们只用一维数组，再通过两个变量记录上一行的值就可解决 代码123456789101112131415161718private static int sumMoveDPSimple(int n, int p, int k, int t) &#123; if (n &lt; 2 || p &gt;= n || p &lt; 0 || k &lt; 0 || t &gt;= n || t &lt; 0) return 0; int[] dp = new int[n]; dp[p] = 1; int pre = 0,next = 0; for (int i = 1; i &lt; k+1; i++) &#123; pre = dp[0]; dp[0] = dp[1]; for (int j = 1; j &lt; n-1; j++) &#123; next = dp[j]; dp[j] = pre+dp[j+1]; pre = next; &#125; &#125; return dp[t]; &#125; 练习题目123456789101112131415给定一个整型数组arr，代表数值不同的纸牌排成一条线。玩家A和玩家B依次拿走每张纸牌，规定玩家A先拿，玩家B后拿，但是每个玩家每次只能拿走最左或最右的纸牌，玩家A和玩家B都绝顶聪明。请返回最后获胜者的分数。例如：arr=[1,2,100,4]开始时玩家A只能拿走1或4。如果玩家A拿走1，则排列变为[2，100，4]，接下来玩家B可以拿走2或4，然后继续轮到玩家A。如果开始时玩家A拿走4，则排列变为[1，2，100]，接下来玩家B可以拿走1或100，然后继续轮到玩家A。玩家A作为绝顶聪明的人不会先拿4，因为拿4之后，玩家B将拿走100。所以玩家A会先拿1，让排列变为[2，100，4]，接下来玩家B不管怎么选，100都会被玩家A拿走。玩家A会获胜，分数为101。所以返回101。arr:tl,100，2]。升始时玩家A不管拿1还是2，玩家B作为绝顶聪明的人，都会把100拿走。玩家B会获胜，分数为100。所以返回100。 算法思路123可将题目分解为先手和后手的区别: 1.先拿的牌大小等于 拿第一张牌+后面拿的牌数 和 拿最后一张牌数+后面拿的牌数 中大的那一个 2. 后拿的牌则是被希望前面拿的牌数尽量小，所以后拿的牌大小等于 拿第一张牌+先拿的牌数 和 拿最后一张牌数+先拿的牌数 中小的那一个 代码 第一种方法 12345678910111213private static int pre(int[] arr,int first,int last) &#123; if(first == last)//当最后只剩一张牌的时候 return arr[first]; return Math.max(arr[first]+next(arr,first+1,last), arr[last]+next(arr,first,last-1)); &#125; private static int next(int[] arr, int first, int last) &#123; if(first == last)//当最后只剩一张牌的时候 return 0; return Math.min(pre(arr,first+1,last),pre(arr,first,last-1)); &#125; 第二种方法 12345678910private static int choose(int[] arr,int first,int last) &#123; if(first==last) return arr[first]; if(first == last - 1)//奇数偶数的原因 return Math.max(arr[first], arr[last]); return Math.max(arr[first]+Math.min( choose(arr,first+2,last), choose(arr,first,last-2)), arr[last]+Math.min(choose(arr,first+2,last), choose(arr,first,last-2))); &#125; 转换为动态规划12345678910111213141516171819202122232425262728293031//对应第一种解法的转换private static int pukeDP(int[] arr) &#123; int f[][] = new int[arr.length][arr.length]; int s[][] = new int[arr.length][arr.length]; for (int j = 0; j &lt; arr.length; j++) &#123; f[j][j] = arr[j]; for (int i = j - 1; i &gt;= 0; i--) &#123; f[i][j] = Math.max(arr[i] + s[i + 1][j], arr[j] + s[i][j - 1]); s[i][j] = Math.min(f[i + 1][j], f[i][j - 1]); &#125; &#125; return Math.max(f[0][arr.length - 1], s[0][arr.length - 1]); &#125;//对应第二种方法的转换private static int pukeDPchoose(int[] arr) &#123; int dp[][] = new int[arr.length][arr.length],sum = 0; for (int j = 0; j &lt; arr.length; j++) &#123; sum += arr[j]; dp[j][j] = arr[j]; if(j-1&gt;=0) dp[j-1][j] = Math.max(arr[j], arr[j-1]); for (int i = j - 2; i &gt;= 0; i--) &#123; dp[i][j] = Math.max(arr[i]+Math.min(dp[i+2][j], dp[i][j-2]), arr[j]+Math.min(dp[i+2][j], dp[i][j-2])); &#125; &#125; return Math.max(sum-dp[0][arr.length - 1], dp[0][arr.length - 1]); &#125;","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://super3h.me/tags/数据结构/"}]},{"title":"最长子串问题","date":"2017-08-25T02:50:58.288Z","path":"2017/08/25/最长子串问题/","text":"前言好久没更新博客了，忙于找工作，最近疯狂练习中。。 题目123a = &#123;1,2,3,5,6,9,8,7,4,5,63,2,1,6,5&#125;aim = 24求能达到和为24的最长子串 求解前言本解法是根据左神的算法而来，牛客网有直播，大家可以去看看，很厉害的算法大神 算法思路123456789101112131415161718192021222324252627282930313233343536 sum = 0当遍历到第一个数1时sum = 1 距离目标数相差 1-24=-23map中没有-23的数,就将 sum放进map中map (1,0)//sum为1时的位置在0当遍历到第二个数2时sum = 3 距离目标数相差 3-24=-21 就将 sum放进map中 map中没有-21的数map (3,1)//sum为3时的位置在1。。。。当遍历到第5个数 6 时sum = 17 距离目标相差 17-24 = -5map中没有-21的数 就将 sum放进map中 map (17,4)//sum为17时的位置在1。。。当遍历到第8个数 7 时sum = 41 距离目标相差 41-24 = 17map中含有(17,5) 子串长 7-4 = 3max = 3继续遍历 拿到最大子串值比较并拿到最大值 代码123456789101112131415161718192021222324252627import java.util.HashMap;public class MaxSubString &#123; public static void main(String[] args) &#123; int[] a = &#123;5,1,4&#125;; int aim = 5; System.out.println(maxLength(a,aim)); &#125; public static int maxLength(int[] arr, int k) &#123; if (arr == null || arr.length == 0) &#123; return 0; &#125; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); map.put(0, -1); // important int len = 0; int sum = 0; for (int i = 0; i &lt; arr.length; i++) &#123; sum += arr[i]; if (map.containsKey(sum - k)) &#123; len = Math.max(i - map.get(sum - k), len); &#125; if (!map.containsKey(sum)) &#123; map.put(sum, i); &#125; &#125; return len; &#125;&#125; 扩展1一段二进制串&#123;0,0,1,0,0,0,0,1,1,1,1,1&#125;,找出最大子串让0和1相等的数量 算法思路道理同上面，在这里将0替换成-1，目标试求和为0的最大子串 代码12345678910111213141516171819202122232425262728293031323334353637383940414243package com.hhh.wangyi;import java.util.HashMap;/**找出最大子串是0和1相等的数量 * @author 黄辉辉 * */public class MaxSubString01 &#123; /** * * 将0替换成-1 * * 用最长子串的方法求解 * */ public static void main(String[] args) &#123; int[] a = &#123;0,0,1,0,0,0,0,1,1,1,1,1&#125;; int aim = 0; fn(a, aim); &#125; private static void fn(int[] a, int aim) &#123; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); int sum = 0,max = 0; //排除第一个是0的情况及全部数字为子串的情况 map.put(0, -1); for (int i = 0; i &lt; a.length; i++) &#123; a[i]= a[i]==0?-1:1;//将0替换成-1 sum += a[i]; int key = sum - aim; if(map.containsKey(key))&#123; max = Math.max(i-map.get(key), max); &#125; if(!map.containsKey(key)) map.put(sum, i); &#125; System.out.println(max); &#125;&#125; 总结类似这种求解最长子串都可用此法，算法还是得多练，不练也就容易忘","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://super3h.me/tags/数据结构/"}]},{"title":"HTML中倒三角和正三角","date":"2017-05-09T15:09:52.066Z","path":"2017/05/09/HTML中倒三角和正三角/","text":"前言经常看到网站有这种符号▽的出现，刚好作业碰到这个问题，于是认真的学了下 分析看似容易的，其实真的很容易。。 效果如下: 分析代码如下：12345678b&#123; border-style:dashed ; border-color:#bbb transparent transparent;&#125;b:hover&#123; border-style:dashed ; border-color:transparent transparent #bbb transparent;&#125; 先看下面解释border-color:red green blue pink; 上边框是红色 右边框是绿色 下边框是蓝色 左边框是粉色看完后，正三角解释:border-color:#bbb transparent transparent; 上边框是灰色 右边框和左边框是透明色 下边框是透明色 倒三角解释:border-color:transparent transparent #bbb transparent; 上边框是透明色 右边框是透明色 左边框是透明色 下边框是灰色 注意：这里一定要设置边框样式,即border-style:dashed ;，否则显示不了!!! 详细代码1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;style type=\"text/css\"&gt; div&#123; width: 960px; margin-left: auto; margin-right: auto; font-size: 45px; &#125; b&#123; position: relative; top: 43px; left: 3px; border-width:20px ; border-style:dashed ; border-color:#bbb transparent transparent; &#125; div:hover b&#123; position: relative; top: -43px; left: 3px; border-style:dashed ; border-color:transparent transparent #bbb transparent; &#125; &lt;/style&gt; &lt;body&gt; &lt;div&gt; 点我&lt;b&gt;&lt;/b&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","tags":[{"name":"html","slug":"html","permalink":"https://super3h.me/tags/html/"}]},{"title":"路由器配置-不等长","date":"2017-05-05T01:51:43.811Z","path":"2017/05/05/路由器配置-不等长/","text":"题目 网络号为：218.197.17.0 子网数： 4 每个子网分配数如下： A:70 B:35 C:30 D:20 问题：写出各个子网的ip范围 分析4个子网，按等长划分，需要2位，每个子网主机量为26-2=62&lt;70 ，所以我们使用不等长划分，按主机数量来划分 A子网70台需要7位(子网掩码:255.255.255.128)，划分如下 子网掩码后8位 可选网络号 地址范围 00 00 00 00 218.197.17.0 218.197.17.1 10 00 00 00 218.197.17.128 218.197.17.126 B子网35台需要6位(子网掩码:255.255.255.192)，划分如下 子网掩码后8位 可选网络号 地址范围 10 00 00 00 218.197.17.128 218.197.17.129 11 00 00 00 218.197.17.192 218.197.17.190 注意:00 00 00 00~10 00 00 00之间的已经被A子网占用了 C子网30台需要5位(子网掩码:255.255.255.224)，划分如下 子网掩码后8位 可选网络号 地址范围 11 00 00 00 218.197.17.192 218.197.17.193 11 10 00 00 218.197.17.224 218.197.17.222 D子网20台需要5位(子网掩码:255.255.255.224)，划分如下 子网掩码后8位 可选网络号 地址范围 11 10 00 00 218.197.17.224 218.197.17.225 11 11 11 10 218.197.17.254 218.197.17.252 网络拓扑图 路由器配置详细操作方法请参照上文:路由器配置-等长","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://super3h.me/tags/计算机网络/"}]},{"title":"容器深入研究-Map","date":"2017-04-23T15:10:15.136Z","path":"2017/04/23/容器深入研究-Map/","text":"前言由于这几天看了些有关map的知识点，面试可能会被问到，所以来总结总结！！ Map介绍 Map的实现 解释 HashMap Map基于散列表的实现(取代了HashTable，下文将介绍),插入和查询”键值对”的开销是固定的，可以通过构造器设置容量和负载因子，以调整容器的性能 LinkedHashMap 类似于HashMap,但是迭代遍历它时，取得”键值对”的顺序是插入次序、或者是最近最少使用(LRU)的次序。只比HashMap慢一点；而在迭代访问时速度反而更快、因为它使用链表维护内部次序 TreeMap 基于红黑树的实现。查看”键”或”键值对”时，它们会被排序(次序由Comparable或Comparator决定)。TreeMap的特点在于，所得到的的结果是经过排序的。TreeMap是唯一的带有subMap()方法的Map，他可以返回一个子树 WeakHashMap 弱键映射，允许释放映射所指向的对象；这是为解决某类特殊问题而设计的。如果映射之外没有引用指向某个”键”，则此”键”可以被垃圾收集器回收 ConcurrentHashMap 一种线程安全的Map，它不涉及同步加锁。 IDentityHashMap 使用==代替equals对”键”进行比较的散列映射。专门解决特殊问题二设计的 HashMap HashMap的存储结构 HashMap有四个构造方法，方法中有两个很重要的参数：初始容量和加载因子 这两个参数是影响HashMap性能的重要参数，其中容量表示哈希表中槽的数量（即哈希数组的长度），初始容量是创建哈希表时的容量（默认为16），加载因子是哈希表当前key的数量和容量的比值，当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表提前进行 resize 操作（即扩容）。如果加载因子越大，对空间的利用更充分，但是查找效率会降低（链表长度会越来越长）；如果加载因子太小，那么表中的数据将过于稀疏（很多空间还没用，就开始扩容了），严重浪费。 JDK开发者规定的默认加载因子为0.75，因为这是一个比较理想的值。另外，无论指定初始容量为多少，构造方法都会将实际容量设为不小于指定容量的2的幂次方，且最大值不能超过2的30次方 重点分析HashMap中用的最多的两个方法put和get的源码 get方法源码 12345678910111213141516171819202122232425// 获取key对应的valuepublic V get(Object key) &#123; if (key == null) return getForNullKey(); // 获取key的hash值 int hash = hash(key.hashCode()); // 在“该hash值对应的链表”上查找“键值等于key”的元素 for (Entry&lt;K, V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; // 判断key是否相同 if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) return e.value; &#125; // 没找到则返回null return null;&#125;// 获取“key为null”的元素的值，HashMap将“key为null”的元素存储在table[0]位置，但不一定是该链表的第一个位置！private V getForNullKey() &#123; for (Entry&lt;K, V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) return e.value; &#125; return null;&#125; 首先，如果key为null，则直接从哈希表的第一个位置table[0]对应的链表上查找。记住，key为null的键值对永远都放在以table[0]为头结点的链表中，当然不一定是存放在头结点table[0]中。如果key不为null，则先求的key的hash值，根据hash值找到在table中的索引，在该索引对应的单链表中查找是否有键值对的key与目标key相等，有就返回对应的value，没有则返回null。 put方法源码 12345678910111213141516171819202122232425// 将“key-value”添加到HashMap中public V put(K key, V value) &#123; // 若“key为null”，则将该键值对添加到table[0]中。 if (key == null) return putForNullKey(value); // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。 int hash = hash(key.hashCode()); int i = indexFor(hash, table.length); for (Entry&lt;K, V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！ if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; // 若“该key”对应的键值对不存在，则将“key-value”添加到table中 modCount++; // 将key-value添加到table[i]处 addEntry(hash, key, value, i); return null;&#125; 如果key为null，则将其添加到table[0]对应的链表中，如果key不为null，则同样先求出key的hash值，根据hash值得出在table中的索引，而后遍历对应的单链表，如果单链表中存在与目标key相等的键值对，则将新的value覆盖旧的value，且将旧的value返回，如果找不到与目标key相等的键值对，或者该单链表为空，则将该键值对插入到单链表的头结点位置（每次新插入的节点都是放在头结点的位置），该操作是有addEntry方法实现的，它的源码如下： view code 1234567891011// 新增Entry。将“key-value”插入指定位置，bucketIndex是位置索引。void addEntry(int hash, K key, V value, int bucketIndex) &#123; // 保存“bucketIndex”位置的值到“e”中 Entry&lt;K, V&gt; e = table[bucketIndex]; // 设置“bucketIndex”位置的元素为“新Entry”， // 设置“e”为“新Entry的下一个节点” table[bucketIndex] = new Entry&lt;K, V&gt;(hash, key, value, e); // 若HashMap的实际大小 不小于 “阈值”，则调整HashMap的大小 if (size++ &gt;= threshold) resize(2 * table.length);&#125; 注意这里倒数第三行的构造方法，将key-value键值对赋给table[bucketIndex]，并将其next指向元素e，这便将key-value放到了头结点中，并将之前的头结点接在了它的后面。该方法也说明，每次put键值对的时候，总是将新的该键值对放在table[bucketIndex]处（即头结点处）。两外注意最后两行代码，每次加入键值对时，都要判断当前已用的槽的数目是否大于等于阀值（容量*加载因子），如果大于等于，则进行扩容，将容量扩为原来容量的2倍。 重点来分析下求hash值和索引值的方法，这两个方法便是HashMap设计的最为核心的部分，二者结合能保证哈希表中的元素尽可能均匀地散列 由hash值找到对应索引的方法如下 123static int indexFor(int h, int length) &#123; return h &amp; (length-1); &#125; 因为容量初始还是设定都会转化为2的幂次。故可以使用高效的位与运算替代模运算。下面会解释原因。 计算hash值的方法如下 1234static int hash(int h) &#123; h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); &#125; JDK 的 HashMap 使用了一个 hash 方法对hash值使用位的操作，使hash值的计算效率很高。为什么这样做？主要是因为如果直接使用hashcode值，那么这是一个int值（8个16进制数，共32位），int值的范围正负21亿多，但是hash表没有那么长，一般比如初始16，自然散列地址需要对hash表长度取模运算，得到的余数才是地址下标。假设某个key的hashcode是0AAA0000，hash数组长默认16，如果不经过hash函数处理，该键值对会被存放在hash数组中下标为0处，因为0AAA0000 &amp; (16-1) = 0。过了一会儿又存储另外一个键值对，其key的hashcode是0BBB0000，得到数组下标依然是0，这就说明这是个实现得很差的hash算法，因为hashcode的1位全集中在前16位了，导致算出来的数组下标一直是0。于是明明key相差很大的键值对，却存放在了同一个链表里，导致以后查询起来比较慢（蜕化为了顺序查找）。故JDK的设计者使用hash函数的若干次的移位、异或操作，把hashcode的“1位”变得“松散”，非常巧妙。 关于扩容。看hashmap的扩容方法，resize方法 12345678910111213141516// 重新调整HashMap的大小，newCapacity是调整后的单位 void resize(int newCapacity) &#123; Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return; &#125; // 新建一个HashMap，将“旧HashMap”的全部元素添加到“新HashMap”中， // 然后，将“新HashMap”赋值给“旧HashMap”。 Entry[] newTable = new Entry[newCapacity]; transfer(newTable); table = newTable; threshold = (int) (newCapacity * loadFactor); &#125; 很明显，是从新建了一个HashMap的底层数组，长度为原来的两倍，而后调用transfer方法，将旧HashMap的全部元素添加到新的HashMap中（要重新计算元素在新的数组中的索引位置）。transfer方法的源码如下:123456789101112131415161718// 将HashMap中的全部元素都添加到newTable中 void transfer(Entry[] newTable) &#123; Entry[] src = table; int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) &#123; Entry&lt;K, V&gt; e = src[j]; if (e != null) &#123; src[j] = null; do &#123; Entry&lt;K, V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; &#125; while (e != null); &#125; &#125; &#125; 很明显，扩容是一个相当耗时的操作，因为它需要重新计算这些元素在新的数组中的位置并进行复制处理。因此，我们在用HashMap时，最好能提前预估下HashMap中元素的个数，这样有助于提高HashMap的性能。 更详细内容HashMap 和 HashTable 源码学习和面试总结 LinkedHashMap LinkedHashMap 是 HashMap 的一个子类，它保留插入的顺序，如果需要输出的顺序和输入时的相同，那么就选用 LinkedHashMap。 LinkedHashMap 是 Map 接口的哈希表和链接列表实现，具有可预知的迭代顺序。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 LinkedHashMap 实现与 HashMap 的不同之处在于，LinkedHashMap 维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。 注意，此实现不是同步的。如果多个线程同时访问链接的哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须保持外部同步。 根据链表中元素的顺序可以分为：按插入顺序的链表，和按访问顺序(调用 get 方法)的链表。默认是按插入顺序排序，如果指定按访问顺序排序，那么调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表 详情参考LinkedHashMap 的实现原理 TreeMap","tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://super3h.me/tags/JavaSE/"},{"name":"Map","slug":"Map","permalink":"https://super3h.me/tags/Map/"}]},{"title":"路由器配置-等长","date":"2017-04-21T14:30:22.550Z","path":"2017/04/21/路由器配置-等长/","text":"题目 有一个企业网络拓扑结构如上图，回答如下问题： 给出子网划分方案，并给出每个子网主机的地址空间； 完成网络地址分配，以表格的形式提供； 完成主机PCD、www、及DNS的配置，以表格的形式提供； 完成路由器Router2的端口地址及静态路由配置并保存。 分析划分子网由图知：共有四个子网，主机号需提供2位给网络号：所以分别为:00,01,10,11，所以可得以下地址(这里把全1的广播号和全0的网络号都算进去了)，ps:配置时候不用管点是红色还是绿色，后面会介绍，做什么事都得一步一步！！！ 网络 地址空间 net1 218.197.15.0~218.197.15.63 net2 218.197.15.64~218.197.15.127 net3 218.197.15.128~218.197.15.191 net4 218.197.15.192~218.197.15.255 这里我们在图上配置好我们的图: 这里net1、net2、net3、net4都需以其实地址开始，即0,64,128,192 划分主机地址我们想看左边那一块,由题目可知，给主机分配218.197.17.1~218.197.17.254即可(除去网络号和主机号)，配置如下： 接下来我们给pc机和服务器配置相应的ip: pc机配置如下： 另一个pc机操作也同上 服务器配置如下: 另一个服务器操作也同上 配置完后，主机、服务器之间就可以相互ping通了！！,操作如下: 接下来我们用pc0来ping主机和服务器 接下来我们配置其网关，网关范围也在218.197.17.1~218.197.17.254(除去网络号和主机号)之间: 配置链接左边那块的路由器 配置默认网关只用在圆柱体的路由器上的fa0/0端口配置以上信息即可，切记一定要点击启用，否则图上的绿点就是红点 (博主已经全部启用，所以你们看到的是绿色) ps:鼠标悬停在绿色(红色)的小圆点上就可以知道其端口号 配置各个pc、服务器的默认网关、和dns服务器 DNS服务器IP我们一开始配置的为218.197.17.100，网关配置的为218.197.17.250，这里博主只演示了CopyPC0的配置，其他几个同理！！,接下来我们ping一下网关即可验证： 最右边操作也同理:ip地址范围218.197.16.1~218.197.16.254即可(网络号和广播号除外),我的Ip地址，网关配置(最后成果是右边pc能访问左边的服务器，所以这里pc的DNS服务器我们也配置成左边的DNS服务器的IP)如下: 配置4个路由的端口 网络 地址空间 net1 218.197.15.0~218.197.15.63 net2 218.197.15.64~218.197.15.127 net3 218.197.15.128~218.197.15.191 net4 218.197.15.192~218.197.15.255 net1之间的地址空间范围为:218.197.15.1~218.197.15.62(除去广播号和网络号),我们在net1之间的两个端口配置上以上的范围即可: 操作如下: 这里解释一下子网掩码写192的原因:由于前面我们划分子网给了2位作为网络号，所以最后8位为1100 0000其他配置同理: 操作完成后，我们来用pc机ping一下来确认: 可以看到我们ping218.197.15.62，可以通，但是218.197.15.1不行，因为这个路由器并不知道发送方在哪个网络，从而不知道数据发送给谁，因此这里我们需要给其配置静态路由，配置如下： 这里目的网络为218.197.17.0这个网络，子网掩码也为这个网络的掩码，下一跳是指需要经过的下一个路由器端口，通过该路由器才能将数据路由出去，这里我们ping一下218.197.15.1来确认一下即可: 倘若我们要通过最左边的电脑来访问左右边的电脑咋办？？分析：最左边访问最右边，当然要通过管理最左边的路由器来路由数据，所以这里我们配置其静态路由： 这里有两条路可以走，博主选的上面这条路，配置完后就可以访问了么？？我们来试一下： 发现都没办法到达目的地，**因为这里我们通过最上方的路由器来路由数据，但它不知道到目的网络在哪，我们再来配置他的静态路由 这个时候我们来ping一下: 发现可以到达目的网络，但是请求超时，因为这个路由器并不知道发送方在哪个网络，从而不知道数据发送给谁，因此这里我们需要给其配置静态路由 在ping一下确认： ping通了，这个时候你会纳闷，数据经过最上方的路由器路由，但是最上方的路由器没有配置目的网络到218.197.17.0啊！！！其实我们刚开始就已经配了，往上翻一下就知道了！！ 总结 之前博主也一直不知道，直到期中考试考了这个，我才重视起来，多亏同学不停地教我，花了博主一晚上才弄懂！！俗话说:Talk is cheap,show me the code，一定要练习，上面只展示了上半部分的路由，读者有心可以从下面路由数据，当你下面路由成功了，你才算真正的懂！！！","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://super3h.me/tags/计算机网络/"}]},{"title":"Java-ValueOf","date":"2017-04-15T05:57:14.156Z","path":"2017/04/15/Java-ValueOf/","text":"value of Integer valueOf(int i)：返回一个表示指定的 int 值的 Integer 实例。 Integer valueOf(String s):返回保存指定的 String 的值的 Integer 对象。 Integer valueOf(String s, int radix): 返回一个 Integer 对象，该对象中保存了用第二个参数提供的基数进行解析时从指定的 String 中提取的值。 题目123System.out.println(Integer.valueOf(\"127\")==Integer.valueOf(\"127\"));//trueSystem.out.println(Integer.valueOf(\"128\")==Integer.valueOf(\"128\"));//falseSystem.out.println(Integer.parseInt(\"128\")==Integer.valueOf(\"128\"));//true 解析看官方文档可以发现: This method will always cache values in the range -128 to 127默认会缓存-128到127间的值，因为128没有被缓存，所以每次调用，都会生成一个新的整型对象，因此两个128整型对象是不同的对象。","tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://super3h.me/tags/JavaSE/"}]},{"title":"SpringMVC 注解","date":"2017-03-29T08:24:45.565Z","path":"2017/03/29/SpringMVC 注解/","text":"前言初学SpringMVC，发现有些注解功能有些类似，都为获取前台数据，这里主要讲这些注解的分别！ SpringMVC 注解@PathVariable用来映射RESTful风格的url，例如@RequestMapping(/getCourse/{id})，获取id则可以通过这个@PathVariable(&quot;id&quot;) Integer courseId来拿到. @RequestParam既处理get 方式中queryString的值，也可以处理post方式中 body data的值，即(@RequestParam(&quot;courseId&quot;)可以处理:123456&lt;a href=\"&#123;pageContext.request.contextPath &#125;/requestparam?courseId=4\"&gt;&lt;/a&gt;或&lt;form action=\"$&#123;pageContext.request.contextPath &#125;/requestparam\" method=\"post\"&gt; &lt;input type=\"text\" name=\"courseId\" &gt; &lt;input type=\"submit\" value=\"提交\" &gt;&lt;/form&gt; @ModelAttribute 用于方法:用来在处理@RequestMapping之前，为请求绑定需要从后台查询的model，例子如下:12345678910@ModelAttribute(\"countryList\")public Map&lt;String, String&gt; getCountryList()&#123; Map&lt;String, String&gt; countryList = new HashMap&lt;String, String&gt;(); countryList.put(\"US\", \"United States\"); countryList.put(\"CH\", \"China\"); countryList.put(\"SG\", \"Singapore\"); countryList.put(\"MY\", \"Malaysia\"); return countryList;&#125; 前台可以直接获取map里的值:1234&lt;form:select path=\"country\"&gt; &lt;form:option value=\"NONE\" label=\"请选择...\" /&gt; &lt;form:options items=\"$&#123;countryList&#125;\" /&gt;&lt;/form:select&gt;&lt;/td&gt; 同于参数：和@RequestParam类似，不过比这个更方便，不仅可以获取参数，还可封装到对象中:前台:12345678910111213&lt;form:form method=\"POST\" action=\"$&#123;pageContext.request.contextPath &#125;/addUser\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;label&gt;密码：&lt;/label&gt;&lt;/td&gt; &lt;td&gt;&lt;form:password path=\"password\" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;label&gt;地址：&lt;/label&gt;&lt;/td&gt; &lt;td&gt;&lt;form:textarea path=\"address\" rows=\"5\" cols=\"30\" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form:form&gt; 后台获取：12345@RequestMapping(value=\"/addUser\",method=RequestMethod.POST) public String addUser(@ModelAttribute Student student,ModelMap model)&#123; //do something.... return \"userlist\"; &#125; @RequestBody该注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到要返回的对象上 ，再把HttpMessageConverter返回的对象数据绑定到 controller中方法的参数上**该注解常用来处理Content-Type: 不是application/x-www-form-urlencoded编码的内容，例如application/json, application/xml等； 例如用异步处理： 后台 12345@RequestMapping(value=\"/ajax\",method=RequestMethod.POST)@ResponseBodypublic Course ajax(@RequestBody Course course)&#123; return course;&#125; 前台 1234567891011function ajax() &#123; $.ajax(&#123; url:\" hello/ajax\", data:JSON.stringify(&#123;'id':2,'cname':'语文','teacher':'djh'&#125;), type:'post', contentType:\"application/json\", success: function(data)&#123; alert(data); &#125; &#125;) &#125; 注意：这里data必须为字符串，否则会报Unrecognized token ‘xxx’: was expecting (‘true’, ‘false’ or ‘null’) @ResponseBody该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。 了解更多内容请看:@RequestParam @RequestBody @PathVariable 等参数绑定注解详解@RequestBody, @ResponseBody 注解详解SpringMVC @ResponseBody和@RequestBody使用","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://super3h.me/tags/SpringMVC/"},{"name":"Annotation","slug":"Annotation","permalink":"https://super3h.me/tags/Annotation/"}]},{"title":"Spring MVC多解析器映射","date":"2017-03-27T14:41:17.492Z","path":"2017/03/27/Spring MVC多解析器映射/","text":"Spring MVC多解析器映射 MultipleResolver-servlet.xml 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd\"&gt; &lt;context:component-scan base-package=\"com.hhh\"&gt;&lt;/context:component-scan&gt; &lt;bean class=\"org.springframework.web.servlet.view.ResourceBundleViewResolver\"&gt; &lt;property name=\"basename\" value=\"views\"&gt;&lt;/property&gt; &lt;property name=\"order\" value=\"0\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt; &lt;property name=\"order\" value=\"1\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; order属性定义了视图解析器的排序。0作为第一解析器，1作为下一解析器，等等。 basename的值views对应src/views.properties，里面内容如下，这里联合controller一起解释： HelloController 12345678910111213141516package com.hhh.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;@Controllerpublic class HelloController&#123; @RequestMapping(value=\"/hello\",method=RequestMethod.GET) public String printHello(Model model)&#123; model.addAttribute(\"hello\", \"hello world\"); return \"hello\"; &#125;&#125; views.properties 12hello.(class)=org.springframework.web.servlet.view.JstlViewhello.url=/WEB-INF/jsp/a.jsp 对于/hello请求，DispatcherServlet会将请求转发到由views.properties中定义的hello对应的视图，也就是/WEB-INF/jsp/a.jsp，最后在a.jsp中显示。 这里“hello”是要匹配的视图名称。class指定视图类型，url是视图的位置。 详情可参看Spring MVC多解析器映射","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://super3h.me/tags/SpringMVC/"}]},{"title":"SpringMVC文件上传","date":"2017-03-26T13:35:24.388Z","path":"2017/03/26/SpringMVC文件上传/","text":"SpringMVC文件上传这里直接上代码： upload-servlet.xml1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd\"&gt; &lt;context:component-scan base-package=\"com.hhh\" /&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt; &lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;/bean&gt; &lt;/beans&gt; CommonsMultipartResolver文件上传所需的类，如若删去，会报如下错: 1java.lang.NullPointerException 定位到这一段:1FileCopyUtils.copy(upload.getFile().getBytes(), new File(storePath+\"\\\\\"+file.getOriginalFilename())); debug调试可知，前端文件传不进来: FileUploadController.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.hhh.controller;import java.io.File;import java.io.IOException;import javax.servlet.ServletContext;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.ModelMap;import org.springframework.util.FileCopyUtils;import org.springframework.validation.BindingResult;import org.springframework.validation.annotation.Validated;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.multipart.MultipartFile;import org.springframework.web.servlet.ModelAndView;import com.hhh.domain.FIleUpload;@Controllerpublic class FileUploadController &#123; @Autowired ServletContext context; @RequestMapping(value=\"/fileupload\",method=RequestMethod.GET) public ModelAndView fileUpload()&#123; return new ModelAndView(\"fileupload\",\"command\",new FIleUpload()); &#125; @RequestMapping(value=\"/success\",method=RequestMethod.POST) public String fileUploadPage(FIleUpload upload,BindingResult result,ModelMap model) throws IOException&#123; String realPath = context.getRealPath(\"\"); String basePath = realPath.substring(0,realPath.indexOf(\"\\\\.\")); String storePath = basePath+File.separator+context.getContextPath().substring(context.getContextPath().indexOf(\"/\")+1)+\"\\\\upload\"; if(result.hasErrors())&#123; return \"fileupload\"; &#125;else&#123; MultipartFile file = upload.getFile(); //文件写入 FileCopyUtils.copy(upload.getFile().getBytes(), new File(storePath+\"\\\\\"+file.getOriginalFilename())); String filename = file.getOriginalFilename(); model.addAttribute(\"filename\", filename); return \"success\"; &#125; &#125;&#125; 更详细的可参考SpringMVC上传文件的三种方式","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://super3h.me/tags/SpringMVC/"}]},{"title":"Spring MVC错误处理","date":"2017-03-25T11:28:11.259Z","path":"2017/03/25/Spring-MVC错误处理/","text":"Spring MVC错误处理以下示例将如何在使用Spring Web MVC框架的表单中使用错误处理和验证器 目录如下 相关代码 Person.java 1234567891011121314151617181920212223242526package com.hhh.domain;public class Person &#123; private Integer age; private String name; private Integer id; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; &#125; PersonValidator.java 12345678910111213141516171819package com.hhh.controller;import org.springframework.validation.Errors;import org.springframework.validation.ValidationUtils;import org.springframework.validation.Validator;import com.hhh.domain.Person;public class PersonValidator implements Validator&#123; public boolean supports(Class&lt;?&gt; clazz) &#123; return Person.class.isAssignableFrom(clazz); &#125; public void validate(Object obj, Errors errors) &#123; ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"name\", \"name\",\"Field name is required.\"); &#125;&#125; isAssignableFrom 是用来判断一个类Class1和另一个类Class2是否相同或是另一个类的超类或接口。通常调用格式是 12//调用者和参数都是 java.lang.Class 类型。Class1.isAssignableFrom (Class2) instanceof 是用来判断一个对象实例是否是一个类或接口的或其子类子接口的实例。 格式是： 12//第一个参数是对象实例名，第二个参数是具体的类名或接口名 oo instanceof TypeName 详情可看Class.isAssignableFrom与 instanceof 区别 rejectIfEmptyOrWhitespace12345678/** Parameters: errors - 错误实例 field - 被检验的字段 errorCode - 错误代号 defaultMessage - 出现错误时的提示消息 */rejectIfEmptyOrWhitespace(Errors errors,String field,String errorCode, String defaultMessage) 详情案例可看此处使用Spring的Validator接口进行校验 PersonController.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.hhh.controller;import java.util.Date;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.validation.BindingResult;import org.springframework.validation.Validator;import org.springframework.validation.annotation.Validated;import org.springframework.web.bind.WebDataBinder;import org.springframework.web.bind.annotation.InitBinder;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.servlet.ModelAndView;import com.hhh.domain.Person;@Controllerpublic class PersonController &#123; public PersonController()&#123; System.out.println(new Date().toString()); &#125; @Autowired @Qualifier(\"personValidator\") private Validator validator; @InitBinder private void initBinder(WebDataBinder binder)&#123; binder.setValidator(validator); &#125; @RequestMapping(value=\"/addPerson\",method=RequestMethod.GET) public ModelAndView person()&#123; return new ModelAndView(\"person\",\"command\",new Person()); &#125; @ModelAttribute(\"person\") public Person createStudentModel() &#123; Person person = new Person(); System.out.println(person); return person; &#125; @RequestMapping(value=\"/showPerson\",method=RequestMethod.POST) public String addPerson(@ModelAttribute(\"person\") @Validated Person person,BindingResult bindingResult,Model model)&#123; if (bindingResult.hasErrors()) &#123; return \"person\"; &#125; model.addAttribute(\"name\", person.getName()); model.addAttribute(\"age\", person.getAge()); model.addAttribute(\"id\", person.getId()); return \"result\"; &#125;&#125; @Qualifier 注解和 @Autowired 注解通过指定哪一个真正的 bean 将会被装配来消除混乱。 WebDataBinder是用来绑定请求参数到指定的属性编辑器.由于前台传到controller里的值是String类型的，当往Model里Set这个值的时候，如果set的这个属性是个对象，Spring就会去找到对应的editor进行转换，然后再SET进去。在需要日期转换的Controller中也会使用SpringMVC的注解@initbinder和Spring自带的WebDateBinder类来操作。可参考SpringMVC注解@initbinder解决类型转换问题 Model 是一个接口， 其实现类为ExtendedModelMap，继承了ModelMap类。 ModelMap:ModelMap对象主要用于传递控制方法处理数据到结果页面，也就是说我们把结果页面上需要的数据放到ModelMap对象中即可，他的作用类似于request对象的setAttribute方法的作用，用来在一个请求过程中传递处理的数据。通过以下方法向页面传递参数：addAttribute(String key,Object value);在页面上可以通过el变量方式$key或者bboss的一系列数据展示标签获取并展示modelmap中的数据。modelmap本身不能设置页面跳转的url地址别名或者物理跳转地址，那么我们可以通过控制器方法的返回值来设置跳转url地址别名或者物理跳转地址。 ModelAndViewModelAndView对象有两个作用： 设置转向地址,如下所示（这也是ModelAndView和ModelMap的主要区别） 1ModelAndView view = new ModelAndView(\"path:ok\"); 用于传递控制方法处理结果数据到结果页面，也就是说我们把需要在结果页面上需要的数据放到ModelAndView对象中即可，他的作用类似于request对象的setAttribute方法的作用，用来在一个请求过程中传递处理的数据。通过以下方法向页面传递参数： 1addObject(String key,Object value); 在页面上可以通过el变量方式$key或者bboss的一系列数据展示标签获取并展示ModelAndView中的数据。 注意:123456@ModelAttribute(\"person\") public Person createStudentModel() &#123; Person person = new Person(); System.out.println(person); return person; &#125; 这段代码必须配合前台jsp中的commandName=&quot;person&quot;一起使用，否则会报错 以下这段错误处理，也必须配合以上的两者一起使用，否则会报错 1Neither BindingResult nor plain target object for bean name &apos;command&apos; available as request attribute 123if (bindingResult.hasErrors()) &#123; return \"person\";&#125; 通过实验发现 12345//@ModelAttribute(\"person\")可改为@ModelAttribute，也能获取前台数据，和createStudentModel()方法无关public String addPerson(@ModelAttribute(\"person\") @Validated Person person,BindingResult bindingResult,Model model)&#123; if (bindingResult.hasErrors()) &#123; return \"person\"; &#125; person.jsp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"http://www.springframework.org/tags/form\" prefix=\"form\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;style&gt;.error &#123; color: #ff0000;&#125;.errorStyle &#123; color: #000; background-color: #ffEEEE; border: 3px solid #ff0000; padding: 8px; margin: 16px;&#125;&lt;/style&gt;&lt;body&gt; &lt;h2&gt;学生信息&lt;/h2&gt; &lt;form:form method=\"POST\" action=\"$&#123;pageContext.request.contextPath &#125;/showPerson\" commandName=\"person\"&gt; &lt;form:errors path=\"*\" cssClass=\"errorStyle\" element=\"div\" /&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;form:label path=\"name\"&gt;姓名：&lt;/form:label&gt;&lt;/td&gt; &lt;td&gt;&lt;form:input path=\"name\" /&gt;&lt;/td&gt; &lt;td&gt;&lt;form:errors path=\"name\" cssClass=\"error\" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;form:label path=\"age\"&gt;年龄：&lt;/form:label&gt;&lt;/td&gt; &lt;td&gt;&lt;form:input path=\"age\" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;form:label path=\"id\"&gt;编号：&lt;/form:label&gt;&lt;/td&gt; &lt;td&gt;&lt;form:input path=\"id\" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"2\"&gt;&lt;input type=\"submit\" value=\"提交\" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form:form&gt;&lt;/body&gt;&lt;/html&gt; result.jsp 1234567891011121314151617181920212223242526&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;Submitted Student Information&lt;/h2&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;姓名：&lt;/td&gt; &lt;td&gt;$&#123;name&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;年龄：&lt;/td&gt; &lt;td&gt;$&#123;age&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;编号：&lt;/td&gt; &lt;td&gt;$&#123;id&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 这里想看hibernate验证器可点击Spring MVC Hibernate验证器 总结单例springmvc中控制器，即我们的PersonController为单例 运行过程通过debug调试得知 当输入 MVC错误处理/2.png 先跳转到 在之后 设置我们的验证器，并获取ServletRequestDataBinder对象 当我们提交后：然后继续进入createStudentModel和initBinder，在之后进入: 可以看出我们的错误: 之后报错: 123if (bindingResult.hasErrors()) &#123; return \"person\"; &#125; 返回的person，跳到person.jsp，并显示错误!!","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://super3h.me/tags/SpringMVC/"}]},{"title":"Python的with 语句","date":"2017-03-25T04:47:09.357Z","path":"2017/03/25/Python的with 语句/","text":"前言with 语句是被设计用来简化“try / finally”语句的。通常的用处在于共享资源的获取和释放，比如文件、数据库和线程资源。它的用法如下：12with context_exp [as var]: with_suit with 语句解释with 语句也是复合语句的一种，就像 if、try 一样，它的后面也有个“：”，并且紧跟一个缩进的代码块 with_suit。 context_exp 表达式的作用是提供一个上下文管理器（Context Manager），整个 with_suit 代码块都是在这个上下文管理器的运行环境下执行的。context_exp 可以直接是一个上下文管理器的引用，也可以是一句可执行的表达式，with 语句会自动执行这个表达式以获得上下文管理对象。with 语句的实际执行流程是这样的： 执行 context_exp 以获取上下文管理器 加载上下文管理器的__exit__() 方法以备稍后调用 调用上下文管理器的 __enter__() 方法 如果有 as var 从句，则将 __enter__() 方法的返回值赋给 var 执行子代码块with_suit 调用上下文管理器的__exit__() 方法，如果 with_suit 的退出是由异常引发的，那么该异常的 type、value 和 traceback 会作为参数传给 __exit__()，否则传三个 None 如果 with_suit 的退出由异常引发，并且 __exit__()的返回值等于 False，那么这个异常将被重新引发一次；如果 __exit__()的返回值等于 True，那么这个异常就被无视掉，继续执行后面的代码 原文参考更详细内容请看:Python 中的 with 语句与上下文管理器","tags":[{"name":"Python2","slug":"Python2","permalink":"https://super3h.me/tags/Python2/"}]},{"title":"SpringMVC表单","date":"2017-03-24T13:05:56.716Z","path":"2017/03/24/SpringMVC表单/","text":"SpringMVC表单过程中所遇问题 报错如下 1The request sent by the client was syntactically incorrect. 前台提交form，tomcat返回 http status 400 The request sent by the client was syntactically incorrect，控制台无任何错误输出。 原因:这是因为前台form表单中的某些参数 和 后台接受的参数类型不一致导致的。即参数名称相同，但是类型不一致。spring mvc在绑定参数的时候出现异常，所以返回400错误。但是坑爹的地方在于，这个异常会被spring mvc吃掉，不会显示在控制台中。 解决办法:检查form表单中的参数和后台的参数对应，看是否有参数名相同但是类型不一致的情况。或者把当前日志设为debug 级别，然后在日志中即可看到spring 抛出的异常信息，即可发现哪个参数出现了错误。 详细内容可参考:Spring MVC 遇到的问题集锦 关于@ModelAttribute注解1234567@RequestMapping(value=\"/addStudent\",method=RequestMethod.POST) public String addStudent(@ModelAttribute Student student,ModelMap model) &#123; model.addAttribute(\"name\", student.getName()); model.addAttribute(\"age\", student.getAge()); model.addAttribute(\"id\", student.getId()); return \"result\"; &#125; 在这个例子里，@ModelAttribute User user中@ModelAttribute将前台表单的值封装到user中 更详细的内容:spring学习之@ModelAttribute运用详解 ModelAndView对象解析1234@RequestMapping(value=\"/asstudent\",method=RequestMethod.GET) public ModelAndView showStudent()&#123; return new ModelAndView(\"student\",\"command\",new Student()); &#125; 解析ModelAndView对象，我们从源码入手 1234567891011/** * Convenient constructor to take a single model object. * @param viewName name of the View to render, to be resolved * by the DispatcherServlet's ViewResolver * @param modelName name of the single entry in the model * @param modelObject the single model object */ public ModelAndView(String viewName, String modelName, Object modelObject) &#123; this.view = viewName; addObject(modelName, modelObject); &#125; 官方文档说的很清楚，第一个String参数为返回的视图名，也就是说:我们访问 localhost:8080/项目名/asstudent Spring 会根据视图名跳转到/WEB-INF/jsp/viewName.jsp，modelName:所需要封装的参数名，modelObject:所需封装的对象注意:modelName必须使用’command’ ，因为如果在JSP文件中使用&lt;form:form&gt;标签，spring框架需要一个名称为“command”的对象 SpringMVC静态页面代码解析代码如下:1234@RequestMapping(value=\"/staticPage\",method=RequestMethod.GET) public String redirect()&#123; return \"redirect:/aaa/final.html\"; &#125; 12&lt;mvc:resources location=\"/WEB-INF/pages/\" mapping=\"/aaa/**\"/&gt;&lt;mvc:annotation-driven /&gt; 当访问 /staticPage 时，根据返回值 redirect:/aaa/final.html 重定向到 /aaa/final.html ，由配置文件知 /aaa/** 映射到 /WEB-INF/pages/ ，所以最后找到/WEB-INF/pages/final.html。 &lt;mvc:annotation-driven/&gt;&lt;mvc:annotation-driven/&gt;是告知Spring，我们启用注解驱动。然后Spring会自动为我们注册上面说到的几个Bean到工厂中，来处理我们的请求。 详情可看:Spring MVC 解读——&lt;mvc:annotation-driven/&gt;，作者讲的非常清晰","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://super3h.me/tags/SpringMVC/"}]},{"title":"SpringMVC初学","date":"2017-03-24T06:24:22.452Z","path":"2017/03/24/SpringMVC初学/","text":"SpringMVC框架介绍 Spring的MVC框架主要由DispatcherServlet、处理器映射、处理器(控制器)、视图解析器、视图组成。 SpringMVC原理图 1.Http请求： 客户端请求提交到DispatcherServlet。 2.寻找处理器：由DispatcherServlet控制器查询一个或多个HandlerMapping，找到处理请求的Controller。 3.调用处理器：DispatcherServlet将请求提交到Controller。 4、5、调用业务处理和返回结果：Controller调用业务逻辑处理后，返回ModelAndView。 6、7、处理视图映射并返回模型： DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图。 8.Http响应：视图负责将结果显示到客户端。 SpringMVC接口解释 DispatcherServlet接口：&lt;font color=&apos;#48B492&apos;&gt;Spring提供的前端控制器，所有的请求都有经过它来统一分发。在DispatcherServlet将请求分发给Spring Controller之前，需要借助于Spring提供的HandlerMapping定位到具体的Controller。&lt;/font&gt; HandlerMapping接口：&lt;font color=&apos;#48B492&apos;&gt;能够完成客户请求到Controller映射。&lt;/font&gt; Controller接口：&lt;font color=&apos;#48B492&apos;&gt;需要为并发用户处理上述请求，因此实现Controller接口时，必须保证线程安全并且可重用。 Controller将处理用户请求，这和Struts Action扮演的角色是一致的。一旦Controller处理完用户请求，则返回ModelAndView对象给DispatcherServlet前端控制器，ModelAndView中包含了模型（Model）和视图（View）。 从宏观角度考虑，DispatcherServlet是整个Web应用的控制器；从微观考虑，Controller是单个Http请求处理过程中的控制器，而ModelAndView是Http请求过程中返回的模型（Model）和视图（View）。&lt;/font&gt; ViewResolver接口：&lt;font color=&apos;#48B492&apos;&gt;Spring提供的视图解析器（ViewResolver）在Web应用中查找View对象，从而将相应结果渲染给客户。&lt;/font&gt; DispatcherServlet DispatcherServlet是整个Spring MVC的核心。它负责接收HTTP请求组织协调Spring MVC的各个组成部分。其主要工作有以下三项： 截获符合特定格式的URL请求。 初始化DispatcherServlet上下文对应的WebApplicationContext，并将其与业务层、持久化层的WebApplicationContext建立关联。 初始化Spring MVC的各个组成组件，并装配到DispatcherServlet中。 web-xml配置解释123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" id=\"WebApp_ID\" version=\"3.1\"&gt; &lt;display-name&gt;SpringMVC_day01&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloWeb&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;WEB-INF/spring/HelloWeb-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloWeb&lt;/servlet-name&gt; &lt;url-pattern&gt;&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; init-param: HelloWeb DispatcherServlet初始化时，框架将尝试从位于应用程序的WebContent/WEB-INF目录中的名为[servlet-name]-servlet.xml的文件加载应用程序上下文。 这里我们配置此参数，让其从WEB-INF/spring/HelloWeb-servlet.xml下读取配置文件 load-on-startup: 当值为0或者大于0时，表示容器在应用启动时就加载这个servlet； 当是一个负数时或者没有指定时，则指示容器在该servlet被选择时才加载。 正数的值越小，启动该servlet的优先级越高 HelloWeb-servlet.xml1234567891011121314151617&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd\"&gt; &lt;context:component-scan base-package=\"com.yiibai\" /&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt;&lt;/beans&gt; 以下是有关HelloWeb-servlet.xml文件的重点说明： [servlet-name]-servlet.xml文件将用于创建定义的bean，它会覆盖在全局范围中使用相同名称定义的任何bean的定义 &lt;context：component-scan ...&gt;标签将用于激活Spring MVC注释扫描功能，允许使用@Controller和@RequestMapping等注释。 InternalResourceViewResolver将定义用于解析视图名称的规则。prefix：定位文件所在位置，suffix:文件后缀。根据上面定义的规则，hello的逻辑视图将委托给位于/WEB-INF/jsp/hello.jsp这个视图来实现。 Controller解释1234567891011121314151617package com.hhh.springmvc;import org.springframework.stereotype.Controller;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;@Controller@RequestMapping(value=\"/hello\")public class HelloController &#123; @RequestMapping(method=RequestMethod.GET) public String printHello(ModelMap modelMap)&#123; modelMap.put(\"message\", \"hello spring mvc\"); return \"hello\"; &#125;&#125; @Controller注释将类定义为Spring MVC控制器。这里@RequestMapping的第一个用法表示此控制器上的所有处理方法都与/hello路径相关。 下一个注释@RequestMapping(method = RequestMethod.GET)用于声明printHello()方法作为控制器的默认服务方法来处理HTTP GET请求。可以定义另一个方法来处理同一URL的任何POST请求。可以以另一种形式在上面的控制器中编写，在@RequestMapping中添加其他属性，如下所示： 12345678910111213141516package com.hhh.springmvc;import org.springframework.stereotype.Controller;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;@Controllerpublic class HelloController &#123; @RequestMapping(value=\"/hello\",method=RequestMethod.GET) public String printHello(ModelMap modelMap)&#123; modelMap.put(\"message\", \"hello spring mvc\"); return \"hello\"; &#125;&#125; value属性指示处理程序方法映射到的URL，method属性定义处理HTTP GET请求的服务方法。关于以上定义的控制器，需要注意以下几点： 在服务方法中定义所需的业务逻辑。可以根据需要在此方法内调用其他方法 基于定义的业务逻辑，将在此方法中创建一个模型。可以设置不同的模型属性，这些属性将被视图访问以呈现最终结果。此示例创建且有属性“message”的模型。 定义的服务方法可以返回一个String，它包含要用于渲染模型的视图的名称。此示例将“hello”返回为逻辑视图名称。 创建JSP视图 Spring MVC支持许多类型的视图用于不同的表示技术。包括 - JSP，HTML，PDF，Excel工作表，XML，Velocity模板，XSLT，JSON，Atom 和 RSS 源，JasperReports等。但最常见的是使用JSPL编写的JSP模板，这里使用的是JSP模板，并在/WEB-INF/hello/hello.jsp中写一个简单的hello视图： 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;Hello Spring MVC&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;$&#123;message&#125;&lt;/h2&gt; &lt;/body&gt;&lt;/html&gt; 这里${message}是在Controller中设置的属性。可以在视图中显示多个属性。 参考链接【Spring】Spring MVC原理及配置详解SpringMVC工作原理Spring MVC概述","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://super3h.me/tags/SpringMVC/"}]},{"title":"python的字节与字符","date":"2017-03-23T01:05:55.623Z","path":"2017/03/23/python的字节与字符/","text":"str与unicode Python2 把字符串分为 unicode 和 str 两种类型。本质上 str 是一串二进制字节序列，下面的示例代码可以看出 str 类型的 “禅” 打印出来是十六进制的 \\xec\\xf8 ，对应的二进制字节序列就是 ‘11101100 11111000’。 12345&gt;&gt;&gt; s = '禅'&gt;&gt;&gt; s'\\xec\\xf8'&gt;&gt;&gt; type(s)&lt;type 'str'&gt; 而 unicode 类型的 u”禅” 对应的 unicode 符号是 u’\\u7985’ 12345&gt;&gt;&gt; u = u\"禅\"&gt;&gt;&gt; uu'\\u7985'&gt;&gt;&gt; type(u)&lt;type 'unicode'&gt; 我们要把 unicode 符号保存到文件或者传输到网络就需要经过编码处理转换成 str 类型，于是 python 提供了 encode 方法，从 unicode 转换到 str，反之亦然。 encode与decode encode 12345&gt;&gt;&gt; u = u\"禅\"&gt;&gt;&gt; uu'\\u7985'&gt;&gt;&gt; u.encode(\"utf-8\")'\\xe7\\xa6\\x85' decode 1234&gt;&gt;&gt; s = \"禅\"&gt;&gt;&gt; s.decode(\"utf-8\")u'\\u7985'&gt;&gt;&gt; unicode 到 str 的转换要用 encode 方法，反过来就是用 decode 方法 UnicodeEncodeError UnicodeEncodeError 发生在 unicode 字符串转换成 str 字节序列的时候，来看一个例子，把一串 unicode 字符串保存到文件 12345678# -*- coding:utf-8 -*-def main(): name = u'Python之禅' f = open(\"output.txt\", \"w\") f.write(name)# 错误如下UnicodeEncodeError: 'ascii' codec can't encode characters in position 6-7: ordinal not in range(128) 原因:因为调用 write 方法时，Python 会先判断字符串是什么类型，如果是 str，就直接写入文件，不需要编码，因为 str 类型的字符串本身就是一串二进制的字节序列了。 如果字符串是 unicode 类型，那么它会先调用 encode 方法把 unicode 字符串转换成二进制形式的 str 类型，才保存到文件，而 encode 方法会使用 python 默认的 ascii 码来编码相当于： 1&gt;&gt;&gt; u\"Python之禅\".encode(\"ascii\") 但是，我们知道 ASCII 字符集中只包含了128个拉丁字母，不包括中文字符，因此 出现了 ‘ascii’ codec can’t encode characters 的错误。要正确地使用 encode ，就必须指定一个包含了中文字符的字符集，比如：UTF-8、GBK。 12345&gt;&gt;&gt; u\"Python之禅\".encode(\"utf-8\")'Python\\xe4\\xb9\\x8b\\xe7\\xa6\\x85'&gt;&gt;&gt; u\"Python之禅\".encode(\"gbk\")'Python\\xd6\\xae\\xec\\xf8' 所以要把 unicode 字符串正确地写入文件，就应该预先把字符串进行 UTF-8 或 GBK 编码转换。 12345def main(): name = u'Python之禅' name = name.encode('utf-8') with open(\"output.txt\", \"w\") as f: f.write(name) UnicodeDecodeError UnicodeDecodeError 发生在 str 类型的字节序列解码成 unicode 类型的字符串时 12345678910&gt;&gt;&gt; a = u\"禅\"&gt;&gt;&gt; au'\\u7985'&gt;&gt;&gt; b = a.encode(\"utf-8\")&gt;&gt;&gt; b'\\xe7\\xa6\\x85'&gt;&gt;&gt; b.decode(\"gbk\")Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;UnicodeDecodeError: 'gbk' codec can't decode byte 0x85 in position 2: incomplete multibyte sequence 把一个经过 UTF-8 编码后生成的字节序列 ‘\\xe7\\xa6\\x85’ 再用 GBK 解码转换成 unicode 字符串时，出现 UnicodeDecodeError，因为 （对于中文字符）GBK 编码只占用两个字节，而 UTF-8 占用3个字节，用 GBK 转换时，还多出一个字节，因此它没法解析。避免 UnicodeDecodeError 的关键是保持 编码和解码时用的编码类型一致。 再举一个 UnicodeDecodeError 的例子 1234567&gt;&gt;&gt; x = u\"Python\"&gt;&gt;&gt; y = \"之禅\"&gt;&gt;&gt; x + yTraceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;UnicodeDecodeError: 'ascii' codec can't decode byte 0xe4 in position 0: ordinal not in range(128)&gt;&gt;&gt; str 与 unicode 字符串 执行 + 操作是，Python 会把 str 类型的字节序列隐式地转换成（解码）成 和 x 一样的 unicode 类型，但Python是使用默认的 ascii 编码来转换的，而 ASCII 中不包含中文，所以报错了。 1234&gt;&gt;&gt; y.decode('ascii')Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;UnicodeDecodeError: 'ascii' codec can't decode byte 0xe4 in position 0: ordinal not in range(128) 正确地方式应该是显示地把 y 用 UTF-8 或者 GBK 进行解码。 12345&gt;&gt;&gt; x = u\"Python\"&gt;&gt;&gt; y = \"之禅\"&gt;&gt;&gt; y = y.decode(\"utf-8\")&gt;&gt;&gt; x + yu'Python\\u4e4b\\u7985' 原文参考 Python 编码为什么那么蛋疼？，感谢作者让我理解了一直困惑我的问题！！！详解 python 中文编码与处理","tags":[{"name":"Python2","slug":"Python2","permalink":"https://super3h.me/tags/Python2/"}]},{"title":"爬虫-爬取学校官网","date":"2017-03-19T14:40:10.986Z","path":"2017/03/19/爬虫-爬取学校官网/","text":"前言 之前断断续续的学习爬虫，结果忘得差不多了，现在重新开始认真学，公众号也要认真弄了，之前做了就一直没管 哈哈 就图个装逼！！ 结构分析 正常的登录界面，可以写出以下代码: 初始化1234567# 传入对应用户名(studentnumber),密码(password),学校官网(schoolURL)def __init__(self,studentnumber,password,schoolURL): self.studentnumber = studentnumber self.password = password self.schoolURL = schoolURL resp = requests.get(schoolURL) self.sl = etree.HTML(resp.content) 接下来就是验证码了，由于并没有找到好的库来识别验证码，就采用人工输入好了，就像超级课程表那样 验证码123456789101112#拿到图片 def getCheckCode(self): imgURL = self.schoolURL+'/CheckCode.aspx' imgResp = requests.get(imgURL, stream=True) image = imgResp.content try: with open('code.jpg','wb') as f: f.write(image) except IOError,e: print(\"IO Error:%s\" % e) finally: f.close() 拿到图片，并下载到本地 数据准备 由图可知所需发送的数据: 1234567891011121314151617def getData(self,checkCode): VIEWSTATE = self.sl.xpath('//input[@name=\"__VIEWSTATE\"]/@value')[0] VIEWSTATEGENERATOR = self.sl.xpath('//input[@name=\"__VIEWSTATEGENERATOR\"]/@value')[0] data = &#123; '__VIEWSTATE': VIEWSTATE, '__VIEWSTATEGENERATOR': VIEWSTATEGENERATOR, 'txtUserName': self.studentnumber, 'Textbox1': '', 'Textbox2': self.password, 'txtSecretCode': checkCode, 'RadioButtonList1':u'学生'.encode('gb2312'), 'Button1':'', 'lbLanguage':'', 'hidPdrs':'', 'hidsc':'' &#125; return data 登录 登录并拿到登陆者的姓名 1234567891011def login(self,checkCode): headers = &#123; \"User-Agent\":\"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.110 Safari/537.36\", &#125; data = self.getData(checkCode) #登陆教务系统 response = requests.post(self.schoolURL,data=data,headers=headers) successSl = etree.HTML((response.content).decode('gb2312'))# print response.encoding# 去除登陆者姓名同学两字(xxx同学) self.name = successSl.xpath('//span[@id=\"xhxm\"]/text()')[0][:-2] 登录，并拿到登录者姓名 进入课表页面 可知queryString为tjkbcx.aspx?xh=2014115010127&amp;xm=黄辉辉&amp;gnmkdm=N121601，代码如下: 12345678910111213141516171819def getCourse(self): #tjkbcx.aspx?xh=2014115010127&amp;xm=黄辉辉&amp;gnmkdm=N121601 courseString = &#123; 'xh':self.studentnumber, 'xm':self.name, 'gnmkdm':'N121601' &#125; baseURL = \"tjkbcx.aspx?%s\" % urllib.urlencode(courseString) courseURL = self.schoolURL+baseURL# print courseURL #必须要有Referer这个参数，否者跳到登录页面 headers = &#123; \"Referer\":\"http://www.jwgl.hbnu.edu.cn/(qsyyr145roe1hwvyfoylp445)/default2.aspx\", \"User-Agent\":\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36\", &#125; contents = resp.content.decode('gb2312') sl = etree.HTML(contents) for course in sl.xpath('//td/text()'): print course 由于表格样式不好调试，可以通过截屏拿到课表 123driver = webdriver.PhantomJS()driver.get(courseURL)driver.save_screenshot(\"course.jpg\") 由于缺少请求头，上网查后发现: 12345dcap = dict(DesiredCapabilities.PHANTOMJS)dcap[\"phantomjs.page.settings.userAgent\"] = ( \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36\" )driver = webdriver.PhantomJS(desired_capabilities=dcap) 由于请求头还缺少referer，导致跳转到登录页面，最后截图成了登录页面。。。。我也是醉了，找了我一下午，还没找到，有网友找到后，请告知，谢啦！！ 所遇问题 解决中文编码1sel.xpath(u\"//h2[text()= 'xx']\") 参考链接python爬虫正方教务系统爬虫：3. selenium","tags":[{"name":"Python","slug":"Python","permalink":"https://super3h.me/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://super3h.me/tags/爬虫/"}]},{"title":"Js技巧","date":"2017-03-14T06:07:29.548Z","path":"2017/03/14/Js技巧/","text":"导航菜单div的切换原理 通过点击事件将div属性由display:none;变为display:block 样式布局如下:123456789101112131415161718192021222324252627282930313233343536373839404142&lt;el-row&gt; &lt;el-col :span=\"4\"&gt; &lt;el-menu default-active=\"1\"&gt; &lt;a href=\"#question\"&gt; &lt;el-menu-item index=\"1\" style=\"padding-left:100px ;\"&gt; 提问 &lt;/el-menu-item&gt; &lt;/a&gt; &lt;a href=\"#add\"&gt; &lt;el-menu-item index=\"2\" style=\"padding-left:100px ;\"&gt; 添加 &lt;/el-menu-item&gt; &lt;/a&gt; &lt;a href=\"#answer\"&gt; &lt;el-menu-item index=\"3\" style=\"padding-left:100px ;\"&gt; 答案 &lt;/el-menu-item&gt; &lt;/a&gt; &lt;a href=\"#query\"&gt; &lt;el-menu-item index=\"4\" style=\"padding-left:100px ;\"&gt; 查询 &lt;/el-menu-item&gt; &lt;/a&gt; &lt;/el-menu&gt; &lt;/el-col&gt; &lt;el-col :span=\"20\"&gt; &lt;div&gt; &lt;div class=\"checkOutDiv\" style=\"display: block;\" id=\"answer\"&gt; &lt;h1&gt;index-1&lt;/h1&gt; &lt;/div&gt; &lt;div class=\"checkOutDiv\" style=\"display: none;\" id=\"answer\"&gt; &lt;h1&gt;index-2&lt;/h1&gt; &lt;/div&gt; &lt;div class=\"checkOutDiv\" style=\"display: none;\" id=\"answer\"&gt; &lt;h1&gt;index-3&lt;/h1&gt; &lt;/div&gt; &lt;div class=\"checkOutDiv\" style=\"display: none;\" id=\"query\"&gt; &lt;h1&gt;index-4&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;/el-col&gt;&lt;/el-row&gt; js代码逻辑1234567891011121314151617$(function() &#123; //给每个a标签添加click事件 $(\"a\").bind(\"click\", function() &#123; //拿到a标签中 href属性的值 var $clickElement = $(this).attr(\"href\"); //遍历所有div $.each($(\".checkOutDiv\"), function() &#123; //获得div中id属性的值 var $checkOut = $(this).attr(\"id\"); if($clickElement.indexOf($checkOut) != -1) &#123; //如果a标签的href属性包含div标签的id的值(不包含返回-1)，则显示 $(this).attr(\"style\", \"display: block;\"); &#125; else &#123; $(this).attr(\"style\", \"display: none;\"); &#125; &#125;) &#125;)&#125;) 详细过程如上，举个例子:点击&lt;a href=&quot;#question&quot;&gt;时,拿到href的值，即#question，此时查询所有div的id，若id=question时，发现#question包含question，则改变div属性dispalay:block js实现表单提交和重置 代码如下: 1234//重置document.getElementById(formName).reset();//提交document.getElementById(formName).submit(); js正则表达式替换 博主这里要把图片对应的url换一下 12&lt;img src=\"img/1_1.jpg\"/&gt;&lt;img src=\"img/2_1.jpg\"/&gt; js的replace可以使用正则替换,将_1替换成_2，默认会全文搜索 1234567$.each($(\"img\"), function() &#123; $(this).bind(\"mousemove\",function()&#123; var $src = $(this).attr(\"src\"); var changeSrc = $src.replace(/_\\d/,\"_2\"); $(\"#showArea\").html(\"&lt;img src=\"+changeSrc+\" style='width:200px;height:300px' id='imgEnlarge' /&gt;\") &#125;) &#125;); 判断元素内是否有内容或者有某个标签判断文本是否为空1234var jqObj = $(this);if(jqObj.text().trim())&#123; //trim()方法是去空格，$.trim()函数删除提供字符串的所有换行符,空格（包括非中断空格），开始和结束tab。如果这些空白字符在字符串中间发生时，它们将被保留。 jqObj.hide();&#125; 判断这个标签下是否有某个已知的元素，比如判断ul标签下是否有li元素1234var jqObj = $(this);if(!jqObj.has('li').length)&#123; jqObj.hide();&#125; JQuery判断一个元素下面是否有内容或者有某个标签感谢这位作者解决了我的困惑，真诚的感谢，哈哈! mousemove事件获取鼠标位置 直接上代码 1234$(\"#showArea\").mousemove(function(e)&#123; e.pageX;//鼠标x轴 e.pageX;//鼠标y轴 &#125;)","tags":[{"name":"js","slug":"js","permalink":"https://super3h.me/tags/js/"}]},{"title":"idea学习","date":"2017-03-14T01:17:11.621Z","path":"2017/03/14/idea学习/","text":"软件安装 直接进入官网下载即可IntelliJ IDEA 破解方案 IntelliJ IDEA 注册码 IntelliJ IDEA 永久破解的方法 方案二中由于github下载超慢，这里把云盘地址贴出来注册机:密码:5jz1 软件快捷键设置Intellij IDEA 快捷键整理（TonyCody）IntelliJ Idea 快捷键映射","tags":[{"name":"idea","slug":"idea","permalink":"https://super3h.me/tags/idea/"}]},{"title":"在网页中使用markdown","date":"2017-03-12T13:38:28.061Z","path":"2017/03/12/在网页中使用markdown/","text":"前言 博客既然能用markdown编写，能否直接在网上编写呢，答案当然是可以，去github搜索一下即可找到editor.md，国人开发哦！！ 使用方法下载后的目录如图 在examples文件夹中有一个简单的示例simple.html，可以在浏览器里打开，并查看源代码; 可得原代码为:1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;Simple example - Editor.md examples&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"css/style.css\" /&gt; &lt;link rel=\"stylesheet\" href=\"css/editormd.css\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"layout\"&gt; &lt;header&gt; &lt;h1&gt;Simple example&lt;/h1&gt; &lt;/header&gt; &lt;div id=\"test-editormd\"&gt; &lt;textarea style=\"display:none;\"&gt;### 这里插入内容&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=\"js/jquery.min.js\"&gt;&lt;/script&gt; &lt;script src=\"js/editormd.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var testEditor; $(function() &#123; testEditor = editormd(\"test-editormd\", &#123; //调整宽度 width: \"60%\", //调整高度 height: 400, syncScrolling: \"single\", path: \"./lib/\" &#125;); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 这里把目录改了下： lib：为根目录下的文件，直接复制即可 css：editormd.js在根目录css文件中，style.css在examples/css中 js：editormd.min.js在根目录下，jquery.min.js在examples\\js中 fonts：为根目录下的文件，直接复制即可 最后效果图 注意 当文件放在display:none的div下会导致格式(样式)出错 如何在页面中显示提交html代码 html代码如下:123456789101112131415161718&lt;!-- 静态加载 --&gt;&lt;input type=\"text\" name=\"pDescription\" class=\"editormd-html-textarea\"&gt;&lt;/input&gt;&lt;!-- 动态加载，特别实在引入js框架时采用此方法，否则界面会出错 --&gt;&lt;script type=\"text/javascript\"&gt; $.getScript(\"js/editormd.min.js\", function() &#123; $(\"#app-markdown\").html(\"&lt;div id=\\\"test-editormd\\\"&gt;&lt;textarea&gt;&lt;/textarea&gt;&lt;textarea name=\\\"description\\\"&gt;&lt;/textarea&gt;&lt;/div&gt;\"); testEditormd = editormd(\"test-editormd\", &#123; width : \"100%\", height : 300, path : \"lib/\", toolbarIcons : function() &#123; return [\"undo\", \"redo\", \"|\", \"bold\", \"hr\", \"|\", \"preview\", \"watch\"] &#125;, saveHTMLToTextarea : true, watch: false, &#125;); &#125;);&lt;/script&gt; js代码如下: 12var ohtml=$('.editormd-html-textarea'), opreview=$('.editormd-preview').clone(); ohtml.val(opreview.html()); 最后form表单提交，后台拿到pDescription的值即可 页面显示 引入前文(上面使用方法中有讲到)css样式即可显示！！效果如图","tags":[{"name":"js","slug":"js","permalink":"https://super3h.me/tags/js/"},{"name":"markdown","slug":"markdown","permalink":"https://super3h.me/tags/markdown/"}]},{"title":"s2sh-大学资源共享网项目","date":"2017-03-10T08:00:29.266Z","path":"2017/03/10/s2sh-大学资源共享网项目/","text":"所遇问题数据库错误 报如下错: 1Cannot add or update a child row: a foreign key constraint fails (`s2shtest01`.`problem`, CONSTRAINT `FK5lcmhm21chjl0wog8par6isxn` FOREIGN KEY (`pid`) REFERENCES `course` (`cid`)) 后来发现。。hibernate配置文件竟然写错了，如此低级的错误 12345678910111213&lt;class name=\"School\"&gt; &lt;id name=\"sid\"&gt; &lt;generator class=\"native\"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=\"sName\"&gt;&lt;/property&gt; &lt;set name=\"academys\"&gt; &lt;key&gt; &lt;!--&lt;column name=\"aid\"&gt;&lt;/column&gt;--&gt; &lt;column name=\"sid\"&gt;&lt;/column&gt; &lt;/key&gt; &lt;one-to-many class=\"Academy\"/&gt; &lt;/set&gt; &lt;/class&gt; 错误如上,&lt;key&gt;里为academys的外键。。结果把它的外键和自己的主键绑定到一起了。 json解决hibernate中级联对象延迟加载问题 简介 相信大部分用过Ext的GridPanel显示数据的朋友都遇到过外键数据的问题，首先是转换格式，将数据库里查出来的List集合要转换为JSON格式，如果只是用 12JSONObject json = new JSONObject(); JSONArray dataArray = JSONArray.fromObject(list); 原因: 如果list中的数据都是普通数据类型的那能正常转换，但很少这种情况，大部分的数据都存在外键的数据，比如有个News类，他可能会有个发布人User的外键，那么用以上的方法转换是不行，将会出现死循环（我去了解到JSON它是这么一种机制，将数据拆分，一致拆分到全都是基本数据类型位置，比如，一个list存放着多个News数据，它是首先将list拆分成多个News，然后将News的多个属性都拆分出来，里面有个User对象，又得再拆分！问题就出现在这了，User里面又有一个News的集合，News里面又有User，因此导致死循环了）； 解决方案 json解决hibernate中级联对象延迟加载问题net.sf.json.JSONException: org....在hibernate中将pojo转化为json数据格式时，抛出：net.sf.json.JSONException: org.hibernate.LazyInitializationException，通过网上的资料，解决办法如下(未列出所需库文件)： 第一种: 123456789101112JsonConfig jsonConfig = new JsonConfig(); jsonConfig .setJsonPropertyFilter(new PropertyFilter()&#123;public boolean apply(Object source, String name, Object value)&#123; if (name.equals(\"property1\") || name.equals(\"property2\"))&#123;// 这里填写需要过滤的属性名 return true; &#125; return false; &#125;&#125;);JSONObject jsonModel= JSONArray.fromObject(yourObject, jsonConfig ); 第二种: 123456JsonConfig jsonConfig = new JsonConfig();jsonConfig .setExcludes( new String[]&#123; \"property1\" , \"property2\" &#125; ) ;JSONObject jsonModel= JSONArray.fromObject(yourObject, jsonConfig );&#125; 详情请参考json解决hibernate中级联对象延迟加载问题net.sf.json.JSONException: c:forEach问题 报错如下: 1According to TLD or attribute directive in tag file, attribute value does not accept any exception 方法如下 一种是将http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd改成http://java.sun.com/xml/ns/javaee/web-app_2_3.xsd； 另一种是将JSP页面中的&lt;%@ taglib prefix=”c” uri=”http://java.sun.com/jstl/core&quot;%&gt;改成&lt;%@ taglib prefix=”c” uri=”http://java.sun.com/jstl/core_rt&quot;%&gt;。在jstl-1.0.2.jar下的META-INF中有一个c.tld还有一个c-rt.tld,后一个好像是jstl核心库备用板的标签描述文件。 参考如下:According to TLD or attribute directive in tag file","tags":[{"name":"J2EE","slug":"J2EE","permalink":"https://super3h.me/tags/J2EE/"},{"name":"Project","slug":"Project","permalink":"https://super3h.me/tags/Project/"}]},{"title":"java初始化顺序","date":"2017-03-09T06:53:22.326Z","path":"2017/03/09/java初始化顺序/","text":"子类继承父类实例化对象过程 代码示例: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Parent &#123; // 静态变量 public static String p_StaticField = \"父类--静态变量\"; // 变量(其实这用对象更好能体同这一点，如专门写一个类的实例) //如果这个变量放在初始化块的后面，是会报错的，因为你根本没有被初始化 public String p_Field = \"父类--变量\"; // 静态初始化块 static &#123; System.out.println(p_StaticField); System.out.println(\"父类--静态初始化块\"); &#125; // 初始化块 &#123; System.out.println(p_Field); System.out.println(\"父类--初始化块\"); &#125; // 构造器 public Parent() &#123; System.out.println(\"父类--构造器\"); &#125;&#125;public class SubClass extends Parent &#123; // 静态变量 public static String s_StaticField = \"子类--静态变量\"; // 变量 public String s_Field = \"子类--变量\"; // 静态初始化块 static &#123; System.out.println(s_StaticField); System.out.println(\"子类--静态初始化块\"); &#125; // 初始化块 &#123; System.out.println(s_Field); System.out.println(\"子类--初始化块\"); &#125; // 构造器 public SubClass() &#123; //super(); System.out.println(\"子类--构造器\"); &#125; // 程序入口 public static void main(String[] args) &#123; System.out.println(\"*************in main***************\"); new SubClass(); System.out.println(\"*************second subClass***************\"); new SubClass(); &#125;&#125; 输出结果: 12345678910111213141516171819输出结果父类--静态变量父类--静态初始化块子类--静态变量子类--静态初始化块*************in main***************父类--变量父类--初始化块父类--构造器子类--变量子类--初始化块子类--构造器*************second subClass***************父类--变量父类--初始化块父类--构造器子类--变量子类--初始化块子类--构造器 总结 累的加载过程不管多么复杂，总是按照-静态代码块-&gt;普通代码块-&gt;构造方法，这个顺序执行的，按照顺序一步步分析，将程序结构捋清楚就能避免不必要的错误。 原文链接 JAVA基础-子类继承父类实例化对象过程","tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://super3h.me/tags/JavaSE/"}]},{"title":"java错题总结","date":"2017-03-07T04:27:51.949Z","path":"2017/03/07/java错题总结/","text":"错题分析Integer的考察 在jdk1.5的环境下，有如下4条语句： 1234Integer i01 = 59;int i02 = 59;Integer i03 =Integer.valueOf(59);Integer i04 = new Integer(59) 以下输出结果为false的是： 解析如下: java类加载 以下哪项不属于java类加载过程？ 分析如下: equals 列出equals的源码 123public boolean equals(Object obj) &#123; return (this == obj); &#125; Object 中euqals的源码如上。没有重写equals时，是直接用==判断的，而String中重写了equals方法 wait()方法和 sleep()方法的区别 这两个方法来自不同的类分别是，sleep来自Thread类，和wait来自Object类。 sleep是Thread的静态类方法，谁调用的谁去睡觉，即使在a线程里调用了b的sleep方法，实际上还是a去睡觉，要让b线程睡觉要在b的代码中调用sleep。 最主要是sleep方法没有释放锁，而wait方法释放了锁，使得敏感词线程可以使用同步控制块或者方法。sleep不出让系统资源；wait是进入线程等待池等待，出让系统资源敏感词线程可以占用CPU。一般wait不会加时间限制，因为如果wait线程的运行资源不够，再出来也没用，要等待敏感词线程调用notify/notifyAll唤醒等待池中的所有线程，才会进入就绪队列等待OS分配系统资源。sleep(milliseconds)可以用时间指定使它自动唤醒过来，如果时间不到只能调用interrupt()强行打断。Thread.Sleep(0)的作用是“触发操作系统立刻重新进行一次CPU竞争”。 使用范围：wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用 1234synchronized(x)&#123; x.notify() //或者wait() &#125; sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常","tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://super3h.me/tags/JavaSE/"}]},{"title":"log4J的使用","date":"2017-03-02T08:33:38.706Z","path":"2017/03/02/log4J的使用/","text":"log4J的安装进入官网下载即可http://logging.apache.org/log4j/1.2/download.html log4J的配置及解释示例1234567891011121314151617181920# Define the root logger with appender filelog4j.rootLogger = DEBUG, FILE# Define the file appenderlog4j.appender.FILE=org.apache.log4j.FileAppender# Set the name of the filelog4j.appender.FILE.File=C:\\log.out# Set the immediate flush to true (default)log4j.appender.FILE.ImmediateFlush=true# Set the threshold to debug modelog4j.appender.FILE.Threshold=debug# Set the append to false, overwritelog4j.appender.FILE.Append=false# Define the layout for file appenderlog4j.appender.FILE.layout=org.apache.log4j.PatternLayoutlog4j.appender.FILE.layout.conversionPattern=%m%n 根日志记录器(logger)的级别定义为DEBUG并连接附加器命名为FILE 附加器(appender)File是定义为org.apache.log4j.FileAppender并写入到一个名为“log.out”位于日志log目录下 定义的布局模式是%m%n，这意味着每打印日志消息之后，将加上一个换行符 注意:log4j支持UNIX风格的变量替换，如 ${variableName}. 调试级别使用DEBUG两个追加程序。所有可能的选项有： TRACE DEBUG INFO WARN ERROR FATAL ALL Appenders Apache的log4j提供Appender对象主要负责打印日志消息到不同的目的地，如控制台，文件，sockets，NT事件日志等等。每个Appender对象具有与之相关联的不同的属性，并且这些属性表明对象的行为 属性 描述 layout Appender使用布局Layout 对象和与之相关的格式化的日志记录信息转换模式 target 目标可以是一个控制台，一个文件，或根据附加器的另一个项目 level 级别是必需的，以控制日志消息的过滤 threshold Appender可以有与之独立的记录器级别相关联的级别阈值水平。Appender忽略具有级别低于阈级别的任何日志消息 filter Filter 对象可以分析超出级别的匹配记录信息，并决定是否记录的请求应该由一个特定 Appender 或忽略处理 Layout我们使用的PatternLayout 使用 appender。所有可能的选项有： DateLayout HTMLLayout PatternLayout SimpleLayout XMLLayout 使用HTMLLayout和XMLLayout，可以在HTML和XML格式和生成日志。 参考链接 properties相关配置详情请看log4j配置 xml相关配置详情请看springmvc+log4j操作日志记录,详细配置 log4J配置文件位置默认加载 log4j启动时，默认会寻找source folder下的log4j.xml配置文件，若没有，会寻找log4j.properties文件。然后加载配置。配置文件放置位置正确，不用在程序中手动加载log4j配置文件。 手动加载配置文件 可以通过PropertyConfigurator.configure(&quot;url&quot;)来手动加载配置文件，示例如下: 相应代码如下:PropertyConfigurator.configure(&quot;config/log4j.properties&quot;); log4J报错 如果上述方法报以下错: 123456789log4j:ERROR Could not read configuration file [log4j.properties].java.io.FileNotFoundException: log4j.properties (系统找不到指定的文件。) at java.io.FileInputStream.open(Native Method) at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:106) at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:66) at org.apache.log4j.PropertyConfigurator.doConfigure(PropertyConfigurator.java:306) at org.apache.log4j.PropertyConfigurator.configure(PropertyConfigurator.java:324) at snmp.GetSnmpInfo.&lt;clinit&gt;(GetSnmpInfo.java:32)log4j:ERROR Ignoring configuration file [log4j.properties]. 解决方案: 方案1:将log4j.properties 这个文件从src的根目录 转移到 项目的根目录下面，即可~~~； 方案2:添加以下代码12345678// 获得当前目录路径 String filePath = this.getClass().getResource(\"/\").getPath(); // 找到log4j.properties配置文件所在的目录(已经创建好) filePath = filePath.substring(1).replace(\"bin\", \"src\"); // 获得日志类loger的实例 loger = Logger.getLogger(this.getClass()); // loger所需的配置文件路径 PropertyConfigurator.configure(filePath + \"log4j.properties\"); 参考链接详情请看log4j配置文件位置详解详情请看log4j:ERROR Could not read configuration file [log4j.properties]. 扩展内容log4j日志记录到文件log4j日志记录到数据库","tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://super3h.me/tags/JavaSE/"},{"name":"log4J","slug":"log4J","permalink":"https://super3h.me/tags/log4J/"}]},{"title":"s2sh三大框架的整合","date":"2017-03-01T00:32:37.142Z","path":"2017/03/01/s2sh三大框架的整合/","text":"前言 断断续续的学完了三大框架，自己也想尝试整合三大框架，这里记录我碰到的问题，以及学习的过程。 问题struts有关错误 使用modelDriven遇到的错误,报错如下： 1234ERROR ParametersInterceptor Developer Notification (set struts.devMode to false to disable this message):Unexpected Exception caught setting 'age' on 'class test.hhh.action.PersonAction: Error setting expression 'age' with value '20'ERROR ParametersInterceptor Developer Notification (set struts.devMode to false to disable this message):Unexpected Exception caught setting 'name' on 'class test.hhh.action.PersonAction: Error setting expression 'name' with value 'hhh' 原因如下: 1234//action中如下写private Person model;//由于model对象还没new，其内部为空，所以导致获取的model为null，改法如下private Person model = new Person(); spring和struts整合报错如下:12345678910111213141516171819202122232425262728ERROR Dispatcher Dispatcher initialization failed Unable to load configuration. - [unknown location] at com.opensymphony.xwork2.config.ConfigurationManager.getConfiguration(ConfigurationManager.java:70) at org.apache.struts2.dispatcher.Dispatcher.getContainer(Dispatcher.java:906) at org.apache.struts2.dispatcher.Dispatcher.init_PreloadConfiguration(Dispatcher.java:445) at org.apache.struts2.dispatcher.Dispatcher.init(Dispatcher.java:486) at org.apache.struts2.dispatcher.InitOperations.initDispatcher(InitOperations.java:75) at org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter.init(StrutsPrepareAndExecuteFilter.java:63) at org.apache.catalina.core.ApplicationFilterConfig.initFilter(ApplicationFilterConfig.java:279) at org.apache.catalina.core.ApplicationFilterConfig.getFilter(ApplicationFilterConfig.java:260) at org.apache.catalina.core.ApplicationFilterConfig.&lt;init&gt;(ApplicationFilterConfig.java:105) at org.apache.catalina.core.StandardContext.filterStart(StandardContext.java:4572) at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5215) at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150) at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1419) at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1409) at java.util.concurrent.FutureTask.run(Unknown Source) at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source) at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source) at java.lang.Thread.run(Unknown Source)Caused by: Cannot locate the chosen ObjectFactory implementation: spring - [unknown location] at org.apache.struts2.config.AbstractBeanSelectionProvider.alias(AbstractBeanSelectionProvider.java:64) at org.apache.struts2.config.AbstractBeanSelectionProvider.alias(AbstractBeanSelectionProvider.java:41) at org.apache.struts2.config.DefaultBeanSelectionProvider.register(DefaultBeanSelectionProvider.java:366) at com.opensymphony.xwork2.config.impl.DefaultConfiguration.reloadContainer(DefaultConfiguration.java:163) at com.opensymphony.xwork2.config.ConfigurationManager.getConfiguration(ConfigurationManager.java:67) ... 17 more三月 01, 2017 9:48:48 下午 org.apache.catalina.core.StandardContext filterStart 解释:struts没有交给spring管理或者你根本没导入struts2-spring-plugin-2.5.5.jar。和以下配置1&lt;constant name=\"struts.objectFactory\" value=\"spring\"&gt;&lt;/constant&gt; hibernate有关错误 错误如下 1Already value [org.springframework.orm.hibernate5.SessionHolder@43826ec] for key [org.hibernate.internal.SessionFactoryImpl@304a3655] bound to thread [main] 解决方案:由于spring配置问题，类LocalSessionFactoryBean应该来自于org.springframework.orm.hibernate5而不是org.springframework.orm.hibernate4 12345678910111213141516&lt;!--注意:PersonDaoImpl和LocalSessionFactoryBean都要来自于hibernate5的包下--&gt;&lt;bean id=\"sessionFactory\" class=\"org.springframework.orm.hibernate5.LocalSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;property name=\"configLocation\"&gt; &lt;value&gt;classpath:hibernate.cfg.xml&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"personDao\" class=\"test.hhh.dao.Impl.PersonDaoImpl\" &gt; &lt;property name=\"factory\" ref=\"sessionFactory\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;tx:annotation-driven transaction-manager=\"transactionManager\"/&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.orm.hibernate5.HibernateTransactionManager\"&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"&gt;&lt;/property&gt; &lt;/bean&gt; PersonDaoImpl和LocalSessionFactoryBean来自的包必须相同，不能一个来自于hibernate5一个hibernate4 s2sh整合时遇到错误 web.xml中spring的配置如下:1234&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;WEB-INF/classes/applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; 读取时从创建时候设置的文件目录读取，所以此处要加WEB-INF/classes/或者从src下读取，即添加以下配置classpath:applicationContext.xml否者会报错 applicationContext.xml中导入数据源配置文件:12345&lt;bean class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\"&gt; &lt;property name=\"location\"&gt; &lt;value&gt;classpath:dataSource.properties&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; 注意：加上classpath是让spring从src中读取 Log4J日志配置所需jar包 如下图 web.xml配置如下12345678910111213&lt;!-- log4j配置，文件路径，因为是跟随项目启动 --&gt; &lt;context-param&gt; &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:log4j.properties&lt;/param-value&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;loggingLevel&lt;/param-name&gt; &lt;param-value&gt;info&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 加载log4j配置文件 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.util.Log4jConfigListener&lt;/listener-class&gt; &lt;/listener&gt; log4J.properties配置123456789101112131415161718# Define the root logger with appender filelog4j.rootLogger = DEBUG, FILE# Define the file appenderlog4j.appender.FILE=org.apache.log4j.FileAppender# Set the name of the filelog4j.appender.FILE.File=G:\\\\log4J\\u65E5\\u5FD7\\\\s2sh_test01\\\\htmlLayout.html# Set the immediate flush to true (default)log4j.appender.FILE.ImmediateFlush=true# Set the threshold to debug modelog4j.appender.FILE.Threshold=debug# Define the layout for file appenderlog4j.appender.FILE.layout=org.apache.log4j.HTMLLayoutlog4j.appender.FILE.layout.Title=HTML Layout Examplelog4j.appender.FILE.layout.LocationInfo=true 参考链接Struts2学习笔记——Struts2与Spring整合","tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://super3h.me/tags/Hibernate/"},{"name":"Struts2","slug":"Struts2","permalink":"https://super3h.me/tags/Struts2/"},{"name":"Spring","slug":"Spring","permalink":"https://super3h.me/tags/Spring/"},{"name":"Project","slug":"Project","permalink":"https://super3h.me/tags/Project/"}]},{"title":"Spring-hibernate整合","date":"2017-02-26T07:42:36.485Z","path":"2017/02/26/Spring-hibernate整合/","text":"所需jar包 导入hibernate-release-5.2.5.Final\\lib\\required下面的包以及spring中事务spring-tx包和对象关系映射spring-orm，jdbcspring-jdbc，注解所需的spring-aop，和beans，core，context，expression以及commons-logging依赖包，还有mysql的驱动包：mysql-connector 配置文件 applicationContext.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd \"&gt; &lt;bean class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\"&gt; &lt;property name=\"location\"&gt; &lt;value&gt;dataSource.properties&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"$&#123;driverClassName&#125;\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"sessionFactory\" class=\"org.springframework.orm.hibernate5.LocalSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;!--加入hibernate.cfg.xml配置--&gt; &lt;property name=\"configLocation\"&gt; &lt;value&gt;classpath:hibernate.cfg.xml&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"personDao\" class=\"com.hhh.dao.impl.PersonDaoImpl\"&gt; &lt;property name=\"factory\" ref=\"sessionFactory\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--配置事务--&gt; &lt;bean id=\"txManager\" class=\"org.springframework.orm.hibernate5.HibernateTransactionManager\"&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;tx:annotation-driven transaction-manager=\"txManager\" /&gt; &lt;/beans&gt; 注意:有关txManager的必须加上，否则dao中sessionFactory.getCurrentSession()会报错:Could not obtain transaction-synchronized Session for current thread原因:在Spring事务管理中,current Session是绑定到SpringSessionContext中的,而不是ThreadLocalSessionContext中的，切勿在hibernate中配置:hibernate.current_session_context_class=thread详情请看@Transactional声明式事务管理 getCurrentSession hibernate.cfg.xml 12345678910111213&lt;!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;property name=\"dialect\"&gt;org.hibernate.dialect.MySQL5InnoDBDialect&lt;/property&gt; &lt;property name=\"hbm2ddl.auto\"&gt;update&lt;/property&gt; &lt;property name=\"show_sql\"&gt;true&lt;/property&gt; &lt;property name=\"format_sql\"&gt;true&lt;/property&gt; &lt;mapping resource=\"com/hhh/bean/person.hbm.xml\"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 数据库配置:dataSource.properties 1234driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/shtestusername=****password=**** 代码详情 com.hhh.bean.Person 123456789101112131415161718192021222324252627282930313233343536373839package com.hhh.bean;public class Person &#123; private Long id; private String name; private int age; public Person()&#123;&#125; public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String toString() &#123; return \"Person [id=\" + id + \", name=\" + name + \", age=\" + age + \"]\"; &#125; &#125; com.hhh.dao.PersonDao 123456789101112package com.hhh.dao;import java.util.List;import com.hhh.bean.Person;public interface PersonDao &#123; void addPerson(Person person); List&lt;Person&gt; listAllPerson();&#125; com.hhh.dao.impl.PersonDaoImpl 1234567891011121314151617181920212223242526272829303132333435363738package com.hhh.dao.impl;import java.util.List;import javax.annotation.Resource;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.springframework.orm.hibernate5.support.HibernateDaoSupport;import org.springframework.transaction.annotation.Transactional;import com.hhh.bean.Person;import com.hhh.dao.PersonDao;public class PersonDaoImpl implements PersonDao&#123; private SessionFactory factory; @Transactional public void addPerson(Person person) &#123; Session session = factory.getCurrentSession(); session.save(person); &#125; @Transactional public List&lt;Person&gt; listAllPerson() &#123; Session session = factory.getCurrentSession(); List&lt;Person&gt; persons = session.createQuery(\"FROM Person\").getResultList(); return persons; &#125; public void setFactory(SessionFactory factory) &#123; this.factory = factory; &#125;&#125; 测试类:com.hhh.test.TestApp 123456789101112131415161718192021222324252627282930313233343536package com.hhh.test;import java.util.List;import org.hibernate.SessionFactory;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.hhh.bean.Person;import com.hhh.dao.PersonDao;public class TestApp &#123; @Test public void testHB()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); SessionFactory factory = (SessionFactory) context.getBean(\"sessionFactory\"); &#125; @Test public void testAddPerson()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); PersonDao dao = (PersonDao) context.getBean(\"personDao\"); Person person = new Person(\"hhh\",20); dao.addPerson(person); &#125; @Test public void testListPerson()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); PersonDao dao = (PersonDao) context.getBean(\"personDao\"); List&lt;Person&gt; persons = dao.listAllPerson(); for(Person p:persons)&#123; System.out.println(p); &#125; &#125;&#125; 代码详情请点此处：Spring-Hibernate","tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://super3h.me/tags/Hibernate/"},{"name":"Spring","slug":"Spring","permalink":"https://super3h.me/tags/Spring/"}]},{"title":"Spring AOP+AspectJ","date":"2017-02-25T08:25:17.145Z","path":"2017/02/25/Spring-AOP+AspectJ/","text":"简介 常见AspectJ的注解： @Before:方法执行前运行 @After:运行在方法返回结果后 @AfterReturning:运行在方法返回一个结果后，在拦截器返回结果 @AfterThrowing:运行方法在抛出异常后 @Around:围绕方法执行运行，结合以上这三个通知 注意:Spring AOP 中没有 AspectJ 支持 目录结构 Spring Beans 普通 bean 中有几个方法，后来通过 AspectJ 注解拦截 123456789101112package com.yiibai.customer.bo;public interface CustomerBo &#123; void addCustomer(); String addCustomerReturnValue(); void addCustomerThrowException() throws Exception; void addCustomerAround(String name);&#125; 123456789101112131415161718192021222324package com.yiibai.customer.bo.impl;import com.yiibai.customer.bo.CustomerBo;public class CustomerBoImpl implements CustomerBo &#123; public void addCustomer()&#123; System.out.println(\"addCustomer() is running \"); &#125; public String addCustomerReturnValue()&#123; System.out.println(\"addCustomerReturnValue() is running \"); return \"abc\"; &#125; public void addCustomerThrowException() throws Exception &#123; System.out.println(\"addCustomerThrowException() is running \"); throw new Exception(\"Generic Error\"); &#125; public void addCustomerAround(String name)&#123; System.out.println(\"addCustomerAround() is running, args : \" + name); &#125;&#125; 启用AspectJ 在 Spring 配置文件，把“&lt;aop:aspectj-autoproxy /&gt;”，并定义Aspect(拦截)和普通的bean。File : applicationContext.xml 12345678910111213141516&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd \"&gt; &lt;aop:aspectj-autoproxy /&gt; &lt;bean id=\"customerBo\" class=\"com.yiibai.customer.bo.impl.CustomerBoImpl\" /&gt; &lt;!-- Aspect --&gt; &lt;bean id=\"logAspect\" class=\"com.yiibai.aspect.LoggingAspect\" /&gt;&lt;/beans&gt; AspectJ @Before 在下面例子中，logBefore()方法将在 customerBo接口的 addCustomer()方法的执行之前被执行。AspectJ的“切入点”是用来声明哪种方法将被拦截 File : LoggingAspect.java 123456789101112131415161718package com.yiibai.aspect;import org.aspectj.lang.JoinYiibai;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;@Aspectpublic class LoggingAspect &#123; @Before(\"execution(* com.yiibai.customer.bo.CustomerBo.addCustomer(..))\") public void logBefore(JoinYiibai joinYiibai) &#123; System.out.println(\"logBefore() is running!\"); System.out.println(\"hijacked : \" + joinYiibai.getSignature().getName()); System.out.println(\"******\"); &#125;&#125; 运行 12CustomerBo customer = (CustomerBo) appContext.getBean(\"customerBo\");customer.addCustomer(); 结果 1234logBefore() is running!hijacked : addCustomer******addCustomer() is running AspectJ @After 在下面例子中，logAfter()方法将在 customerBo 接口的 addCustomer()方法的执行之后执行。 File : LoggingAspect.java12345678910111213141516171819package com.yiibai.aspect;import org.aspectj.lang.JoinYiibai;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.After;@Aspectpublic class LoggingAspect &#123; @After(\"execution(* com.yiibai.customer.bo.CustomerBo.addCustomer(..))\") public void logAfter(JoinYiibai joinYiibai) &#123; System.out.println(\"logAfter() is running!\"); System.out.println(\"hijacked : \" + joinYiibai.getSignature().getName()); System.out.println(\"******\"); &#125;&#125; AspectJ @AfterReturning 在下面例子中，logAfterReturning()方法将在 customerBo 接口的addCustomerReturnValue()方法执行之后执行。此外，还可以截取返回的值使用“returning”属性。 要截取返回的值，对“returning”属性(结果)的值必须用相同的方法参数(结果) File : LoggingAspect.java 1234567891011121314151617181920package com.yiibai.aspect;import org.aspectj.lang.JoinYiibai;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.AfterReturning;@Aspectpublic class LoggingAspect &#123; @AfterReturning( pointcut = \"execution(* com.yiibai.customer.bo.CustomerBo.addCustomerReturnValue(..))\", returning= \"result\") public void logAfterReturning(JoinYiibai joinYiibai, Object result) &#123; System.out.println(\"logAfterReturning() is running!\"); System.out.println(\"hijacked : \" + joinYiibai.getSignature().getName()); System.out.println(\"Method returned value is : \" + result); System.out.println(\"******\"); &#125;&#125; 结果 12345addCustomerReturnValue() is running logAfterReturning() is running!hijacked : addCustomerReturnValueMethod returned value is : abc****** AspectJ @AfterReturning 在下面的例子中，如果 customerBo 接口的addCustomerThrowException()方法抛出异常logAfterThrowing()方法将被执行。 File : LoggingAspect.java 123456789101112131415161718192021package com.yiibai.aspect;import org.aspectj.lang.JoinYiibai;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.AfterThrowing;@Aspectpublic class LoggingAspect &#123; @AfterThrowing( pointcut = \"execution(* com.yiibai.customer.bo.CustomerBo.addCustomerThrowException(..))\", throwing= \"error\") public void logAfterThrowing(JoinYiibai joinYiibai, Throwable error) &#123; System.out.println(\"logAfterThrowing() is running!\"); System.out.println(\"hijacked : \" + joinYiibai.getSignature().getName()); System.out.println(\"Exception : \" + error); System.out.println(\"******\"); &#125;&#125; 结果 1234567addCustomerThrowException() is running logAfterThrowing() is running!hijacked : addCustomerThrowExceptionException : java.lang.Exception: Generic Error******Exception in thread \"main\" java.lang.Exception: Generic Error //... AspectJ @Around 在下面例子中，logAround()方法将在customerBo接口的addCustomerAround()方法执行之前执行， 必须定义“joinYiibai.proceed();” 控制何时拦截器返回控制到原来的addCustomerAround()方法。 File : LoggingAspect.java 12345678910111213141516171819202122232425package com.yiibai.aspect;import org.aspectj.lang.ProceedingJoinYiibai;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Around;@Aspectpublic class LoggingAspect &#123; @Around(\"execution(* com.yiibai.customer.bo.CustomerBo.addCustomerAround(..))\") public void logAround(ProceedingJoinYiibai joinYiibai) throws Throwable &#123; System.out.println(\"logAround() is running!\"); System.out.println(\"hijacked method : \" + joinYiibai.getSignature().getName()); System.out.println(\"hijacked arguments : \" + Arrays.toString(joinYiibai.getArgs())); System.out.println(\"Around before is running!\"); joinYiibai.proceed(); //continue on the intercepted method System.out.println(\"Around after is running!\"); System.out.println(\"******\"); &#125; &#125; 结果 1234567logAround() is running!hijacked method : addCustomerAroundhijacked arguments : [yiibai]Around before is running!addCustomerAround() is running, args : yiibaiAround after is running!******","tags":[{"name":"SpringAOP","slug":"SpringAOP","permalink":"https://super3h.me/tags/SpringAOP/"}]},{"title":"Spring表达式语言","date":"2017-02-25T03:07:16.141Z","path":"2017/02/25/Spring表达式语言/","text":"前言 Spring EL与OGNL和JSF EL相似，计算评估或在bean创建时执行。此外，所有的Spring表达式都可以通过XML或注解。在本教程中，我们将学习如何使用Spring表达式语言(SpEL)，注入字符串，整数，Bean到属性，无论是在XML和注释。 Spring Beans 两个简单Bean，后来利用 SpEL 注入值到属性，在 XML 和 注释。 123456789package com.yiibai.core;public class Customer &#123; private Item item; private String itemName;&#125; 123456789package com.yiibai.core;public class Item &#123; private String name; private int qty;&#125; Spring EL以XML形式 使用 SpEL关闭的#{ SpEL expression }括号，请参阅XML bean定义文件下面的例子。12345678910111213141516&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt; &lt;bean id=\"itemBean\" class=\"com.yiibai.core.Item\"&gt; &lt;property name=\"name\" value=\"itemA\" /&gt; &lt;property name=\"qty\" value=\"10\" /&gt; &lt;/bean&gt; &lt;bean id=\"customerBean\" class=\"com.yiibai.core.Customer\"&gt; &lt;property name=\"item\" value=\"#&#123;itemBean&#125;\" /&gt; &lt;property name=\"itemName\" value=\"#&#123;itemBean.name&#125;\" /&gt; &lt;/bean&gt; &lt;/beans&gt; #{itemBean}: 注入“itemBean”到“customerBean”Bean 的“item”属性。 #{itemBean.name}: 注入“itemBean”的“name”属性到 “customerBean&quot;bean的&quot;itemname”属性。 Spring EL以注解形式代码解析 要在注解使用使用SpEL，必须通过注解注册您的组件。如果注册bean在XML和Java类中定义@Value，该@Value将无法执行。1234567891011121314151617package com.yiibai.core;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Component(\"customerBean\")public class Customer &#123; @Value(\"#&#123;itemBean&#125;\") private Item item; @Value(\"#&#123;itemBean.name&#125;\") private String itemName; //...&#125; 1234567891011121314151617181920package com.yiibai.core;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Component(\"itemBean\")public class Item &#123; @Value(\"itemA\") //inject String directly private String name; @Value(\"10\") //inject interger directly private int qty; public String getName() &#123; return name; &#125; //...&#125; 启用自动组件扫描。 1234567891011&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd\"&gt; &lt;context:component-scan base-package=\"com.yiibai.core\" /&gt;&lt;/beans&gt; 在注解模式下，可以使用@Value定义Spring EL。在这种情况下，一个String和Integer值直接注入到“itemBean”，之后又注入“itemBean”到“customerBean”属性。 执行输出 运行它，无论是使用 SpEL在XML 还是注释都显示了同样的结果： 12345678910111213package com.yiibai.core;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class App &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); Customer obj = (Customer) context.getBean(\"customerBean\"); System.out.println(obj); &#125;&#125; 输出结果1Customer [item=Item [name=itemA, qty=10], itemName=itemA] 详细内容Spring EL hello world Spring EL方法调用实例代码解析 了解如何实现Spring EL方法调用与@Value注释123456789101112131415161718192021222324252627282930313233343536package com.yiibai.core;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Component(\"customerBean\")public class Customer &#123; @Value(\"#&#123;'yiibai'.toUpperCase()&#125;\") private String name; @Value(\"#&#123;priceBean.getSpecialPrice()&#125;\") private double amount; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public double getAmount() &#123; return amount; &#125; public void setAmount(double amount) &#123; this.amount = amount; &#125; @Override public String toString() &#123; return \"Customer [name=\" + name + \", amount=\" + amount + \"]\"; &#125;&#125; 123456789101112package com.yiibai.core;import org.springframework.stereotype.Component;@Component(\"priceBean\")public class Price &#123; public double getSpecialPrice() &#123; return new Double(199.09); &#125;&#125; 输出1Customer [name=YIIBAI, amount=199.09] 详细内容Spring EL方法调用实例 Spring EL运算符简介 Spring EL支持大多数标准的数学，逻辑和关系运算符。 例如， 关系运算符: 等于 (==, eq), 不等于 (!=, ne), 小于 (&lt;, lt), 小于或等于 (&lt;= , le), 大于 (&gt;, gt), 和大于或等于 (&gt;=, ge). 逻辑运算符:且, 或, 非 (!). 数学运算符:加法(+), 减法 (-), 乘法 (*), 除法(/), 除模(%) 和指数幂 (^). 代码解析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.yiibai.core;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Component(\"customerBean\")public class Customer &#123; //Relational operators @Value(\"#&#123;1 == 1&#125;\") //true private boolean testEqual; @Value(\"#&#123;1 != 1&#125;\") //false private boolean testNotEqual; @Value(\"#&#123;1 &lt; 1&#125;\") //false private boolean testLessThan; @Value(\"#&#123;1 &lt;= 1&#125;\") //true private boolean testLessThanOrEqual; @Value(\"#&#123;1 &gt; 1&#125;\") //false private boolean testGreaterThan; @Value(\"#&#123;1 &gt;= 1&#125;\") //true private boolean testGreaterThanOrEqual; //Logical operators , numberBean.no == 999 @Value(\"#&#123;numberBean.no == 999 and numberBean.no &lt; 900&#125;\") //false private boolean testAnd; @Value(\"#&#123;numberBean.no == 999 or numberBean.no &lt; 900&#125;\") //true private boolean testOr; @Value(\"#&#123;!(numberBean.no == 999)&#125;\") //false private boolean testNot; //Mathematical operators @Value(\"#&#123;1 + 1&#125;\") //2.0 private double testAdd; @Value(\"#&#123;'1' + '@' + '1'&#125;\") //1@1 private String testAddString; @Value(\"#&#123;1 - 1&#125;\") //0.0 private double testSubtraction; @Value(\"#&#123;1 * 1&#125;\") //1.0 private double testMultiplication; @Value(\"#&#123;10 / 2&#125;\") //5.0 private double testDivision; @Value(\"#&#123;10 % 10&#125;\") //0.0 private double testModulus ; @Value(\"#&#123;2 ^ 2&#125;\") //4.0 private double testExponentialPower; @Override public String toString() &#123; return \"Customer [testEqual=\" + testEqual + \", testNotEqual=\" + testNotEqual + \", testLessThan=\" + testLessThan + \", testLessThanOrEqual=\" + testLessThanOrEqual + \", testGreaterThan=\" + testGreaterThan + \", testGreaterThanOrEqual=\" + testGreaterThanOrEqual + \", testAnd=\" + testAnd + \", testOr=\" + testOr + \", testNot=\" + testNot + \", testAdd=\" + testAdd + \", testAddString=\" + testAddString + \", testSubtraction=\" + testSubtraction + \", testMultiplication=\" + testMultiplication + \", testDivision=\" + testDivision + \", testModulus=\" + testModulus + \", testExponentialPower=\" + testExponentialPower + \"]\"; &#125; &#125; 详情链接Spring EL运算符实例 更多详情内容Spring EL Lists,Maps实例Spring EL正则表达式实例","tags":[{"name":"Spring","slug":"Spring","permalink":"https://super3h.me/tags/Spring/"}]},{"title":"Spring自动扫描组件","date":"2017-02-25T02:35:10.542Z","path":"2017/02/25/Spring自动扫描组件/","text":"自动组件扫描 启用Spring组件扫描功能。使用@Component注释来表示这是类是一个自动扫描组件。 12345678910111213141516171819202122232425262728293031package com.yiibai.customer.dao;import org.springframework.stereotype.Component;@Componentpublic class CustomerDAO &#123; @Override public String toString() &#123; return \"Hello , This is CustomerDAO\"; &#125; &#125;//DAO层，添加@Component，表明这也是一个自动扫描组件。package com.yiibai.customer.services;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import com.yiibai.customer.dao.CustomerDAO;@Componentpublic class CustomerService &#123; @Autowired CustomerDAO customerDAO; @Override public String toString() &#123; return \"CustomerService [customerDAO=\" + customerDAO + \"]\"; &#125;&#125; 将这个“context:component”在bean配置文件，这意味着，在 Spring 中启用自动扫描功能。base-package 是指明存储组件，Spring将扫描该文件夹，并找出Bean(注解为@Component)并注册到 Spring 容器。 1234567891011&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd\"&gt; &lt;context:component-scan base-package=\"com.yiibai.customer\" /&gt;&lt;/beans&gt; 执行:12345678910111213141516171819package com.yiibai.common;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.yiibai.customer.services.CustomerService;public class App &#123; public static void main( String[] args ) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(new String[] &#123;\"Spring-AutoScan.xml\"&#125;); CustomerService cust = (CustomerService)context.getBean(\"customerService\"); System.out.println(cust); &#125;&#125; 输出结果1CustomerService [customerDAO=Hello , This is CustomerDAO] 自定义自动扫描组件名称 默认情况下，Spring 将小写部件的第一字符 从’CustomerService’到’customerService’。可以检索该组件名称为“customerService”。 1CustomerService cust = (CustomerService)context.getBean(\"customerService\"); 要创建组件的自定义名称，你可以这样自定义名称： 123@Service(\"AAA\")public class CustomerService ... 现在，可以用’AAA’这个名称进行检索。1CustomerService cust = (CustomerService)context.getBean(\"AAA\"); 自动组件扫描注释类型 在Spring2.5中，有4种类型的组件自动扫描注释类型 @Component – 指示自动扫描组件。 @Repository – 表示在持久层DAO组件。 @Service – 表示在业务层服务组件。 @Controller – 表示在表示层控制器组件。 因此，使用哪一个？其实并不那么重要。参见 @Repository，@Service 或 @Controller 源代码。 123456789@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface Repository &#123; String value() default \"\";&#125; 你可能会发现，所有的 @Repository, @Service 或 @Controller 被注解为 @Component。因此，我们可以只使用 @Component 对所有组件进行自动扫描？是的，Spring会自动扫描所有组件的 @Component 注解。它工作正常，但不是一个好的做法，为便于阅读，应该始终声明@Repository，@ Service 或 @Controller 在指定的层，使你的代码更易于阅读，如下： DAO 层123456789101112package com.yiibai.customer.dao;import org.springframework.stereotype.Repository;@Repositorypublic class CustomerDAO &#123; @Override public String toString() &#123; return \"Hello , This is CustomerDAO\"; &#125; &#125; Service 层12345678910111213141516171819package com.yiibai.customer.services;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import com.yiibai.customer.dao.CustomerDAO;@Servicepublic class CustomerService &#123; @Autowired CustomerDAO customerDAO; @Override public String toString() &#123; return \"CustomerService [customerDAO=\" + customerDAO + \"]\"; &#125; &#125; Spring过滤器组件自动扫描过滤组件 - 包含 参见下面的例子中使用Spring “过滤” 扫描并注册匹配定义“regex”，即使该类组件的名称未标注 @Component 。 DAO 层123456789package com.yiibai.customer.dao;public class CustomerDAO &#123; @Override public String toString() &#123; return \"Hello , This is CustomerDAO\"; &#125; &#125; Service 层 12345678910111213141516package com.yiibai.customer.services;import org.springframework.beans.factory.annotation.Autowired;import com.yiibai.customer.dao.CustomerDAO;public class CustomerService &#123; @Autowired CustomerDAO customerDAO; @Override public String toString() &#123; return \"CustomerService [customerDAO=\" + customerDAO + \"]\"; &#125; &#125; Spring 过滤 12345678910111213141516171819&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd\"&gt; &lt;context:component-scan base-package=\"com.yiibai\" &gt; &lt;context:include-filter type=\"regex\" expression=\"com.yiibai.customer.dao.*DAO.*\" /&gt; &lt;context:include-filter type=\"regex\" expression=\"com.yiibai.customer.services.*Service.*\" /&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; 执行 123456789101112131415161718192021package com.yiibai.common;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.yiibai.customer.services.CustomerService;public class App &#123; public static void main( String[] args ) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(new String[] &#123;\"Spring-AutoScan.xml\"&#125;); CustomerService cust = (CustomerService)context.getBean(\"customerService\"); System.out.println(cust); &#125;&#125;//输出CustomerService [customerDAO=Hello , This is CustomerDAO] 在这个XML过滤中，所有文件的名称中包含 DAO 或 Service(DAO., Services.) 单词将被检测并在 Spring 容器中注册。 过滤组件 - 不包含 另外，您还可以排除指定组件，以避免 Spring 检测和 Spring 容器注册。不包括在这些文件中标注有 @Service 。1234&lt;context:component-scan base-package=\"com.yiibai.customer\" &gt; &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Service\" /&gt; &lt;/context:component-scan&gt; 不包括那些包含DAO这个词组文件名。1234&lt;context:component-scan base-package=\"com.yiibai\" &gt; &lt;context:exclude-filter type=\"regex\" expression=\"com.yiibai.customer.dao.*DAO.*\" /&gt; &lt;/context:component-scan&gt; 原文链接Spring自动扫描组件Spring过滤器组件自动扫描","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://super3h.me/tags/SpringMVC/"},{"name":"Annotation","slug":"Annotation","permalink":"https://super3h.me/tags/Annotation/"}]},{"title":"spring-xmlns,xmlns:xsi和xsi:schemaLocation","date":"2017-02-24T12:13:43.477Z","path":"2017/02/24/spring-xmlns,xmlns xsi和xsi schemaLocation/","text":"前言 相信很多人和我一样，在编写Spring或者Maven或者其他需要用到XML文档的程序时，通常都是将这些XML文档头拷贝过来，并没有理解其中元素（比 如xmlns，xmlns:xsi，xsi:schemaLocation）的真正含义，不知道哪些元素是多余的，也不知道为什么要加那些元素。这样当有 时候网上Copy的XML头有错的时候自己却不知道怎么下手。我也是这样的，于是今天花了点时间好好的理解了一下这些元素及其用法，现整理与此。 案例 话不多说，先来一段Spring的XML样本，相信大家都很眼熟：123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;context:component-scan base-package=\"xxx.xxx.controller\" /&gt; &lt;context:annotation-config/&gt; &lt;mvc:default-servlet-handler/&gt; &lt;mvc:annotation-driven/&gt; &lt;mvc:resources mapping=\"/images/**\" location=\"/images/\" /&gt; &lt;bean id=\"xxx\" class=\"xxx.xxx.xxx.Xxx\"&gt; &lt;property name=\"xxx\" value=\"xxxx\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 这 个文档中，根元素就不用说了，接下来是xmlns。那么什么是xmlns呢？xmlns其实是XML Namespace的缩写，可译为“XML命名空间”，但个人觉得，翻译后的名字反而不好理解，所以我们就叫它为XML Namespace吧。 为什么需要xmlns？ 考虑这样两个XML文档：表示HTML表格元素的&lt;table/&gt;： 123456&lt;table&gt; &lt;tr&gt; &lt;td&gt;Apples&lt;/td&gt; &lt;td&gt;Bananas&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 和描述一张桌子的&lt;table/&gt;：12345&lt;table&gt; &lt;name&gt;African Coffee Table&lt;/name&gt; &lt;width&gt;80&lt;/width&gt; &lt;length&gt;120&lt;/length&gt;&lt;/table&gt; 假如这两个 XML 文档被一起使用，由于两个文档都包含带有不同内容和定义的 &lt;table&gt;元素，就会发生命名冲突。XML 解析器是无法确定如何处理这类冲突。为了解决上述问题，xmlns就产生了。 如何是用xmlns？ 很简单，使用语法：xmlns:namespace-prefix=&quot;namespaceURI&quot;。其中namespace-prefix为自定义前缀，只要在这个XML文档中保证前缀不重复即可；namespaceURI是这个前缀对应的XML Namespace的定义。例如，1xmlns:context=\"http://www.springframework.org/schema/context\" 这一句定义了一个http://www.springframwork.org/schema/context的Namespace（这和Java类中的包的声明很相似），并将其和前缀context绑定。所以上面的Spring XML文档中会有这么一句：1&lt;context:component-scan base-package=\"xxx.xxx.controller\" /&gt; 这里的元素就来自别名为context的XML Namespace，也就是在http://www.springframework.org/schema/context中定义的。 我们还可以将前缀定义为abc：1xmlns:abc=\"namespaceURI\" 这样再使用这个namespaceURI中的元素时，需要以abc为前缀，例如：&lt;abc:xxx/&gt;。再拿上面的例子解释怎么使用xmlns： 12345678&lt;!-- 这里xmlns:h=\"url1\"表示这个table是用h作为标记，table的写法在url1中定义 --&gt;&lt;h:table xmlns:h=\"url1\"&gt; &lt;h:tr&gt; &lt;h:td&gt;Apples&lt;/h:td&gt; &lt;h:td&gt;Bananas&lt;/h:td&gt; &lt;/h:tr&gt; &lt;/h:table&gt; 123456&lt;!-- 这里xmlns:f=\"url2\"表示这个table是用f作为标记，table的写法在url2中定义 --&gt;&lt;f:table xmlns:f=\"url2\"&gt; &lt;f:name&gt;African Coffee Table&lt;/f:name&gt; &lt;f:width&gt;80&lt;/f:width&gt; &lt;f:length&gt;120&lt;/f:length&gt; &lt;/f:table&gt; 后者与前者仅仅使用不同前缀，我们为&lt;table&gt;标签添加了一个 xmlns 属性，这样就为前缀赋予了一个与某个命名空间相关联的限定名称。此时再把它们放在一起，XML解析器就不会报错了。 xmlns和xmlns:xsi有什么不同？ xmlns表示默认的Namespace。例如Spring XML文档中的:1xmlns=\"http://www.springframework.org/schema/beans\" 这一句表示该文档默认的XML Namespace为http://www.springframwork.org/schema/beans。对于默认的Namespace中的元素，可以不使用前缀。例如Spring XML文档中的123&lt;bean id=\"xxx\" class=\"xxx.xxx.xxx.Xxx\"&gt; &lt;property name=\"xxx\" value=\"xxxx\"/&gt; &lt;/bean&gt; xmlns:xsi表示使用xsi作为前缀的Namespace，当然前缀xsi需要在文档中声明。 xsi:schemaLocation有何作用？ xsi:schemaLocation属性其实是Namespace为http://www.w3.org/2001/XMLSchema-instance里的schemaLocation属性，正是因为我们一开始声明了 1xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" 这里才写作xsi:schemaLocation（当然一般都使用这个前缀）。它定义了XML Namespace和对应的 XSD（Xml Schema Definition）文档的位置的关系。它的值由一个或多个URI引用对组成，两个URI之间以空白符分隔（空格和换行均可）。第一个URI是定义的 XML Namespace的值，第二个URI给出Schema文档的位置，Schema处理器将从这个位置读取Schema文档，该文档的targetNamespace必须与第一个URI相匹配。例如： 12xsi:schemaLocation=\"http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\" 这里表示Namespace为http://www.springframework.org/schema/context的Schema的位置为http://www.springframework.org/schema/context/spring-context.xsd这里我们可以打开这个Schema的位置，下面是这个文档的开始部分： 12345678&lt;xsd:schema xmlns=\"http://www.springframework.org/schema/context\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:beans=\"http://www.springframework.org/schema/beans\" xmlns:tool=\"http://www.springframework.org/schema/tool\" &lt;!-- 这里的targetNamespace和上方xsi:schemaLocation中的第一个URI匹配 --&gt; targetNamespace=\"http://www.springframework.org/schema/context\" elementFormDefault=\"qualified\" attributeFormDefault=\"unqualified\"&gt; 有了上面的说明后，再去理解开始的Spring XML文档，一定会有不一样的感觉！ 原文链接关于XML文档的xmlns、xmlns:xsi和xsi:schemaLocation","tags":[{"name":"Spring","slug":"Spring","permalink":"https://super3h.me/tags/Spring/"},{"name":"Xml","slug":"Xml","permalink":"https://super3h.me/tags/Xml/"}]},{"title":"Spring使用@Autowired注解自动装配","date":"2017-02-24T11:09:22.924Z","path":"2017/02/24/Spring使用@Autowired注解自动装配/","text":"引言 在大多数情况下，你可能只需要在特定的 bean 自动装配属性。在Spring中，可以使用 @Autowired 注解通过setter方法，构造函数或字段自动装配Bean。此外，它可以在一个特定的bean属性自动装配。注意:@Autowired注解是通过匹配数据类型自动装配Bean Beans 一个 Customer bean 在bean配置文件中声明。稍后，您将使用 “@Autowired” 来自动装配一个Person bean。123456789101112131415161718192021222324252627282930package com.yiibai.common;public class Customer &#123; //you want autowired this field. private Person person; private int type; private String action; //getter and setter method &#125;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd\"&gt; &lt;bean id=\"CustomerBean\" class=\"com.yiibai.common.Customer\"&gt; &lt;property name=\"action\" value=\"buy\" /&gt; &lt;property name=\"type\" value=\"1\" /&gt; &lt;/bean&gt; &lt;bean id=\"PersonBean\" class=\"com.yiibai.common.Person\"&gt; &lt;property name=\"name\" value=\"yiibai\" /&gt; &lt;property name=\"address\" value=\"address 123\" /&gt; &lt;property name=\"age\" value=\"28\" /&gt; &lt;/bean&gt; &lt;/beans&gt; 注册AutowiredAnnotationBeanPostProcessor 要启用@Autowired，必须注册“AutowiredAnnotationBeanPostProcessor’，你可以用两种方式做到这一点： Include 添加 Spring 上下文和&lt;context:annotation-config /&gt;在bean配置文件中12345678910111213141516171819202122&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd\"&gt; &lt;context:annotation-config /&gt; &lt;bean id=\"CustomerBean\" class=\"com.yiibai.common.Customer\"&gt; &lt;property name=\"action\" value=\"buy\" /&gt; &lt;property name=\"type\" value=\"1\" /&gt; &lt;/bean&gt; &lt;bean id=\"PersonBean\" class=\"com.yiibai.common.Person\"&gt; &lt;property name=\"name\" value=\"yiibai\" /&gt; &lt;property name=\"address\" value=\"address ABC\" /&gt; &lt;property name=\"age\" value=\"29\" /&gt; &lt;/bean&gt; &lt;/beans&gt; 是用于激活那些已经在spring容器里注册过的bean（无论是通过xml的方式还是通过package sanning的方式）上面的注解。注意:除了具有的功能之外，还可以在指定的package下扫描以及注册javabean 。 包含 AutowiredAnnotationBeanPostProcessor 直接在bean配置文件包含“AutowiredAnnotationBeanPostProcessor”。1234567891011121314151617181920&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd\"&gt;&lt;bean class=\"org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor\"/&gt; &lt;bean id=\"CustomerBean\" class=\"com.yiibai.common.Customer\"&gt; &lt;property name=\"action\" value=\"buy\" /&gt; &lt;property name=\"type\" value=\"1\" /&gt; &lt;/bean&gt; &lt;bean id=\"PersonBean\" class=\"com.yiibai.common.Person\"&gt; &lt;property name=\"name\" value=\"yiibai\" /&gt; &lt;property name=\"address\" value=\"address ABC\" /&gt; &lt;property name=\"age\" value=\"29\" /&gt; &lt;/bean&gt; &lt;/beans&gt; @Autowired示例 现在，你可以通过 @Autowired 自动装配 bean，它可以在 setter 方法，构造函数或字段中使用。 @Autowired setter 方法12345678910111213141516package com.yiibai.common;import org.springframework.beans.factory.annotation.Autowired;public class Customer &#123; private Person person; private int type; private String action; //getter and setter methods @Autowired public void setPerson(Person person) &#123; this.person = person; &#125;&#125; @Autowired 构造方法12345678910111213141516package com.yiibai.common;import org.springframework.beans.factory.annotation.Autowired;public class Customer &#123; private Person person; private int type; private String action; //getter and setter methods @Autowired public Customer(Person person) &#123; this.person = person; &#125;&#125; @Autowired 字段123456789101112package com.yiibai.common;import org.springframework.beans.factory.annotation.Autowired;public class Customer &#123; @Autowired private Person person; private int type; private String action; //getter and setter methods&#125; 上面的例子会自动装配“PersonBean”到Customer的person属性。执行它1234567891011121314151617package com.yiibai.common;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class App &#123; public static void main( String[] args ) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(new String[] &#123;\"applicationContext.xml\"&#125;); Customer cust = (Customer)context.getBean(\"CustomerBean\"); System.out.println(cust); &#125;&#125; 输出:1Customer [person=Person [name=YiibaiA], type=1, action=buy] 依赖检查 默认情况下，@Autowired将执行相关检查，以确保属性已经装配正常。当Spring无法找到匹配的Bean装配，它会抛出异常。要解决这个问题，可以通过 @Autowired 的“required”属性设置为false来禁用此检查功能。123456789101112package com.yiibai.common;import org.springframework.beans.factory.annotation.Autowired;public class Customer &#123; @Autowired(required=false) private Person person; private int type; private String action; //getter and setter methods&#125; 在上面的例子中，如果Spring不能找到一个匹配的Bean，person属性将不设定。 @Qualifier @Qualifier注解我们用来控制bean应在字段上自动装配。例如，具有两个类似的 person bean 配置文件。12345678910111213141516171819202122232425262728&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd\"&gt; &lt;context:annotation-config /&gt; &lt;bean id=\"CustomerBean\" class=\"com.yiibai.common.Customer\"&gt; &lt;property name=\"action\" value=\"buy\" /&gt; &lt;property name=\"type\" value=\"1\" /&gt; &lt;/bean&gt; &lt;bean id=\"PersonBean1\" class=\"com.yiibai.common.Person\"&gt; &lt;property name=\"name\" value=\"yiibai-1\" /&gt; &lt;property name=\"address\" value=\"address-1\" /&gt; &lt;property name=\"age\" value=\"29\" /&gt; &lt;/bean&gt; &lt;bean id=\"PersonBean2\" class=\"com.yiibai.common.Person\"&gt; &lt;property name=\"name\" value=\"yiibai-2\" /&gt; &lt;property name=\"address\" value=\"address-2\" /&gt; &lt;property name=\"age\" value=\"28\" /&gt; &lt;/bean&gt; &lt;/beans&gt; Spring知道哪个 bean 应当装配？为了解决这个问题，可以使用 @Qualifier 自动装配一个特定的 bean，例如，1234567891011121314package com.yiibai.common;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;public class Customer &#123; @Autowired @Qualifier(\"PersonBean1\") private Person person; private int type; private String action; //getter and setter methods&#125; 这意味着，“PersonBean1” bean被自动装配到customer的person属性 原文链接Spring使用@Autowired注解自动装配","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://super3h.me/tags/SpringMVC/"},{"name":"Annotation","slug":"Annotation","permalink":"https://super3h.me/tags/Annotation/"}]},{"title":"Spring Bean作用域实例","date":"2017-02-24T10:47:03.231Z","path":"2017/02/24/Spring Bean作用域实例/","text":"简介 在Spring中，bean作用域用于确定哪种类型的 bean 实例应该从Spring容器中返回给调用者。bean支持的5种范围域： 单例： 每个Spring IoC 容器返回一个bean实例 原型：当每次请求时返回一个新的bean实例 请求：返回每个HTTP请求的一个Bean实例 会话：返回每个HTTP会话的一个bean实例 全局会话：返回全局HTTP会话的一个bean实例 在大多数情况下，可能只处理了 Spring 的核心作用域 - 单例和原型，默认作用域是单例。注：意味着只有在一个基于web的Spring ApplicationContext情形下有效！ 单例VS原型 这里有一个例子来说明，bean的作用域单例和原型之间的不同：1234567891011121314package com.yiibai.customer.services;public class CustomerService &#123; String message; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125;&#125; 单例例子 如果 bean 配置文件中没有指定 bean 的范围，默认为单例。123456789&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd\"&gt; &lt;bean id=\"customerService\" class=\"com.yiibai.customer.services.CustomerService\" /&gt; &lt;/beans&gt; 执行结果：1234567891011121314151617181920212223package com.yiibai.common;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.yiibai.customer.services.CustomerService;public class App &#123; public static void main( String[] args ) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(new String[] &#123;\"Spring-Customer.xml\"&#125;); CustomerService custA = (CustomerService)context.getBean(\"customerService\"); custA.setMessage(\"Message by custA\"); System.out.println(\"Message : \" + custA.getMessage()); //retrieve it again CustomerService custB = (CustomerService)context.getBean(\"customerService\"); System.out.println(\"Message : \" + custB.getMessage()); &#125;&#125; 输出结果12Message : Message by custAMessage : Message by custA 由于 bean 的 “CustomerService’ 是单例作用域，第二个通过提取”custB“将显示消息由 ”custA’ 设置，即使它是由一个新的 getBean()方法来提取。在单例中，每个Spring IoC容器只有一个实例，无论多少次调用 getBean()方法获取它，它总是返回同一个实例。 原型例子 如果想有一个新的 “CustomerService”bean 实例，每次调用它的时候，需要使用原型(prototype)来代替。123456789&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd\"&gt; &lt;bean id=\"customerService\" class=\"com.yiibai.customer.services.CustomerService\" scope=\"prototype\"/&gt; &lt;/beans&gt; 运行-执行12Message : Message by custAMessage : null 在原型作用域，必须为每个 getBean()方法中调用返回一个新的实例。 Bean作用域注释 还可以使用注释来定义 bean 的作用域。12345678910111213141516171819package com.yiibai.customer.services;import org.springframework.context.annotation.Scope;import org.springframework.stereotype.Service;@Service@Scope(\"prototype\")public class CustomerService &#123; String message; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125;&#125; 启用自动组件扫描1234567891011&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd\"&gt; &lt;context:component-scan base-package=\"com.yiibai.customer\" /&gt; &lt;/beans&gt; 原文详解Spring Bean作用域实例","tags":[{"name":"Spring","slug":"Spring","permalink":"https://super3h.me/tags/Spring/"}]},{"title":"Spring 依赖注入(DI)","date":"2017-02-24T05:09:01.266Z","path":"2017/02/24/Spring 依赖注入(DI)/","text":"在Spring框架中，依赖注入(DI)的设计模式是用来定义对象彼此间的依赖。它主要有两种类型： - Setter方法注入 - 构造器注入 这里两种方法共用的基本类如下:1234567package com.hhh.core;public interface Music &#123; void minYao();&#125; 1234567891011package com.hhh.core.impl;import com.hhh.core.Music;public class MusicImpl implements Music &#123; public void minYao() &#123; System.out.println(\"民谣\"); &#125;&#125; Setter方法注入 这是最流行最简单的DI注入方法，通过设置方法注入依赖。 示例 帮助器类和指定的setter方法1234567891011121314151617package com.hhh.helper;import com.hhh.core.Music;public class MusicHelper &#123; private Music music; public void getMusic() &#123; music.minYao(); &#125; public void setMusic(Music music) &#123; this.music = music; &#125; &#125; 一个 bean 配置文件用来声明bean 和通过 setter 设置注入(property标签)的依赖1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"music\" class=\"com.hhh.core.impl.MusicImpl\"&gt;&lt;/bean&gt; &lt;bean id=\"musicHelper\" class=\"com.hhh.helper.MusicHelper\"&gt; &lt;property name=\"music\" ref=\"music\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 测试类test1234567891011121314151617package com.hhh.test;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.hhh.helper.MusicHelper;public class TestDI &#123; @Test public void testSetter()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); MusicHelper helper = (MusicHelper) context.getBean(\"musicHelper\"); helper.getMusic(); &#125;&#125; 结果:民谣 构造函数注入 此DI方法将通过构造函数注入依赖。 示例 一个辅助类的构造函数。12345678910package com.hhh.helper;import com.hhh.core.Music;public class ConstructorHelper &#123; public ConstructorHelper(Music music)&#123; music.minYao(); &#125;&#125; bean 配置文件来声明bean并通过构造函数(constructor-arg标签)设置注入依赖1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"music\" class=\"com.hhh.core.impl.MusicImpl\"&gt;&lt;/bean&gt; &lt;bean id=\"constructorHelper\" class=\"com.hhh.helper.ConstructorHelper\"&gt; &lt;constructor-arg&gt; &lt;ref bean=\"music\"/&gt; &lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/beans&gt; 测试类test12345678910111213141516package com.hhh.test;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.hhh.helper.MusicHelper;public class TestDI &#123; @Test public void testConstructor()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); MusicHelper helper = (MusicHelper) context.getBean(\"musicHelper\"); helper.getMusic(); &#125;&#125; 结果:民谣 构造方法注入类型歧义问题问题 让我们来看看这个客户 bean 实例。它包含两个构造方法，均接受3个不同的数据类型参数。1234567891011121314151617181920212223242526package com.yiibai.common;public class Customer &#123; private String name; private String address; private int age; public Customer(String name, String address, int age) &#123; this.name = name; this.address = address; this.age = age; &#125; public Customer(String name, int age, String address) &#123; this.name = name; this.age = age; this.address = address; &#125; //getter and setter methods public String toString()&#123; return \" name : \" +name + \"\\n address : \" + address + \"\\n age : \" + age; &#125;&#125; 在Spring bean 的配置文件中，通过传递一个“yiibai’ 的名字，地址为’188’，以及年龄为’28’12345678910111213141516171819202122&lt;!--Spring-Customer.xml--&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xsi:schemaLocation=\"http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans-2.5.xsd\"&gt; &lt;bean id=\"CustomerBean\" class=\"com.yiibai.common.Customer\"&gt; &lt;constructor-arg&gt; &lt;value&gt;yiibai&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg&gt; &lt;value&gt;188&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg&gt; &lt;value&gt;28&lt;/value&gt; &lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/beans&gt; 运行它，你期望的结果是什么？12345678910111213141516package com.yiibai.common;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class App &#123; public static void main( String[] args ) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(new String[] &#123;\"Spring-Customer.xml\"&#125;); Customer cust = (Customer)context.getBean(\"CustomerBean\"); System.out.println(cust); &#125;&#125; 输出结果123name : yiibai address : 28 age : 188 其结果不是我们所期望的，第一个构造器不执行，而是第二构造函数运行。在Spring参数类型’188’ 能够转换成int，所以Spring只是转换它，并采用第二个构造来执行，即使你认为它应该是一个字符串。 另外，如果Spring不能解决使用哪个构造函数，它会提示以下错误信息123constructor arguments specified but no matching constructor found in bean 'CustomerBean' (hint: specify index and/or type arguments for simple parameters to avoid type ambiguities) 解决方案12345678910111213141516171819202122&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xsi:schemaLocation=\"http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans-2.5.xsd\"&gt; &lt;bean id=\"CustomerBean\" class=\"com.yiibai.common.Customer\"&gt; &lt;constructor-arg type=\"java.lang.String\"&gt; &lt;value&gt;yiibai&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg type=\"java.lang.String\"&gt; &lt;value&gt;188&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg type=\"int\"&gt; &lt;value&gt;28&lt;/value&gt; &lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/beans&gt; 再次运行它，现在得到你所期望的。123name : yiibai address : 188 age : 28 这是一个很好的做法，显式声明每个构造函数参数的数据类型，以避免上述构造注入型歧义的问题。 原文链接Spring构造方法注入类型歧义Spring依赖注入（DI）","tags":[{"name":"Spring","slug":"Spring","permalink":"https://super3h.me/tags/Spring/"}]},{"title":"spring所遇问题","date":"2017-02-23T13:44:21.080Z","path":"2017/02/23/spring所遇问题/","text":"jar包没导出的问题 没导入spring-core-4.2.6.RELEASE.jar，报:The type org.springframework.core.NestedRuntimeException cannot be resolved. It is indirectly referenced from required .class files以及其他jar包没导报:ClassNoFoundException....，以下列出所需基本包","tags":[{"name":"Spring","slug":"Spring","permalink":"https://super3h.me/tags/Spring/"}]},{"title":"Spring JavaConfig","date":"2017-02-23T12:54:19.177Z","path":"2017/02/23/Spring-JavaConfig/","text":"注解替代 从Spring 3起，JavaConfig功能已经包含在Spring核心模块，它允许开发者将bean定义和在Spring配置XML文件到Java类中。但是，仍然允许使用经典的XML方式来定义bean和配置，JavaConfig是另一种替代解决方案。看来看经典的XML定义和JavaConfig的不同，如下定义在Spring容器中的bean12345678&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt; &lt;bean id=\"helloBean\" class=\"com.yiibai.hello.impl.HelloWorldImpl\"&gt; &lt;/beans&gt; 等效于以下JavaConfig的配置：1234567891011121314import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import com.yiibai.hello.HelloWorld;import com.yiibai.hello.impl.HelloWorldImpl;@Configurationpublic class AppConfig &#123; @Bean(name=\"helloBean\") public HelloWorld helloWorld() &#123; return new HelloWorldImpl(); &#125; &#125; 举例目录及所需jar包 单个加载Spring Beans 一个简单的Bean123456package com.hhh.helloWorld;public interface HelloWorld &#123; void sayHello();&#125; 1234567891011package com.hhh.helloWorld.impl;import com.hhh.helloWorld.HelloWorld;public class HelloWorldImpl implements HelloWorld &#123; public void sayHello() &#123; System.out.println(\"hello world\"); &#125;&#125; @Configuration示例 使用 @Configuration 注释告诉 Spring，这是核心的 Spring 配置文件，并通过 @Bean 定义 bean12345678910111213141516package com.hhh.appconfig;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import com.hhh.helloWorld.HelloWorld;import com.hhh.helloWorld.impl.HelloWorldImpl;@Configurationpublic class AppConfig &#123; @Bean(name=\"helloWorld\") public HelloWorld helloWorld()&#123; return new HelloWorldImpl(); &#125;&#125; 执行程序 使用AnnotationConfigApplicationContext 加载您的JavaConfig类1234567891011121314151617181920212223242526package com.hhh.test;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import com.hhh.appconfig.AppConfig;import com.hhh.appconfig.AppConfig2;import com.hhh.core.CustomerBo;import com.hhh.core.SchedulerBo;import com.hhh.helloWorld.HelloWorld;public class TestAnnotation &#123; @Test public void testHello()&#123; //spring通过注解拿到HelloWorld对象 ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); HelloWorld hello = (HelloWorld) context.getBean(\"helloWorld\"); hello.sayHello(); //通过new而得到的对象 AppConfig config = new AppConfig(); HelloWorld world = config.helloWorld(); world.sayHello(); &#125;&#125; 通过import加载多个Spring Beans 两个简单的Spring bean。1234567891011121314151617181920//File : CustomerBo.javapackage com.hhh.core;public class CustomerBo &#123; public void printMsg(String msg) &#123; System.out.println(\"CustomerBo : \" + msg); &#125;&#125;/***************************************************///File : SchedulerBo.javapackage com.hhh.core;public class SchedulerBo &#123; public void printMsg(String msg) &#123; System.out.println(\"SchedulerBo : \" + msg); &#125;&#125; @Configuration示例 现在，使用JavaConfig @Configuration声明上述Bean类。123456789101112131415161718192021222324252627282930313233//File : CustomerConfig.javapackage com.hhh.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import com.hhh.core.CustomerBo;@Configurationpublic class CustomerConfig &#123; @Bean(name=\"customer\") public CustomerBo customerBo()&#123; return new CustomerBo(); &#125;&#125;/*****************************************************///File : SchedulerConfig.javapackage com.hhh.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import com.hhh.core.SchedulerBo;@Configurationpublic class SchedulerConfig &#123; @Bean(name=\"scheduler\") public SchedulerBo schedulerBo()&#123; return new SchedulerBo(); &#125;&#125; @Import示例 加载主配置文件，并进行测试1234567891011package com.hhh.appconfig;import org.springframework.context.annotation.Import;import com.hhh.config.CustomerConfig;import com.hhh.config.SchedulerConfig;@Import(&#123;CustomerConfig.class,SchedulerConfig.class&#125;)public class AppConfig2 &#123;&#125; 执行程序 加载主配置文件，并进行测试。1234567891011121314151617181920212223package com.hhh.test;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import com.hhh.appconfig.AppConfig;import com.hhh.appconfig.AppConfig2;import com.hhh.core.CustomerBo;import com.hhh.core.SchedulerBo;import com.hhh.helloWorld.HelloWorld;public class TestAnnotation &#123; @Test public void testConfig()&#123; ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig2.class); CustomerBo cb = (CustomerBo) context.getBean(\"customer\"); cb.printMsg(\"hahaha\"); SchedulerBo sb = (SchedulerBo) context.getBean(\"scheduler\"); sb.printMsg(\"heiheihei\"); &#125;&#125; 原文链接Spring JavaConfig @Import实例","tags":[{"name":"Spring","slug":"Spring","permalink":"https://super3h.me/tags/Spring/"},{"name":"Annotation","slug":"Annotation","permalink":"https://super3h.me/tags/Annotation/"}]},{"title":"Spring自动装配Beans","date":"2017-02-22T05:31:48.467Z","path":"2017/02/22/Spring自动装配Beans/","text":"Spring自动装配Beans的5中模式 在Spring框架，可以用 auto-wiring 功能会自动装配Bean。要启用它，只需要在 定义“autowire”属性。1&lt;bean id=\"customer\" class=\"com.yiibai.common.Customer\" autowire=\"byName\" /&gt; 在Spring中，支持 5 自动装配模式。 no – 缺省情况下，自动配置是通过“ref”属性手动设定 byName – 根据属性名称自动装配。如果一个bean的名称和其他bean属性的名称是一样的，将会自装配它。 byType – 按数据类型自动装配。如果一个bean的数据类型是用其它bean属性的数据类型，兼容并自动装配它。 constructor – 在构造函数参数的byType方式。 autodetect – 如果找到默认的构造函数，使用“自动装配用构造”; 否则，使用“按类型自动装配”。 示例 Customer 和 Person 对象自动装配示范。123456789101112131415161718public class Customer &#123; private Person person; public Customer(Person person) &#123; this.person = person; &#125; public void setPerson(Person person) &#123; this.person = person; &#125; //...&#125;public class Person &#123; //...&#125; Auto-Wiring ‘no’ 这是默认的模式，你需要通过 ‘ref’ 属性来连接 bean。12345&lt;bean id=\"customer\" class=\"com.yiibai.common.Customer\"&gt; &lt;property name=\"person\" ref=\"person\" /&gt; &lt;/bean&gt; &lt;bean id=\"person\" class=\"com.yiibai.common.Person\" /&gt; Auto-Wiring ‘byName’ 按属性名称自动装配。在这种情况下，由于对“person” bean的名称是相同于“customer” bean 的属性(“person”)名称，所以，Spring会自动通过setter方法将其装配 – “setPerson(Person person)“.12&lt;bean id=\"customer\" class=\"com.yiibai.common.Customer\" autowire=\"byName\" /&gt; &lt;bean id=\"person\" class=\"com.yiibai.common.Person\" /&gt; Auto-Wiring ‘byType’ 通过按属性的数据类型自动装配Bean。在这种情况下，由于“Person” bean中的数据类型是与“customer” bean的属性(Person对象)的数据类型一样的，所以，Spring会自动通过setter方法将其自动装配。– “setPerson(Person person)“.12&lt;bean id=\"customer\" class=\"com.yiibai.common.Customer\" autowire=\"byType\" /&gt;&lt;bean id=\"person\" class=\"com.yiibai.common.Person\" /&gt; Auto-Wiring ‘constructor’ 通过构造函数参数的数据类型按属性自动装配Bean。在这种情况下，由于“person” bean的数据类型与“customer” bean的属性(Person对象)的构造函数参数的数据类型是一样的，所以，Spring通过构造方法自动装配 – “public Customer(Person person)“.12&lt;bean id=\"customer\" class=\"com.yiibai.common.Customer\" autowire=\"constructor\" /&gt;&lt;bean id=\"person\" class=\"com.yiibai.common.Person\" /&gt; 原文链接Spring自动装配Beans","tags":[{"name":"Spring","slug":"Spring","permalink":"https://super3h.me/tags/Spring/"}]},{"title":"maven外部依赖","date":"2017-02-22T02:18:33.817Z","path":"2017/02/22/maven外部依赖/","text":"maven外部依赖 正如大家所了解的那样，Maven确实使用 Maven 库的概念作依赖管理。但是，如果依赖是在远程存储库和中央存储库不提供那会怎么样？ Maven 提供为使用外部依赖的概念，就是应用在这样的场景中的。举一个例子，让我们在Maven创建项目这一章节中创建的项目做以下的修改 - 添加 lib 文件夹到 src 文件夹 - 复制任何的 jar 到 lib 文件夹。这里使用的是 ldapjdk.jar，这是 LDAP 操作的辅助库 目录结构如下: 在这里，在项目中指定自己所用的库，它可以包含 jar 文件，但是可能无法在任何 Maven 存储库找到，那么需要从外部下载。如果代码使用这个 Maven 库但没有办法找到，那么 Maven 构建将会失败，因为它在编译阶段使用指这个库无法下载或无法找到。要处理这种情况，需要添加外部依赖项，如使用下列方式在 Maven 的 pom.xml12345678910111213141516171819202122232425262728293031&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.companyname.bank&lt;/groupId&gt; &lt;artifactId&gt;consumerBanking&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;consumerBanking&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ldapjdk&lt;/groupId&gt; &lt;artifactId&gt;ldapjdk&lt;/artifactId&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;systemPath&gt;$&#123;basedir&#125;\\src\\lib\\ldapjdk.jar&lt;/systemPath&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 再看上面例子中的第二个依赖元素（dependency），它清除以下有关外部依赖的重要概念。 - 外部依赖（JAR库的位置）可以在 pom.xml 中配置为与其他依赖的方式相同； - 指定 groupId 同样作为库的名称； - 指定 artifactId 同样作为库的名称 - 指定范围的系统； - 指定相系统项目的位置； 原文链接详情请参考Maven外部依赖","tags":[{"name":"maven","slug":"maven","permalink":"https://super3h.me/tags/maven/"}]},{"title":"maven-Eclipse里导入MavenWeb工程","date":"2017-02-22T01:22:32.149Z","path":"2017/02/22/maven-Eclipse里导入MavenWeb工程/","text":"原文链接详情参考使用Eclipse创建Maven Web工程 所遇到的问题 pom.xml报错:web.xml is missing and &lt;failOnMissingWebXml&gt; is set to true 解决方案 这时候需要右击项目——&gt;Java EE Tools——&gt;Generate Deployment Descriptor Stub.然后系统会在src/main/webapp/WEB_INF文件加下创建web.xml文件。错误解决！当然这个方法是针对web项目的解决方案，如果你的工程不是web项目，那么还有另外一种解决方案，就是在pom文件中配置一下failOnMissingWebXml。具体配置如下：123456789101112&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;configuration&gt; &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;","tags":[{"name":"maven","slug":"maven","permalink":"https://super3h.me/tags/maven/"}]},{"title":"maven相关参数讲解","date":"2017-02-21T14:16:56.887Z","path":"2017/02/21/maven相关参数讲解/","text":"maven相关参数 groupId:代表组织和整个项目的唯一标志。比如说所有的Maven组件的groupId都是org.apache.maven artifactId:具体项目的名称，它于groupId共同确定一个项目在maven repo中的位置，例如，groupId=org.codehaus.mojo, artifactId=my-project的项目，在maven repo中的位置为：$M2_REPO/org/codehaus/mojo/my-project version:用于说明目前项目的版本，在引用依赖的时候确定具体依赖的版本号。 packaging: 规定项目的输出格式，包括jar、war、pom、apk等，根据实际需要确定。例如，开发一般的java库，可以使用jar packaging；开发android则是apk packaging。 例子说明 一般来说，Maven肯定要用到pom文件，全名叫Project Object Model。简单的说，就是这个pom.xml文件含有project的相关信息。以下面的pom文件为例，举个简单的例子：123456789&lt;project xmlns=\"http://maven,apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3c.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.apache.maven&lt;/groupId&gt; &lt;artifactId&gt;my-project&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt;&lt;/project&gt; 其中，groupId代表的是唯一的一个标识，比如一个组织或者一个项目的名字，基本上是唯一的，以这个maven为例就是org.apache.maven。artifactId:代表的是名字，如果刚刚那个有点像身份证，这个就是类似姓名的东西。version:比较好理解，就是版本号，比如1.2.1版本这样的。最后的packaging是我们提供组件的类型，比如使用时打包成一个jar或者是一个war之类的，默认为打成jar包。还要注意不得不提到maven的一个插件maven-archetype-plugin。这个插件是为了方便我们弄一些模板或者原型直接生成会更加方便。通过cmd指令，我们可以确定我们需要的是哪个原型cmd的命令的例子:1mvn archetype:generate -DarchetypeArtifactId=jersey-quickstart-grizzly2 -DarchetypeGroupId=org.glassfish.jersey.archetypes -DinteractiveMode=false -DgroupId=com.example -DartifactId=simple-service -Dpackage=com.example -DarchetypeVersion=2.17 archetypeGroupId:这个和刚刚那个很像，指的是原型唯一的标识archetypeArtifactId：原型的名字。interactiveMode:交互模式，默认为true。我上面的cmd命令是一次性把该输入的都输入进去了，免去了交互所以是false。如果你选择交互的话，就是有一步一步的选项指引你去选择和填写相关的标识之类的。archetypeCatalog:这个例子里面没有，指的是查找规则至于后面那些groupId之类的，前面已经说过的就是生成的项目的一些标识名字之类的相关信息，不过要注意这个package是生成项目的包结构而不是提供组件的类型了 原文参考Maven中的参数分别是什么意思？","tags":[{"name":"maven","slug":"maven","permalink":"https://super3h.me/tags/maven/"}]},{"title":"maven依赖机制","date":"2017-02-21T13:51:18.163Z","path":"2017/02/21/maven依赖机制/","text":"案例分析 让我们看一个案例研究，以了解它是如何工作的。假设你想使用 Log4j 作为项目的日志。这里你要做什么？ 在传统方式 访问http://logging.apache.org/log4j/ 下载 Log4 j的 jar 库 复制 jar 到项目类路径 手动将其包含到项目的依赖 所有的管理需要一切由自己做 如果有 Log4j 版本升级，则需要重复上述步骤一次 在Maven的方式 你需要知道 log4j 的 Maven 坐标，例如： 123&lt;groupId&gt;log4j&lt;/groupId&gt;&lt;artifactId&gt;log4j&lt;/artifactId&gt;&lt;version&gt;1.2.14&lt;/version&gt; 它会自动下载 log4j 的1.2.14 版本库。如果“version”标签被忽略，它会自动升级库时当有新的版本时 声明 Maven 的坐标转换成 pom.xml 文件 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.14&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 当 Maven 编译或构建，log4j 的 jar 会自动下载，并把它放到 Maven 本地存储库 所有由 Maven 管理 解释说明 看看有什么不同？那么到底在Maven发生了什么？当建立一个Maven的项目，pom.xml文件将被解析，如果看到 log4j 的 Maven 坐标，然后 Maven 按此顺序搜索 log4j 库： 1. 在 Maven 的本地仓库搜索 log4j 2. 在 Maven 中央存储库搜索 log4j 3. 在 Maven 远程仓库搜索 log4j(如果在 pom.xml 中定义) Maven 依赖库管理是一个非常好的工具，为您节省了大量的工作如何找到 Maven 坐标:访问 Maven 中心储存库，搜索下载您想要的jar。 原文参考Maven依赖机制","tags":[{"name":"maven","slug":"maven","permalink":"https://super3h.me/tags/maven/"}]},{"title":"maven-定制库到Maven本地资源库","date":"2017-02-21T13:35:33.780Z","path":"2017/02/21/maven-定制库到Maven本地资源库/","text":"案例学习 kaptcha，它是一个流行的第三方Java库，它被用来生成 “验证码” 的图片，以阻止垃圾邮件，但它不在 Maven 的中央仓库中，这里拿它来举例 mvn 安装 下载 “kaptcha”，将其解压缩并将 kaptcha-version.jar 复制到其他地方，比如：C盘。发出下面的命令：1mvn install:install-file -Dfile=c:\\kaptcha-&#123;version&#125;.jar -DgroupId=com.google.code -DartifactId=kaptcha -Dversion=&#123;version&#125; -Dpackaging=jar 示例:123456789101112131415161718D:\\&gt;mvn install:install-file -Dfile=c:\\kaptcha-2.3.jar -DgroupId=com.google.code -DartifactId=kaptcha -Dversion=2.3 -Dpackaging=jar[INFO] Scanning for projects...[INFO] Searching repository for plugin with prefix: &apos;install&apos;.[INFO] ------------------------------------------------------------------------[INFO] Building Maven Default Project[INFO] task-segment: [install:install-file] (aggregator-style)[INFO] ------------------------------------------------------------------------[INFO] [install:install-file][INFO] Installing c:\\kaptcha-2.3.jar to D:\\maven_repo\\com\\google\\code\\kaptcha\\2.3\\kaptcha-2.3.jar[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESSFUL[INFO] ------------------------------------------------------------------------[INFO] Total time: &lt; 1 second[INFO] Finished at: Tue May 12 13:41:42 SGT 2014[INFO] Final Memory: 3M/6M[INFO] ------------------------------------------------------------------------ “kaptcha” jar被复制到 Maven 本地存储库。 pom.xml 安装完毕后，就在 pom.xml 中声明 kaptcha 的坐标12345&lt;dependency&gt; &lt;groupId&gt;com.google.code&lt;/groupId&gt; &lt;artifactId&gt;kaptcha&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt; &lt;/dependency&gt; 构建它，现在 “kaptcha” jar 能够从你的 Maven 本地存储库检索了 原文参考定制库到Maven本地资源库","tags":[{"name":"maven","slug":"maven","permalink":"https://super3h.me/tags/maven/"}]},{"title":"maven添加远程仓库","date":"2017-02-21T13:16:59.024Z","path":"2017/02/21/maven添加远程仓库/","text":"Java.net资源库 添加Java.net远程仓库的详细信息在“pom.xml”文件123456789&lt;!--pom.xml--&gt;&lt;project ...&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;java.net&lt;/id&gt; &lt;url&gt;https://maven.java.net/content/repositories/public/&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; JBoss Maven存储库 添加JBoss远程仓库的详细信息在 “pom.xml” 文件中12345678&lt;project ...&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;JBoss repository&lt;/id&gt; &lt;url&gt;http://repository.jboss.org/nexus/content/groups/public/&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; 原文参考Maven添加远程仓库","tags":[{"name":"maven","slug":"maven","permalink":"https://super3h.me/tags/maven/"}]},{"title":"Crawler学习之Regex","date":"2017-02-20T13:29:13.893Z","path":"2017/02/20/Python-Crawler-regex/","text":"re.compile(strPattern[, flag]) 这个方法是Pattern类的工厂方法，用于将字符串形式的正则表达式编译为Pattern对象。flag:匹配模式，取值可以使用按位或运算符’|’表示同时生效，比如re.I | re.M。另外，你也可以在regex字符串中指定模式，比如re.compile(‘pattern’, re.I | re.M)与re.compile(‘(?im)pattern’)是等价的。可选值有： re.I(全拼：IGNORECASE): 忽略大小写（括号内是完整写法，下同） re.M(全拼：MULTILINE): 多行模式，改变’^’和’$’的行为 re.S(全拼：DOTALL): 点任意匹配模式，改变’.’的行为 re.L(全拼：LOCALE): 使预定字符类 \\w \\W \\b \\B \\s \\S 取决于当前区域设定 re.U(全拼：UNICODE): 使预定字符类 \\w \\W \\b \\B \\s \\S \\d \\D 取决于unicode定义的字符属性 re.X(全拼：VERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。 findall 当给出的正则表达式中带有多个括号时，列表的元素为多个字符串组成的tuple，tuple中字符串个数与括号对数相同，字符串内容与每个括号内的正则表达式相对应，并且排放顺序是按括号出现的顺序 当给出的正则表达式中带有一个括号时，列表的元素为字符串，此字符串的内容与括号中的正则表达式相对应（不是整个正则表达式的匹配内容） 当给出的正则表达式中不带括号时，列表的元素为字符串，此字符串为整个正则表达式匹配的内容。 例子如下: 1234567891011121314&gt;&gt;&gt; import re &gt;&gt;&gt; s = \"adfad asdfasdf asdfas asdfawef asd adsfas \" &gt;&gt;&gt; reObj1 = re.compile('((\\w+)\\s+\\w+)') &gt;&gt;&gt; reObj1.findall(s) [('adfad asdfasdf', 'adfad'), ('asdfas asdfawef', 'asdfas'), ('asd adsfas', 'asd')] &gt;&gt;&gt; reObj2 = re.compile('(\\w+)\\s+\\w+') &gt;&gt;&gt; reObj2.findall(s) ['adfad', 'asdfas', 'asd'] &gt;&gt;&gt; reObj3 = re.compile('\\w+\\s+\\w+') &gt;&gt;&gt; reObj3.findall(s) ['adfad asdfasdf', 'asdfas asdfawef', 'asd adsfas'] 详情参考python re 模块 findall 函数用法简述","tags":[{"name":"Python2","slug":"Python2","permalink":"https://super3h.me/tags/Python2/"},{"name":"Regex","slug":"Regex","permalink":"https://super3h.me/tags/Regex/"}]},{"title":"struts和ajax结合","date":"2017-02-20T04:41:03.991Z","path":"2017/02/20/J2EE-sh_Ajax/","text":"项目想法 这里接着上回用servlet和ajax结合，换成用struts2和hibernate框架生成。 项目过程 这里介绍点我用框架所遇到的问题 导入包的问题 除了struts基本包，hibernate必须包之外，还需加以下包 这里列出我所用的所有包 相对绝对路径问题解决1234&lt;!--采用struts标签来替代--&gt;&lt;s:url action='weibo_showImg'&gt; &lt;s:param name='id' value='#weibo.id'&gt;&lt;/s:param&gt;&lt;/s:url&gt; struts配置问题123456789101112&lt;package name=\"weibo\" extends=\"json-default\" namespace=\"/\"&gt; &lt;action name=\"weibo_*\" class=\"hhh.controller.WeiboAction\" method=\"&#123;1&#125;\"&gt; &lt;result name=\"toIndex\"&gt;/index.jsp&lt;/result&gt; &lt;result name=\"publish\"&gt;/WEB-INF/jsp/publish.jsp&lt;/result&gt; &lt;result name=\"toList\"&gt;/WEB-INF/jsp/list.jsp&lt;/result&gt; &lt;result name=\"success\" type=\"json\"&gt; &lt;!--必须加这一句--&gt; &lt;param name=\"root\"&gt;postData&lt;/param&gt; &lt;/result&gt; &lt;allowed-methods&gt;success,publishUI,listAirticle,publish,showImg&lt;/allowed-methods&gt; &lt;/action&gt; &lt;/package&gt; 博主一开始没有加这一句&lt;param name=&quot;root&quot;&gt;postData&lt;/param&gt;，导致各种找，终于不负辛苦，找到了，这里贴出action中的代码：注意:postData为发送的数据，必须要含有getter和setter方法 123456789101112131415161718192021//postData的setter和getter方法(其实只含有getter方法即可，因为页面需要获取值只需要getter方法，二后台获取前台来的值则需要色setter方法，需要什么添加什么，不要一股脑吧所有东西全加进去)private String postData;public String getPostData() &#123; return postData; &#125; public void setPostData(String postData) &#123; this.postData = postData; &#125;public String listAirticle()&#123; if(\"post\".equals(way))&#123; currentPage += postTime; Page page = service.listAirticle(currentPage); postData = JSONArray.fromObject(page.getRecords()).toString(); setPostData(postData); System.out.println(postData);//打印转换成json的数据 return SUCCESS; &#125;else&#123; Page page = service.listAirticle(currentPage); ActionContext.getContext().put(\"weibos\", page.getRecords()); return \"toList\"; &#125; 本来想在这 调试所报的异常123456789101112commons-beanutils-1.8.0.jar不加这个包 java.lang.NoClassDefFoundError: org/apache/commons/beanutils/DynaBean commons-collections.jar 不加这个包 java.lang.NoClassDefFoundError: org/apache/commons/collections/map/ListOrderedMapcommons-lang-2.4.jar不加这个包 java.lang.NoClassDefFoundError: org/apache/commons/lang/exception/NestableRuntimeExceptioncommons-logging-1.1.1.jar不加这个包 java.lang.NoClassDefFoundError: org/apache/commons/logging/LogFactory ezmorph-1.0.4.jar不加这个包 java.lang.NoClassDefFoundError: net/sf/ezmorph/Morpher json-lib-2.3-jdk15.jar不加这个包 java.lang.NoClassDefFoundError: net/sf/json/JSONObject 更详细请参考原文java转换json需要导入的jar包，org/apache/commons/lang/exception/NestableRuntimeException报异常:There is no result type defined for type &#39;json&#39; mapped with name &#39;success&#39;.首先要检查 是否有json-lib-2.3-jdk15.jar和struts2-json-plugin-2.3.4.1.jar两个包如果还报错，那就是struts.xml配置问题，将&lt;package中的 extends=&quot;struts-default&quot;为 extends=&quot;json-default&quot;更详细内容请参考SSH搭建遇到的问题—There is no result type defined for type ‘json’ mapped with name ‘success’. hibernate分页12String hql=\"select eage from Emp order by eage\"; Query query= session. createQuery(hql). setFirstResult(0). setMaxResults(5); //从0开始，现实5条数据 更详细请参考原文web开发（九）之Hibernate分页查询 源码 源码请参考AjaxTest/Struts-hibernate-test/，欢迎订阅。","tags":[{"name":"Ajax","slug":"Ajax","permalink":"https://super3h.me/tags/Ajax/"},{"name":"Struts2","slug":"Struts2","permalink":"https://super3h.me/tags/Struts2/"}]},{"title":"js相关问题","date":"2017-02-19T04:13:49.382Z","path":"2017/02/19/js相关问题/","text":"闭包考察1234567//输出结果？？如何让其恢复正常for (var i=0; i&lt;10; ++i) &#123; setTimeout( function timer()&#123; console.log( i ); &#125;,1000 );&#125;// 解决方案:12345678910111213141516//第一种for (var i=1; i&lt;=9; i++) &#123; (function(j)&#123; setTimeout( function timer()&#123; console.log( j ); &#125;, 1000 ); &#125;)( i );&#125;//第二种for (var i=1; i&lt;=9; i++) &#123; (function(j)&#123; setTimeout( function timer()&#123; console.log( j ); &#125;, 1000 ); &#125;)( i );&#125; 原因解释：这两种方法都不是解决异步问题的，而是解决变量作用域的问题的。因为函数 timer() 属于一个新的域，通过 var 定义的变量是无法传入到这个函数执行域中的，于是有了你展示的两种解决办法，第一种是通过使用 let 来声明块变量，这时候变量就能作用于这个块，所以 timer 就能使用 i 这个变量了。第二种是通过传入参数，间接的把变量传入到 timer 中。关于var和let的介绍:js中let和var定义变量的区别","tags":[{"name":"js","slug":"js","permalink":"https://super3h.me/tags/js/"}]},{"title":"VueJs学习","date":"2017-02-17T09:00:30.691Z","path":"2017/02/17/VueJs/","text":"vue初学v-if和v-show区别 v-if:表达式为false时，对应的元素将被删除 v-show:表达式为false时,对应的元素的属性display被置为false v-else:v-else元素必须立即跟在v-if或v-show元素的后面，否则它不能被识别。v-else元素是否渲染在HTML中，取决于前面使用的是v-if还是v-show指令。 v-for:Cannot use v-for on stateful component root element问题原因: v-for不能用于根元素（root element）。因为v-for是个循环，它返回更多的元素。导致无法渲染，例子如下:1234567891011121314151617181920212223&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--v-for必须在#el的内部才行--&gt; &lt;div id=\"el\" v-for=\"p in ps\"&gt;&#123;&#123;p&#125;&#125;&lt;/div&gt; &lt;!--以下为正确的写法--&gt; &lt;div id=\"el\"&gt; &lt;div v-for=\"p in ps\"&gt;&#123;&#123;p&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue(&#123; el:\"#el\", data:&#123; ps:[\"a\",\"b\",\"c\"] &#125; &#125;) &lt;/script&gt;&lt;/html&gt; vue.js2.0改版如下:数组:12value in arr(value, index) in arr json对象语法:12value in obj (value, key) in obj(value, key, index) in obj 写事件时,如@click=&quot;delete(index)，会导致点击事件加载不了，因为vue本身就含有此方法名，换成deleteElement即可 参考链接Vue.js——60分钟快速入门 vue深度学习v-model的作用 例子如下(这列只截取一小段代码): 1234567891011&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"name\"/&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; name:'HHH' &#125; &#125;) &lt;/script&gt; v-model=name指从data中去的name的值，相当于value=’HHH’,但如果v-model和value同时存在,v-model会覆盖value的值，因为v-model为动态绑定！！如果type=hidden了: 1&lt;input type='hidden' v-model='cid'&gt; 注意:本来想通过以上方式传id到后台,结果发现这样会导致值传不到后台！！v-model貌似不能访问json对象，例如v-model=&#39;message.value&#39; 事件的传参 例如: 1234&lt;el-select palaceholder=\"请选择\" v-model=\"value\" @change=\"changeSchool(value)\"&gt; &lt;el-option v-for=\"item in options\" :value=\"item.value\"&gt; &lt;/el-option&gt;&lt;/el-select&gt; 这里用的是ElementUI，详情参看ElementUI 学习这一章 当下拉框的值改变时触发changeSchool函数并且将v-model中绑定的value传进去！！！如果要将v-model的值传给属性(比如说:name等),可以这样写: ``` html","tags":[{"name":"Vue","slug":"Vue","permalink":"https://super3h.me/tags/Vue/"}]},{"title":"Servlet与ajax结合","date":"2017-02-17T04:13:02.755Z","path":"2017/02/17/J2EE-Servlet_Ajax/","text":"项目想法 由于老是逛微博，发现每到滑轮到底时就会刷新数据，今天刚好有时间，就自己尝试了一下，由于三大框架还不太熟，所以用的是servlet。后期改成ssh。 项目过程 由于这是一个小项目，就讲下自己所遇到的问题吧。 滑轮触发事件首先:从前台开始分析，滑轮滚到底会触发一个事件，代码如下:12345678910$().ready(function()&#123; $(window).bind(\"scroll\",function()&#123; var $height = $(this).height();//可见高度 var $contentH = $(document).height();//内容高度 var $scrollTop = $(this).scrollTop();//滚动的高度 if(($scrollTop+$height)==$contentH)&#123; //加载数据 &#125; &#125;)&#125;) 滚动高度+可见的高度=内容的高度；本代码是滚轮划到底部时才触发的事件，也可以设置一个范围，将if里的内容改成如下代码：$scrollTop/($contentH-$height)&gt;0.95 Ajax加载数据 由于本项目比较简单，就采用了$.post就行了，这里简单介绍一下$.post和$.ajax的区别$.post(url, [data], [callback], [type]):这是一个简单的 POST 请求功能以取代复杂 $.ajax 。请求成功时可调用回调函数。如果需要在出错时执行函数，请使用 $.ajax。 - `url:`发送请求地址 - `data:`待发送 Key/value 参数 - `callback:`发送成功时回调函数 - `type:`返回内容格式，xml, html, script, json, text, _default. $.aajax([options]):jQuery 底层 AJAX 实现。简单易用的高层实现见 $.get, $.post 等。$.ajax() 返回其创建的 XMLHttpRequest 对象。大多数情况下你无需直接操作该函数，除非你需要操作不常用的选项，以获得更多的灵活性。 具体请自行百度。 具体代码 以下ajax代码添加在滑轮触发事件的if内部;123456$.post(\"$&#123;pageContext.request.contextPath&#125;/clientServlet\",&#123; //待发送的参数 &#125;,function(data)&#123; //成功后执行的代码 &#125;) &#125;) 本例中时候向clientServlet发送数据接下来是servlet内的代码123456789101112131415161718resp.setContentType(\"text/html;charset=utf-8\"); PrintWriter out = resp.getWriter(); String way = req.getParameter(\"way\"); int page; if(req.getParameter(\"page\")==null||\"\".equals(req.getParameter(\"page\"))) page = 1; else page = Integer.parseInt(req.getParameter(\"page\")); //准备要显示的数据 Page p = service.listAirticle(page); if(\"post\".equals(way))&#123; List&lt;Weibo&gt; weibos = p.getRecords(); //TODO:weibos为null？？ out.println(\"&#123;weibos:\"+JsonParse.parse(weibos)+\"&#125;\"); out.close(); &#125;else &#123; req.setAttribute(\"page\", p); req.getRequestDispatcher(\"/WEB-INF/jsp/list.jsp\").forward(req, resp); &#125; 本来以为这样就可以不用分页了，天真的我发现不用分页不行呐。。这里解释一下思路:每到滑轮滚到底部时，触发ajax事件，同时把当前页加1，此时servlet负责查询下一页数据，并out.println，也就是写给ajax里的data,注意:写过去的时候为json格式，但data里的为字符串，需要将字符串转换成json格式，下面会讲 项目所遇问题 图片显示:浏览器中显示图片 json转为字符串:1、eval方式解析1234function strToJson(str)&#123; var json = eval('(' + str + ')'); return json;&#125; 2、new Function形式，比较怪异哦1234function strToJson(str)&#123; var json = (new Function(\"return \" + str))(); return json;&#125; 3、使用全局的JSON对象12var str = '&#123;\"name\":\"jack\"&#125;';var obj = JSON.parse(str); 注意:这里必须采用严格的json格式，name一定要用引号引起来，否则解析失败详细可参考js中将字符串转换成json的三种方式 foreach的运用方法:JS中的forEach、$.each、map方法推荐 Jquery中添加元素方法中:append()和after(),prepend()和before()的区别: append和prepend是指在元素内部添加而after和before是指在元素外添加，代码解释如下:1234&lt;!-- 此为在元素内部 --&gt;&lt;p&gt;This is a paragraph. &lt;b&gt;Appended text&lt;/b&gt;.&lt;/p&gt;&lt;!-- 此为在元素外部 --&gt;&lt;p&gt;This is a paragraph.&lt;/p&gt; &lt;b&gt;Appended text&lt;/b&gt; 源码如下 js完整代码如下:1234567891011121314151617181920212223242526$().ready(function()&#123; var x = 0; var page = $&#123;page.page&#125;; $(window).bind(\"scroll\",function()&#123; var $height = $(this).height();//可见高度 var $contentH = $(document).height();//内容高度 var $scrollTop = $(this).scrollTop();//滚动的高度 if(($scrollTop+$height)==$contentH)&#123; x += 1; $.post(\"$&#123;pageContext.request.contextPath&#125;/clientServlet\",&#123; operation:\"listAirticle\", way:\"post\", //每次滑轮拖到底部，当前页面就加1，直到无内容显示 page:page+x &#125;,function(data)&#123; var dataJson = eval(\"(\"+data+\")\"); dataJson.weibos.forEach(function(value)&#123; var $p = \"&lt;p&gt;\"+value.airticle+\"&lt;/p&gt;\"; var $img = \"&lt;img width='200px' height='100px' src='http://localhost:8080$&#123;pageContext.request.contextPath&#125;/clientServlet?showImg=\"+value.filename+\"&amp;operation=showImg&amp;id=\"+value.id+\"' /&gt;\"; $(\"body\").append($p); $(\"body\").append($img); &#125;) &#125;) &#125; &#125;)&#125;) 更详细内容，请参考AjaxTest","tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://super3h.me/tags/Servlet/"},{"name":"Ajax","slug":"Ajax","permalink":"https://super3h.me/tags/Ajax/"}]},{"title":"Jquery判断滚动条到底部","date":"2017-02-16T07:16:58.976Z","path":"2017/02/16/JQuery-scroll/","text":"属性解释scrollTop:为滚动条在Y轴上的滚动距离clientHeight:为内容可视区域的高度。scrollHeight:为内容可视区域的高度加上溢出（滚动）的距离。关系:clientHeight+scrollTop=scrollHeight 代码详情123456789101112 $().ready(function()&#123; //窗体为window时 $(window).bind(\"scroll\",function()&#123; var $height = $(this).height();//可见高度 var $contentH = $(document).height();//内容高度 var $scrollTop = $(this).scrollTop();//滚动的高度 //当 if(($scrollTop/($contentH-$height))&gt;0.95)&#123; alert(\"加载数据\"); &#125; &#125;)&#125;) 分清滚轮滚动属于哪一块，然后给那一块绑定，本文中为window 原文参考判断滚动条到底部的JS代码JS实现判断滚动条滚到页面底部并执行事件的方法","tags":[{"name":"Jquery","slug":"Jquery","permalink":"https://super3h.me/tags/Jquery/"},{"name":"js","slug":"js","permalink":"https://super3h.me/tags/js/"}]},{"title":"J2EE-浏览器中显示图片","date":"2017-02-15T10:02:03.631Z","path":"2017/02/15/J2EE-图片显示/","text":"servlet中的显示图片前端改法 Jsp中改法如下:1&lt;img src=\"$&#123;pageContext.request.contextPath&#125;/clientServlet?operation=showImg\" /&gt; 后台改法 Servlet改法如下:12345678910111213141516171819private void showImg(HttpServletRequest req, HttpServletResponse resp) &#123; String showImg = req.getParameter(\"showImg\"); String storePath = getPath(req, resp);//拿到根路径 try&#123; InputStream in = new FileInputStream(new File(storePath+\"\\\\\"+showImg)); OutputStream out = resp.getOutputStream(); byte[] b = new byte[1024]; int len = 0; while((len = in.read(b))!=-1)&#123; out.write(b, 0, len); out.flush(); &#125; out.close(); in.close(); &#125;catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(); &#125; &#125; 详细内容请参考JavaWeb将图片显示在浏览器中 struts2框架中的配置前端改法 Jsp中改法如下:1234&lt;img width=\"200px\" height=\"100px\" src=\"&lt;s:url action='weibo_showImg'&gt; &lt;s:param name='id' value='#weibo.id'&gt;&lt;/s:param&gt; &lt;/s:url&gt;\" /&gt; 后台改法 action中改法如下:12345678910111213public String showImg() throws IOException&#123; Weibo weibo = service.findWeiboById(model.getId()); OutputStream out = ServletActionContext.getResponse().getOutputStream(); InputStream in = new FileInputStream(getFilePath(weibo.getPath(), weibo.getFileName())); byte[] b = new byte[1024]; int len = 0; while((len=in.read(b))!=-1)&#123; out.write(b,0,len); &#125; out.close(); in.close(); return null; &#125; 注意:此方法必须放回nullstruts.xml配置:&lt;action name=&quot;访问action名&quot; class=&quot;action类名&quot; method=&quot;viewImages&quot;&gt;&lt;/action&gt;Jsp配置格式:&lt;img alt=&quot;显示图片&quot; src=&quot;&lt;s:url action=&#39;访问action名&#39;&gt;&lt;s:param name=&#39;向action传递参数名&#39; value=&#39;参数值&#39;&gt;&lt;/s:param&gt;&lt;/s:url&gt;&quot;&gt;&lt;/img&gt;","tags":[{"name":"J2EE","slug":"J2EE","permalink":"https://super3h.me/tags/J2EE/"}]},{"title":"struts2.xml报There is no Action mapped","date":"2017-02-13T07:14:43.441Z","path":"2017/02/13/J2EE-Struts2_xml/","text":"错误提示 报以下错误: 1There is no Action mapped for namespace [/] and action name [test] associated with context path [/test]. - [unknown location] 解决方案 确保struts.xml文件名大小写正确：struts.xml 确保struts.xml文件在src目录下,编译成功后，要确认是否编译到classes目录中项目右键 -&gt;properties -&gt;Java Build Path -&gt;source -&gt;Default output folder，选择你的路径。(也可以在新建项目时选择,如图：) 先排查访问的链接有没有问题（细节问题） 查看struts.xml的配置（仔细排查，出现问题几率很大） 查看结果响应页面是否存在问题（出现问题的几率比较小） 如果上面的四个步骤没出问题，可是还是报错，怎么办？在struts2.5.2中添加如下配置&lt;constant name=&quot;struts.enable.DynamicMethodInvocation&quot; value=&quot;false&quot; /&gt; 当使用动态调用方法时（action名 + 感叹号 + 方法名进行方法调用），需要将其属性改为true， 当使用通配符调用语法时，建议将其属性改为false（struts2.5.2中默认是false） 但在struts2.5.5中不行了，没错，博主用的就是2.5.5的，花了我一下午，心累。改法如下12345678910&lt;!--这一句必须添加--&gt;&lt;constant name=\"struts.enable.DynamicMethodInvocation\" value=\"false\" /&gt;&lt;package name=\"test\" namespace=\"/test\" extends=\"struts-default\"&gt; &lt;action name=\"test_*\" class=\"test.controller.TestAction\" method=\"&#123;1&#125;\"&gt; &lt;result name=\"success\"&gt;/index.jsp&lt;/result&gt; &lt;!--还有这一句，success为TestAction中的方法名--&gt; &lt;allowed-methods&gt;success&lt;/allowed-methods&gt; &lt;/action&gt; &lt;/package&gt; 说明:在struts2.3之前的版本，正常的配置就可以了，但在struts2.3版本之后，使用通配符调用方法时，内部会验证是否允许访问该方法，所以要加上用法如下:1&lt;allowed-methods&gt;方法名1，方法名2…&lt;/allowed-methods&gt; struts.xml配置：12345678910111213141516171819202122232425&lt;struts&gt; &lt;!-- 指定默认编码集 --&gt; &lt;constant name=\"struts.i18n.encoding\" value=\"UTF-8\"&gt;&lt;/constant&gt; &lt;!-- 指定需要Struts2处理的请求后缀 --&gt; &lt;constant name=\"struts.action.extension\" value=\"do,action\"&gt;&lt;/constant&gt; &lt;!-- 设置浏览器是否缓存静态内容，开发阶段应关闭，生产阶段打开，默认为打开 --&gt; &lt;constant name=\"struts.serve.static.browserCache\" value=\"false\"&gt;&lt;/constant&gt; &lt;!-- 当struts的配置文件修改后，系统是否自动重新加载该文件，默认为false，开发阶段应打开 --&gt; &lt;constant name=\"struts.configuration.xml.reload\" value=\"true\"&gt;&lt;/constant&gt; &lt;!-- 开发模式下使用，可以打印出更详细的错误信息 --&gt; &lt;constant name=\"struts.devMode\" value=\"true\"&gt;&lt;/constant&gt; &lt;!-- action全部用注解进行配置 --&gt; &lt;!-- 是否开启动态方法调用 --&gt; &lt;constant name=\"struts.enable.DynamicMethodInvocation\" value=\"false\" /&gt; &lt;!--添加包 --&gt; &lt;package name=\"weibo\" extends=\"struts-default\" namespace=\"/\"&gt; &lt;action name=\"weibo_*\" class=\"hhh.controller.WeiboAction\" method=\"&#123;1&#125;\"&gt; &lt;result name=\"toIndex\"&gt;/index.jsp&lt;/result&gt; &lt;result name=\"publish\"&gt;/WEB-INF/jsp/publish.jsp&lt;/result&gt; &lt;result name=\"toList\"&gt;/WEB-INF/jsp/list.jsp&lt;/result&gt; &lt;allowed-methods&gt;success,publishUI,listAirticle,publish&lt;/allowed-methods&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 原文参考struts2.5框架使用通配符指定方法（常见错误） eclipse下简单配置struts2.5.8","tags":[{"name":"J2EE","slug":"J2EE","permalink":"https://super3h.me/tags/J2EE/"},{"name":"Struts2","slug":"Struts2","permalink":"https://super3h.me/tags/Struts2/"}]},{"title":"tomcat的部署","date":"2017-02-13T03:43:56.946Z","path":"2017/02/13/J2EE-tomcat/","text":"静态部署 直接将web项目文件件拷贝到webapps 目录中 Tomcat的Webapps目录是Tomcat默认的应用目录，当服务器启动时，会加载所有这个目录下的应用。 所以可以将JSP程序打包成一个 war包放在目录下，服务器会自动解开这个war包，并在这个目录下生成一个同名的文件夹。 说明: 一个war包就是有特性格式的jar包，它是将一个web程序的所有内容进行压缩得到。 方式:可以使用许多开发工具的IDE环境，如Eclipse等。也可以用 cmd 命令：jar -cvf mywar.war myweb webapps这个默认的应用目录也是可以改变。打开Tomcat的conf目录下的server.xml文件，找到下面内容：1234&lt;Host name=\"localhost\" appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"true\" xmlValidation=\"false\" xmlNamespaceAware=\"false\"&gt; &lt;!-- 将appBase修改即可--&gt; 在server.xml中指定: 在Tomcat的配置文件中，一个Web应用就是一个特定的Context，可以通过在server.xml中新建Context里部署一个JSP应用程序。打开server.xml文件，在Host标签内建一个Context，内容如下。 在tomcat中的conf目录中，在server.xml中的，&lt;host/&gt;节点中添加： 12&lt;Context path=\"/hello\" docBase=\"D:\\ workspace\\hello\\WebRoot\" debug=\"0\" privileged=\"true\"&gt; &lt;/Context&gt; 或者1&lt;Context path=\"/myapp\" reloadable=\"true\" docBase=\"D:\\myapp\" workDir=\"D:\\myapp\\work\"/&gt; 或者1&lt;Context path=\"/sms4\" docBase=\"D:\\workspace\\sms4\\WebRoot\"/&gt; 说明：path:是虚拟路径；docBase: 是应用程序的物理路径；workDir: 是这个应用的工作目录，存放运行时生成的与这个应用相关的文件； debug: 则是设定debug level, 0表示提供最少的信息，9表示提供最多的信息privileged:设置为true的时候，才允许Tomcat的Web应用使用容器内的Servletreloadable: 如果为true，则tomcat会自动检测应用程序的/WEB-INF/lib 和/WEB-INF/classes目录的变化，自动装载新的应用程序，可以在不重起tomcat的情况下改变应用程序，实现热部署antiResourceLocking和antiJARLocking 热部署是需要配置的参数，默认false避免更新了某个webapp，有时候Tomcat并不能把旧的webapp完全删除，通常会留下WEB-INF/lib下的某个jar包，必须关闭Tomcat才能删除，这就导致自动部署失败。设置为true，Tomcat在运行对应的webapp时，会把相应的源文件和jar文件复制到一个临时目录里。 创建一个Context文件 在conf目录中，新建 Catalina＼localhost目录(自带的就不用建了)，在该目录中新建一个xml文件，名字不可以随意取，要和path后的那个名字一致，按照下边这个path的配置，xml的名字应该就应该是hello（hello.xml），该xml文件的内容为：1&lt;Context path=\"/hello\" docBase=\"E:\\workspace\\hello\\WebRoot\" debug=\"0\" privileged=\"true\"&gt;&lt;/Context&gt; tomcat自带例子如下：123&lt;Context docBase=\"$&#123;catalina.home&#125;/server/webapps/host-manager\" privileged=\"true\" antiResourceLocking=\"false\" antiJARLocking=\"false\"&gt;&lt;/Context&gt; 这个例子是tomcat自带的，编辑的内容实际上和第二种方式是一样的，其中这xml文件名字就是访问路径，这样可以隐藏应用的真实名字。 删除一个Web应用同时也要删除webapps下相应的文件夹和server.xml中相应的Context，还要将Tomcat的conf\\catalina\\localhost目录下相应的xml文件删除，否则Tomcat仍会去配置并加载。。。 动态部署 登陆tomcat管理控制台：http://localhost:8080/，输入用户名和密码后便可管理应用并动态发布。 在Context Path(option):中输入/yourwebname ，这代表你的应用的访问地址。 XML Configration file URL中要指定一个xml文件，比如我们在F:\\下建立一个hmcx.xml文件，内容如下：&lt;Context reloadable=&quot;false&quot; /&gt;其中docBase不用写了，因为在下一个文本框中填入。或者更简单点，这个文本框什么都不填，在WAR or Directory URL:中键入F:\\hmcx即可，然后点击Deploy按钮，上面就可以看到了web应用程序，名字就Context Path(option):中的名字。 如果部署.war文件还有更加简单的方式，下面还有个Select WAR file uploae点击浏览选择.war文件，然后点击Deploy也可以。 原文参考tomcat部署项目的几种方式","tags":[{"name":"J2EE","slug":"J2EE","permalink":"https://super3h.me/tags/J2EE/"},{"name":"tomcat","slug":"tomcat","permalink":"https://super3h.me/tags/tomcat/"}]},{"title":"Hexo-本地搜索","date":"2017-02-11T01:12:19.675Z","path":"2017/02/11/Hexo-search/","text":"安装和配置插件1、 cd到根目录下1$ npm install --save hexo-generator-search 2、 在__config.yml最后添加一下设置项(注意:缩进问题，建议直接copy)123search: path: search.xml field: all 说明: path:指定生成的索引数据的文件名。默认为 search.xml 。 field 指定索引数据的生成范围。可选值包括： post - 只生成博客文章（post）的索引（默认）； page:只生成其他页面（page）的索引； all:生成所有文章和页面的索引。搜索函数的创建新建search.js在themes\\jacman\\source\\js目录中，部署后将位于public\\js此函数参考于实现本地搜索函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485var searchFunc = function(path, search_id, content_id) &#123; 'use strict'; $.ajax(&#123; url: path, dataType: \"xml\", success: function( xmlResponse ) &#123; // get the contents from search data var datas = $( \"entry\", xmlResponse ).map(function() &#123; return &#123; title: $( \"title\", this ).text(), content: $(\"content\",this).text(), url: $( \"url\" , this).text() &#125;; &#125;).get(); var $input = document.getElementById(search_id); var $resultContent = document.getElementById(content_id); $input.addEventListener('input', function()&#123; var str='&lt;ul class=\\\"search-result-list\\\"&gt;'; var keywords = this.value.trim().toLowerCase().split(/[\\s\\-]+/); $resultContent.innerHTML = \"\"; if (this.value.trim().length &lt;= 0) &#123; return; &#125; // perform local searching datas.forEach(function(data) &#123; var isMatch = true; var content_index = []; var data_title = data.title.trim().toLowerCase(); var data_content = data.content.trim().replace(/&lt;[^&gt;]+&gt;/g,\"\").toLowerCase(); var data_url = data.url; var index_title = -1; var index_content = -1; var first_occur = -1; // only match artiles with not empty titles and contents if(data_title != '' &amp;&amp; data_content != '') &#123; keywords.forEach(function(keyword, i) &#123; index_title = data_title.indexOf(keyword); index_content = data_content.indexOf(keyword); if( index_title &lt; 0 &amp;&amp; index_content &lt; 0 )&#123; isMatch = false; &#125; else &#123; if (index_content &lt; 0) &#123; index_content = 0; &#125; if (i == 0) &#123; first_occur = index_content; &#125; &#125; &#125;); &#125; // show search results if (isMatch) &#123; str += \"&lt;li&gt;&lt;a href='\"+ data_url +\"' class='search-result-title'&gt;\"+ data_title +\"&lt;/a&gt;\"; var content = data.content.trim().replace(/&lt;[^&gt;]+&gt;/g,\"\"); if (first_occur &gt;= 0) &#123; // cut out 100 characters var start = first_occur - 20; var end = first_occur + 80; if(start &lt; 0)&#123; start = 0; &#125; if(start == 0)&#123; end = 100; &#125; if(end &gt; content.length)&#123; end = content.length; &#125; var match_content = content.substr(start, end); // highlight all keywords keywords.forEach(function(keyword)&#123; var regS = new RegExp(keyword, \"gi\"); match_content = match_content.replace(regS, \"&lt;em class=\\\"search-keyword\\\"&gt;\"+keyword+\"&lt;/em&gt;\"); &#125;); str += \"&lt;p class=\\\"search-result\\\"&gt;\" + match_content +\"...&lt;/p&gt;\" &#125; str += \"&lt;/li&gt;\"; &#125; &#125;); str += \"&lt;/ul&gt;\"; $resultContent.innerHTML = str; &#125;); &#125; &#125;);&#125; searchFunc(path, search_id, content_id)包含三个参数： path:用 hexo-generator-search 生成的搜索索引文件的路径。注意这个 path 和前面 hexo-generator-search 的 path 选项有所不同。这里的 path 才是指这个文件的路径，而前面的 path 指的是生成的文件名 search_id:搜索框的 id 。对于我们的例子，就是 local-search-input; content_id: 结果框的 id 。对于我们的例子，就是 local-search-result 搜索函数文件的引入既然搜索函数已创建，接下来就是调用了。 调用之前有必要明白themes\\jacman\\layout\\_partial\\header.ejs中最后一个form表单即为页面中的search框 对应代码如下: 1234&lt;form class=\"search\"&gt; &lt;label&gt;Search&lt;/label&gt; &lt;input type=\"text\" id=\"search\" class=\"search form-control\" autocomplete=\"off\" maxlength=\"20\" placeholder=\"&lt;%= __('search') %&gt;\" autocorrect=\"off\"/&gt;&lt;/form&gt; 在目录themes\\jacman\\layout\\_partial\\after_footer.ejs中，添加一下内容:1234567891011121314151617181920&lt;script&gt;(function()&#123; var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') &#123; bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; &#125; else &#123; bp.src = 'http://push.zhanzhang.baidu.com/push.js'; &#125; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s);&#125;)();&lt;/script&gt;&lt;script src=\"&lt;%- config.root %&gt;js/jquery-2.0.3.min.js\"&gt;&lt;/script&gt;&lt;script src=\"&lt;%- config.root %&gt;js/jquery.imagesloaded.min.js\"&gt;&lt;/script&gt;&lt;script src=\"&lt;%- config.root %&gt;js/gallery.js\"&gt;&lt;/script&gt;&lt;script src=\"&lt;%- config.root %&gt;js/jquery.qrcode-0.12.0.min.js\"&gt;&lt;/script&gt;//以下是引入我们创建的js文件&lt;script src=\"&lt;%- config.root %&gt;js/search.js\"&gt;&lt;/script&gt; after_footer.ejs专门存放各种js文件，从此处引入我们创建的search.js文件 输入框的整改 思考:由于主题原因，我们有两条路走：1.写一个html页面用于显示搜索后的结果2.用div叠加在原页面上，在进行搜索和结果展示博主走的第二条路，样式如下: 由于博主前台很渣，能做成这样就不错了。虽然后台也好不到哪去，哈哈要添加此样式就得找到添加的位置，themes\\jacman\\layout\\layout.ejs，此文件用于页面的排布,分别对应了文章，分类，归档等的排布，我们分别在每个&lt;header&gt;后加入以下代码 123456789101112131415161718&lt;header&gt; &lt;%- partial('_partial/header') %&gt;&lt;/header&gt;&lt;!--添加以下代码--&gt; &lt;div id=\"ly\" style=\"width:100%;height:100%;position: fixed; top: 0px; opacity:0.5; background-color: #6F6F6F; z-index: 2; left: 0px; display: none;\" onclick=\"Lock_CheckForm()\"&gt; &lt;/div&gt; &lt;!--浮层框架开始--&gt; &lt;div id=\"Layer2\" align=\"center\" style=\"width: 950px; position: absolute;left: 200px ;top:10%;z-index: 3;background-color: #fff; display: none;border-radius: 10px;\"&gt; &lt;div style=\"background-color: #F8F8F8;border-radius: 10px;\"&gt; &lt;input type=\"text\" value=\"\" id=\"local-search-input\" placeholder=\"search this website\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" style=\"outline: none;\"&gt; &lt;span class=\"local-search-close\" onclick=\"Lock_Reset()\"&gt;&lt;/span&gt; &lt;!-- 清空/重置搜索框 --&gt; &lt;br&gt;&lt;br&gt; &lt;/div&gt; &lt;div id=\"local-search-result\"&gt;&lt;/div&gt; &lt;!-- 搜索结果区 --&gt; &lt;/div&gt; &lt;!-- 浮层框架结束--&gt; 说明:#ly:用于暗色背景#Layer2:用于搜索和结果展示div #local-search-input:搜索框div #local-search-close:用于清空搜索框内容div #local-search-result:用于结果展示 浮层样式的添加 html写完后,改写css了，博主把所有的样式写在一个文件中了，以免乱套在themes\\jacman\\source\\css新建search.styl，此文件夹用于页面所有样式的展示，对应的代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104ul.search-result-list &#123; padding-left: 10px;&#125;a.search-result-title &#123; font-weight: bold;&#125;p.search-result &#123; color=#555;&#125;em.search-keyword &#123; border-bottom: 1px dashed #4088b8; font-weight: bold;&#125;/*搜索框样式*/#local-search-input &#123; font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif;&#125;#local-search-input &#123; font-size: 13px; min-height: 32px; margin: 0; padding: 7px 8px; outline: none; color: #333; background-color: #fff; background-repeat: no-repeat; background-position: right center; border: 1px solid #ccc; border-radius: 3px; box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.075); -moz-box-sizing: border-box; box-sizing: border-box; transition: all 0.15s ease-in; -webkit-transition: all 0.15s ease-in 0; vertical-align: middle;&#125;#local-search-input:focus &#123; outline: none; border-color: #51a7e8; box-shadow: inset 0 1px 2px rgba(0, 0, 0, .075), 0 0 5px rgba(81, 167, 232, .5);&#125;#local-search-input &#123; margin-top: 20px; margin-left: -46px; font-size: 18px; width: 850px; height: 30px;&#125;/*搜索重置按钮*/.local-search-close:hover &#123; zoom: 1.0; padding: 1px 0.6em; border: 1px solid #d3d3d3; box-shadow: 0 0 6px rgba(0, 0, 0, 0.25); background: #FAF7F4;&#125;.local-search-close:active &#123; background: #d3d3d3;&#125;.local-search-close &#123; padding: 1px 0.7em; box-shadow: 0 0 3px rgba(0, 0, 0, 0.15); cursor: pointer; color: #808080;&#125;.local-search-close::before &#123; content: \"\\2716\";&#125;/* place the button on top-right */.local-search-close &#123; top: 22px; right: 28px; position: absolute;&#125;/*搜索结果区*/#local-search-result &#123; font-size: 0.9em; text-align: left; word-break: break-all;&#125;#local-search-result ul.search-result-list li:hover &#123; font-weight: normal;&#125;/*搜索预览段落*/#local-search-result p.search-result &#123; margin: 0.4em auto; max-height: 3.6em; overflow: hidden; font-size: 0.8em; text-align: justify; color: #808080;&#125;/*匹配的关键词*/#local-search-result em.search-keyword &#123; color: #f58e90; border-bottom: 1px dashed #f58e90; font-weight: bold; font-size: 0.85em;&#125; 之后就要添加样式文件了，我们到themes\\jacman\\layout\\_partial\\head.ejs文件中的最后几行中添加以下代码: 123&lt;%- css('css/style') %&gt;/*以下为添加的内容*/&lt;%- css('css/search') %&gt; 函数调用和事件添加 样式也添加完了，接下来就是函数调用和事件添加，到themes\\jacman\\layout\\_partial\\after_footer.ejs目录下，在刚才引入search.js的下面添加以下代码: 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;script src=\"&lt;%- config.root %&gt;js/search.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt;//div层的显示function locking() &#123; document.all.ly.style.display = \"block\"; document.all.Layer2.style.display = 'block';&#125;//div层的隐藏function Lock_CheckForm() &#123; document.all.ly.style.display = 'none'; document.all.Layer2.style.display = 'none'; return false;&#125;//重置搜索框function Lock_Reset() &#123; //拿到搜索结果层 var $resultArea = $(\"#local-search-result\"); $resultArea.html(\"\"); $(\"#local-search-input\").val('');&#125; //拿到文件路径var search_path = \"&lt;%= config.search.path %&gt;\";if (search_path.length == 0) &#123; search_path = \"search.xml\"; &#125;var path = \"&lt;%= config.root %&gt;\" + search_path;//拿到页面自带的搜索框元素var inputArea = document.querySelector(\"#search\");//禁止回车的输入inputArea.onkeydown = function()&#123; if(event.keyCode==13) return false&#125;var getSearchFile = function()&#123; //调用搜索函数 searchFunc(path, 'local-search-input', 'local-search-result');&#125;//给页面自带的搜索框元素添加聚焦时间inputArea.onfocus = function()&#123; locking(); getSearchFile();&#125;getSearchFile();&lt;/script&gt; 到此也就结束了，花了博主一个多小时，下回发个治颈椎的博文，哈哈！大家可以按照自己的样式修改，最后贴出我的成果 参考链接在此谢谢这两位博主的文章让 Hexo 博客支持本地站内搜索jQuery-based Local Search Engine for Hexo","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://super3h.me/tags/Hexo/"}]},{"title":"Python-List添加元素的方法","date":"2017-02-10T11:20:25.128Z","path":"2017/02/10/Python-list/","text":"List添加元素的方法1、append() 追加单个元素到List的尾部，只接受一个参数，参数可以是任何数据类型，被追加的元素在List中保持着原结构类型。此元素如果是一个list，那么这个list将作为一个整体进行追加，注意append()和extend()的区别。1234&gt;&gt;&gt; list1=['a','b']&gt;&gt;&gt; list1.append('c')&gt;&gt;&gt; list1['a', 'b', 'c'] 2、extend() 将一个列表中每个元素分别添加到另一个列表中，只接受一个参数；extend()相当于是将list B 连接到list A上。12345&gt;&gt;&gt; list1['a', 'b', 'c']&gt;&gt;&gt; list1.extend('d')&gt;&gt;&gt; list1['a', 'b', 'c', 'd'] 3、insert() 将一个元素插入到列表中，但其参数有两个（如insert(1,”g”)），第一个参数是索引点，即插入的位置，第二个参数是插入的元素。12345&gt;&gt;&gt; list1['a', 'b', 'c', 'd']&gt;&gt;&gt; list1.insert(1,'x')&gt;&gt;&gt; list1['a', 'x', 'b', 'c', 'd'] 4、+ 加号，将两个list相加，会返回到一个新的list对象，注意与前三种的区别。前面三种方法（append, extend, insert）可对列表增加元素的操作，他们没有返回值，是直接修改了原数据对象。 注意：将两个list相加，需要创建新的list对象，从而需要消耗额外的内存，特别是当list较大时，尽量不要使用“+”来添加list，而应该尽可能使用List的append()方法。123456&gt;&gt;&gt; list1['a', 'x', 'b', 'c', 'd']&gt;&gt;&gt; list2=['y','z']&gt;&gt;&gt; list3=list1+list2&gt;&gt;&gt; list3['a', 'x', 'b', 'c', 'd', 'y', 'z'] 参考链接python中List添加元素的几种方法","tags":[{"name":"Python2","slug":"Python2","permalink":"https://super3h.me/tags/Python2/"}]},{"title":"hexo样式无法加载","date":"2017-02-10T08:39:30.489Z","path":"2017/02/10/Hexo-样式无法加载/","text":"更改域名后样式无法加载 博主发现更改域名后，其他浏览器都能加载样式，唯独火狐和谷歌不行，我这强迫症就不能忍了(其实也不是，主要是花了我25的绿毛爷爷，舍不得啊TwT)，花了博主好几天，终于找到了，主要就是域名解析问题这里贴出图片： 这里博主并没有设置github，直接让github跳转至super3h.me之后链接到super3h.coding.me的内容，之前设置github后导致页面都加载不出来了，所以直接删除了。 域名设置课参考博主上一篇博文Hexo-github 域名设置","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://super3h.me/tags/Hexo/"}]},{"title":"npm相关命令","date":"2017-02-09T14:30:19.459Z","path":"2017/02/09/npm-命令/","text":"npm install xxx 会把xxx包安装到node_modules目录中 不会修改package.json 之后运行npm install命令时，不会自动安装xxx npm install –save 会把xxx包安装到node_modules目录中 会在package.json的dependencies属性下添加xxx 之后运行npm install命令时，会自动安装xxx到node_modules目录中 之后运行npm install –production或者注明NODE_ENV变量值为production时，会自动安装xxx到node_modules目录中 npm install –save-dev 会把xxx包安装到node_modules目录中 会在package.json的devDependencies属性下添加xxx 之后运行npm install命令时，会自动安装xxx到node_modules目录中 之后运行npm install --production或者注明NODE_ENV变量值为production时，不会自动安装xxx到node_modules目录中 使用原则运行时需要用到的包使用–save，否则使用–save-dev。 原文参考npm install –save 与 npm install –save-dev 的区别","tags":[{"name":"npm","slug":"npm","permalink":"https://super3h.me/tags/npm/"}]},{"title":"hexo-优化","date":"2017-02-09T09:50:13.041Z","path":"2017/02/09/hexo-优化/","text":"Hexo优化静态文件压缩1、 cd到根目录下npm install xxx --save，xxx为一下工具123\"gulp\": \"^3.9.1\",\"gulp-minify-css\": \"^1.2.4\",\"gulp-uglify\": \"^1.5.3\", 2、在根目录下建立gulpfile.js 文件1234567891011121314151617181920212223242526272829303132333435363738var gulp = require('gulp'); //Plugins模块获取 var minifycss = require('gulp-minify-css'); var uglify = require('gulp-uglify'); // 压缩 public 目录 css文件 gulp.task('minify-css', function() &#123; return gulp.src('./public/**/*.css') .pipe(minifycss()) .pipe(gulp.dest('./public')); &#125;); // 压缩 public 目录 html文件 gulp.task('minify-html', function() &#123; return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest('./public')) &#125;); // 压缩 public/js 目录 js文件 gulp.task('minify-js', function() &#123; return gulp.src('./public/**/*.js') .pipe(uglify()) .pipe(gulp.dest('./public')); &#125;); // 执行 gulp 命令时执行的任务 gulp.task('default', [ 'minify-css','minify-js' ]); 由于压缩html和img报错 ，所以只压缩了js和css 其他优化请参考：Hexo折腾记——性能优化篇hexo定制&amp;优化 网易云添加第一步： 第二步： 第三步： 第四步： 笔者放在themes\\jacman\\layout\\_partial\\sidebar.ejs具体代码如下: 123456789&lt;div id=\"asidepart\"&gt;&lt;div class=\"closeaside\"&gt;&lt;a class=\"closebutton\" href=\"#\" title=\"&lt;%= __('hidesidebar') %&gt;\"&gt;&lt;/a&gt;&lt;/div&gt;&lt;iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=300 height=450 src=\"//music.163.com/outchain/player?type=0&amp;id=485228675&amp;auto=1&amp;height=430\" style=\"margin-top:40px;margin-left:-10px;\"&gt;&lt;/iframe&gt;&lt;aside class=\"clearfix\"&gt;&lt;% theme.widgets.forEach(function(widget)&#123; %&gt; &lt;%- partial('../_widget/' + widget) %&gt;&lt;% &#125;); %&gt;&lt;/aside&gt;&lt;/div&gt; 样式也做了相应的修改： 1234567891011//themes\\jacman\\source\\css\\_partial\\aside.styl//sidebar#asidepart background color-section margin 1em 0 0 padding 0.5em 2% 1em @media tablet position relative float left width 23% margin 2em 0 0 3% 123456789//themes\\jacman\\source\\css\\_partial\\index.styl#main margin 1em 0 0 line-height line-height+0.3 @media tablet margin 2em 0 0 width 70% float left transition margin 0.5s ease-out github名片修改：12345//E:\\Hexo\\blog\\themes\\jacman\\layout\\_widget\\github-card.ejs&lt;div class=\"github-card\" data-github=\"&lt;%= theme.author.github %&gt;\" data-width=\"280\" data-height=\"119\" data-theme=\"medium\"&gt;&lt;script type=\"text/javascript\" src=\"//cdn.jsdelivr.net/github-cards/latest/widget.js\" &gt;&lt;/script&gt;&lt;/div&gt; 注意:谷歌和火狐无法播放音乐。原因如下： 多说评论修改原博主是大神，写的很清楚，完全不用动脑子，全程复制粘贴即可，感谢原博主，请点击此处多说样式折腾记录 — 添加 UA 浏览器标识、旋转头像等","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://super3h.me/tags/Hexo/"}]},{"title":"Hexo-github 域名设置","date":"2017-02-08T03:54:17.174Z","path":"2017/02/08/Hexo-域名/","text":"购买域名 笔者是在腾讯云买的，网上教程都是万网买的,两者都差不多，只要输入以下内容即可 注意:博主把蓝灯打开后，ip变为国外的了，此时访问super3h.me，显示不安全，因此会访问不了了 添加CNAME然后回到博客项目根目录，在source/下新建一个名为CNAME的文件，里面的内容写入super3h.me即可。 然后在浏览器输入super3h.me，即可代替之前的github.io的域名，访问到自己的博客页面了 原文链接hexo博客进阶－相册和独立域名","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://super3h.me/tags/Hexo/"}]},{"title":"python is和==的区别","date":"2017-02-07T14:48:31.381Z","path":"2017/02/07/Python-is_==/","text":"is和==的区别Python中的对象包含三要素：id、type、value。其中id用来唯一标识一个对象，type标识对象的类型，value是对象的值。is判断的是a对象是否就是b对象，是通过id来判断的。==判断的是a对象的值是否和b对象的值相等，是通过value来判断的","tags":[{"name":"Python2","slug":"Python2","permalink":"https://super3h.me/tags/Python2/"}]},{"title":"python开发公众号","date":"2017-02-05T10:41:51.548Z","path":"2017/02/05/WeiXin-Python/","text":"原文参考从零开始 Python 微信公众号开发使用python一步一步搭建微信公众平台添加用户关注后的欢迎信息与听音乐功能Python快速搭建自动回复微信公众号未认证订阅号自定义菜单与开发者兼得 所遇问题git push sae master:1时候报如下错误:12G:\\Web_python\\xyPyTest&gt;git push sae master:1fatal: Authentication failed for &apos;https://git.sinacloud.com/super3h/&apos; 解决方案:用户名密码就是你的github账户邮箱和密码，输入密码不是没反应，是你输入了但是不会显示，你输入完直接enter就ok了，sshkey是另外一种提交方式罢了！ lxml安装问题123456E:\\&gt;easy_install lxmlSearching for lxmlReading https://pypi.python.org/simple/lxml/Best match: lxml 3.7.2Downloading https://pypi.python.org/packages/66/45/f11fc376f784c6f2e77ffc7a9d02374ff3ceb07ede8c56f918939409577c/lxml-3.7.2.tar.gz#md5=8dcf8d6c692b7aed9370f7462ff09935error: ('The read operation timed out',) 解决方案:从官方网站下载与系统，Python版本匹配的lxml文件：lxml 2.3执行 easy_install lxml-2.3-py2.7-win-amd64.egg即可详细解决方案请参考Python lxml模块安装教程 ‘not found’页面 这个属于正常页面，因为index.wsgi只会接受http://6.super3h.applinzi.com/weixin的入口才会响应，对应微信配置如下： 具体详情请参考新浪云SAE搭建python环境和SAE部署Python-让云端自动运行Python代码 自动回复无反应问题 原文参考代码有错index.wsgi中将import lxml改为import lxml.etree as etree，可进入sae日志中心查看代码错误原因，具体过程如下: 添加第三方依赖包除了使用新浪云上已经预装的模块之外，您还可以通过以下方式给自己的应用添加第三方依赖包。 首先，在应用的根目录下创建一个第三方依赖包目录 vendor 。调用pip命令安装依赖包，使用其-t选项指定第三方包的安装目录。31$ pip install -t vendor PACKAGE ... 将 vendor 目录和应用的代码一起提交，即可在应用代码里使用安装的第三方依赖包了。 如果依赖包安装的目录名不为 vendor ，你需要在 index.wsgi 文件的最开始，添加以下代码，将目录加入到 sys.path 中。123import saesae.add_vendor_dir('路径')# 注意：以上代码得放在 index.wsgi 的最前面，所有其它代码之前。 详情参考:添加第三方依赖包 编码问题1(unicode error) 'utf8' codec can't decode byte 0xd6 in position 2: invalid continuation byte yq26 具体原因：编码不一致，微信为gbk编码，本地为utf-8编码二导致编码不一致解决方案：将本地用gbk解码，具体操作如下：1return self.render.reply_text(fromUser, toUser, int(time.time()), ('图中人物性别为:'+datas[0]+'\\n'+'年龄为:'+datas[1]).decode('gbk')) 输入&lt;&gt;会被转义问题 由于![CDATA[$content]]而发生转义问题，改成如下模式即可:12345678$def with (toUser,fromUser,createTime,content)&lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[$toUser]]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[$fromUser]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;$createTime&lt;/CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt; &lt;Content&gt;$content&lt;/Content&gt;&lt;/xml&gt; 音乐问题 由于百度云存储要钱的缘故。。。所以我选择了新浪云。问题：苹果手机中不能听解决方案：还没解决。。能力有限。后续:那天闲来无事，进公众号点了首歌，发现不能放了，原来是新浪云把歌的链接给改了。。没办法存在了qq邮箱的中转站，原文点击此教你快速添加qq空间背景音乐免费网络歌曲链接 新闻列表templates\\reply_url.xml12345678910111213141516171819$def with (toUser,fromUser,createTime,content,title,description,picUrl,url)&lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[$toUser]]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[$fromUser]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;$createTime&lt;/CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[news]]&gt;&lt;/MsgType&gt; &lt;Content&gt;&lt;![CDATA[$content]]&gt;&lt;/Content&gt; &lt;ArticleCount&gt;1&lt;/ArticleCount&gt; &lt;Articles&gt; &lt;item&gt; &lt;Title&gt;&lt;![CDATA[$title]]&gt;&lt;/Title&gt; &lt;Description&gt;&lt;![CDATA[$description]]&gt; &lt;/Description&gt; &lt;PicUrl&gt;&lt;![CDATA[$picUrl]]&gt;&lt;/PicUrl&gt; &lt;Url&gt;&lt;![CDATA[$url]]&gt;&lt;/Url&gt; &lt;/item&gt; &lt;/Articles&gt; &lt;FuncFlag&gt;0&lt;/FuncFlag&gt;&lt;/xml&gt; weixinInterface.py添加这一句:12345678def POST(self): if msgType == 'text': content = xml.find(\"Content\").text #添加这一句 if isinstance(replayText,list): articleList = [article['article']+'\\n详情'.decode('gbk')+article['detailurl'] for article in replayText]# 一定要写在此文件里，写在tulingAutoReply.py会报缩进问题 reply = random.choice(articleList) return self.render.reply_text(fromUser,toUser,int(time.time()),reply) tulingAutoReply.py1234567891011121314151617181920212223242526272829303132333435# coding:utf-8import jsonimport requestsimport tracebackfrom random import choice class TulingAutoReply: def __init__(self, tuling_key, tuling_url): self.key = tuling_key self.url = tuling_url def reply(self, reply): body = &#123;'key': self.key, 'info': reply&#125; r = requests.post(self.url, data=body) #设置编码 r.encoding = 'utf-8' resp = r.text if resp is None or len(resp) == 0: return None try: js = json.loads(resp) # 回复为文本类 if js['code'] == 100000: return js['text'] # 回复为链接类 elif js['code'] == 200000: return js['url'] # 回复为新闻类 elif js['code'] == 302000: return js['list'] # 其他 else: return None except Exception: traceback.print_exc() return None 博主本来准备做语音识别，结果好像认证后才提供此接口，这里把原文贴出来，供大家参考听得懂语音消息的聊天机器人 微信图文信息直接跳转至外部链接 点击菜单跳转到网页必须要认证才行，我们可以用关键字回复来实现跳转至外部链接在templates下添加reply_url.xml，内容为:12345678910111213141516171819$def with (toUser,fromUser,createTime,content,title,description,picUrl,url)&lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[$toUser]]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[$fromUser]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;$createTime&lt;/CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[news]]&gt;&lt;/MsgType&gt; &lt;Content&gt;&lt;![CDATA[$content]]&gt;&lt;/Content&gt; &lt;ArticleCount&gt;1&lt;/ArticleCount&gt; &lt;Articles&gt; &lt;item&gt; &lt;Title&gt;&lt;![CDATA[$title]]&gt;&lt;/Title&gt; &lt;Description&gt;&lt;![CDATA[$description]]&gt; &lt;/Description&gt; &lt;PicUrl&gt;&lt;![CDATA[$picUrl]]&gt;&lt;/PicUrl&gt; &lt;Url&gt;&lt;![CDATA[$url]]&gt;&lt;/Url&gt; &lt;/item&gt; &lt;/Articles&gt; &lt;FuncFlag&gt;0&lt;/FuncFlag&gt;&lt;/xml&gt; weixinInterface.py添加这一句:1234if msgType == 'text': content = xml.find(\"Content\").text if content == '博客'.decode('gbk'): return self.render.reply_url(fromUser,toUser,int(time.time()),content,'个人博客'.decode('gbk'),'HHH的个人博客'.decode('gbk'),r'https://mmbiz.qlogo.cn/mmbiz_jpg/z67Nqg3yAzRNVazozLUD7icuibRJdnCDaJd1dTfQ9673IDS6ttA5cFQwQCic7IrjPhbTcX1ycQDGibJhlGaFbwzyyg/0?wx_fmt=jpeg',r'http://super3h.github.io') 源码链接欢迎订阅 ProgrammerBy3H 求star star star！！","tags":[{"name":"Python","slug":"Python","permalink":"https://super3h.me/tags/Python/"},{"name":"Weixin","slug":"Weixin","permalink":"https://super3h.me/tags/Weixin/"}]},{"title":"hibernate中openSession()跟getCurrentSession()的区别","date":"2017-01-30T15:11:00.494Z","path":"2017/01/30/J2EE-Hibernate的Session获取/","text":"openSession()与getCurrentSession() 采用getCurrentSession()创建的Session会绑定到当前的线程中去、而采用OpenSession()则不会。查询也需要开事务，否则会报错 采用getCurrentSession()创建的Session在commit或rollback后会自动关闭，采用OpenSession()必须手动关闭。 采用getCurrentSession()需要在Hibernate.cfg.xml配置文件中加入如下配置： 如果是本地事物，及JDBC一个数据库：&lt;property name=”current_session_context_class”&gt;thread&lt;/property&gt;如果是全局事物，及jta事物、多个数据库资源或事物资源：&lt;property name=”current_session_context_class”&gt;jta&lt;/property&gt;使用spring的getHiberanteTemplate 就不需要考虑事务管理和session关闭的问题 补充 openSession创建session时autoCloseSessionEnabled参数为false，即在事物结束后不会自动关闭session，需要手动关闭，如果不关闭将导致session关联的数据库连接无法释放，最后资源耗尽而使程序当掉。 getCurrentSession创建session时autoCloseSessionEnabled，flushBeforeCompletionEnabled都为true，并且session会同sessionFactory组成一个map以sessionFactory为主键绑定到当前线程。 getCurrentSession():从上下文（配置文件current_session_context_class: thread 使用Connection自动管理；jta(java transaction api) 由Application Server提供的分布式事务管理，Tomcat本身不具备此能力，JBoss、WebLogic具备）找，如果有，则用旧的，否则创建新的，事务提交自动Close； 本地事务和全局事务 全局事务：资源管理器管理和协调的事务，可以跨越多个数据库和进程。资源管理器一般使用 XA 二阶段提交协议与“企业信息系统”(EIS) 或数据库进行交互。 本地事务：在单个 EIS 或数据库的本地并且限制在单个进程内的事务。本地事务不涉及多个数据来源。 在Hibernate配置文件中有这么两种配置方式: 如果使用的是本地事务（jdbc事务）&lt;property name=&quot;hibernate.current_session_context_class&quot;&gt;thread&lt;/property&gt;,这个是我们常用的选项,只针对一个数据库进行操作，也就是说只针对一个事务性资源进行操作. 如果使用的是全局事务（jta事务）&lt;property name=&quot;hibernate.current_session_context_class&quot;&gt;jta&lt;/property&gt; 以前我们学习的事务类型都属于本地事务。 JTA(全局事务)和thread(本地事务)有什么区别呢？在某些应用场合，只能使用全局事务，比如： 有两个数据库：mysql 和 oracle 现在有个业务需求–转账 : 1234step 1&gt; update mysql_table set amount=amount-xx where id=aaa /*发生扣钱,假设是在mysql数据库扣钱的。 */step 2&gt; update oracle_table set amount=amount+xx where id=bbb/* 加钱,假设是在oracle数据库扣钱的。 */ 现在怎么确保两个语句在同一个事务里执行呢？12345678/*以前在JDBC里是这样做 */connection = mysql /*连接mysql */connection.setAutoCommit(false); /*不自动提交 */1&gt; update mysql_table set amount=amount-xx where id=aaa /*发生扣钱,假设是在mysql数据库扣钱的。 */2&gt; update oracle_table set amount=amount+xx where id=bbb /*发生在oracle数据库 */connection.commit(); 执行这两条语句，然后通过connection对象提交事务.我们这样子做只能确保这两个语句在同一个数据库mysql里面实现在同一个事务里执行。 但是问题是我们现在是要连接到oracle数据库，是不是需要connection2啊？ 12345678connection = mysql /*连接mysql */connection2 = oracle /*连接oracle */connection.setAutoCommit(false); /*不自动提交 */1&gt; update mysql_table set amount=amount-xx where id=aaa /*发生扣钱,假设是在mysql数据库扣钱的。 */2&gt; update oracle_table set amount=amount+xx where id=bbb /*发生在oracle数据库 /*connection.commit(); connection2.setAutoCommit(false); connection2.commit(); 事务只能在一个connection里打开，并且确保两条语句都在该connection里执行，这样才能让两条语句在同一事务里执行，现在问题就在于connection2是连接到oracle数据库的，那么connection2再开事务有意义吗？它能确保吗？不能，所以在这种情况下就只能使用全局事务了。这种情况下用普通JDBC操作是满足不了这个业务需求的，这种业务需求只能使用全局事务，本地事务是无法支持我们的操作的，因为这时候，事务的生命周期不应该局限于connection对象的生命周期范围全局事务怎么做呢？ 123456JPA.getUserTransaction().begin(); /*首先要全局事务的API,不需要我们编写，通常容器已经提供给我们了，我们只需要begin一下 */connection = mysql /*连接mysql */connection2 = oracle /*连接oracle*/connection--&gt; update mysql_table set amount=amount-xx where id=aaa /*发生扣钱,假设是在mysql数据库扣钱的。 */connection2--&gt; update oracle_table set amount=amount+xx where id=bbb /*发生在oracle数据库 */JPA.getUserTransaction().commit(); 那么它是怎么知道事务该提交还是回滚呢？这时候它使用了二次提交协议。二次提交协议简单说就这样：如果你先执行第一条语句，执行的结果先预提交到数据库，预提交到数据库了，数据库会执行这条语句，然后返回一个执行的结果，这个结果假如我们用布尔值表示的话，成功就是true，失败就是false.然后把执行的结果放入一个（假设是List）对象里面去，接下来再执行第二条语句，执行完第二条语句之后（也是预处理，数据库不会真正实现数据的提交，只是说这条语句送到数据库里面，它模拟下执行，给你返回个执行的结果），假如这两条语句的执行结果在List里面都是true的话，那么这个事务就认为语句是成功的，这时候全局事务就会提交。二次提交协议，数据库在第一次提交这个语句时，只会做预处理，不会发生真正的数据改变，当我们在全局事务提交的时候，这时候发生了第二次提交，那么第二次提交的时候才会真正的发生数据的改动。 如果说在执行这两条语句中，有一个出错了，那么List集合里就有个元素为false，那么全局事务就认为你这个事务是失败的，它就会进行回滚，回滚的时候，哪怕你的第二条语句在第一次提交的时候是成功的，它在第二次提交的时候也会回滚，那么第一次的更改也会恢复到之前的状态，这就是二次提交协议。（可以查看一下数据库方面的文档来了解二次提交协议） 原文链接hibernate中openSession()跟getCurrentSession()方法之间的区别 事务-本地事务和全局事务","tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://super3h.me/tags/Hibernate/"},{"name":"J2EE","slug":"J2EE","permalink":"https://super3h.me/tags/J2EE/"}]},{"title":"J2EE-Hibernate关系配置","date":"2017-01-29T12:29:11.873Z","path":"2017/01/29/J2EE-Hibernate关系配置/","text":"cascade 、inverse详解 cascade有以下四种值：all: 所有情况下均进行关联操作。none: 所有情况下均不进行关联操作。这是默认值。save-update: 在执行save/update/saveOrUpdate时进行关联操作。delete: 在执行delete时进行关联操作。 inverse `详情请点：cascade 、inverse详解 一对多（多对一）班级12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\"&gt;&lt;hibernate-mapping&gt; &lt;class name=\"cn.itcast.hiberate.sh.domain.Classes\"&gt; &lt;id name=\"cid\" length=\"5\" type=\"java.lang.Long\"&gt; &lt;generator class=\"increment\"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=\"cname\" length=\"20\" type=\"java.lang.String\"&gt;&lt;/property&gt; &lt;property name=\"description\" length=\"100\" type=\"java.lang.String\"&gt;&lt;/property&gt; &lt;!-- set元素对应类中的set集合 通过set元素使classes表与student表建立关联 key是通过外键的形式让两张表建立关联 one-to-many是通过类的形式让两个类建立关联 cascade 级联 save-update 1、当 保存班级的时候，对学生进行怎么样的操作 如果学生对象在数据库中没有对应的值，这个时候会执行save操作 如果学生对象在数据库中有对应的值，这个时候会执行update操作 delete all inverse 维护关系 true 不维护关系 false 维护关系 default false --&gt; &lt;set name=\"students\" cascade=\"all\" inverse=\"true\"&gt; &lt;!-- key是用来描述外键 --&gt; &lt;key&gt; &lt;column name=\"cid\"&gt;&lt;/column&gt; &lt;/key&gt; &lt;one-to-many class=\"cn.itcast.hiberate.sh.domain.Student\"/&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 学生123456789101112&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\"&gt;&lt;hibernate-mapping&gt; &lt;class name=\"cn.itcast.hiberate.sh.domain.Student\"&gt; &lt;id name=\"sid\" length=\"5\"&gt; &lt;generator class=\"increment\"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=\"sname\" length=\"20\"&gt;&lt;/property&gt; &lt;property name=\"description\" length=\"100\"&gt;&lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 多对多多对多关系也很常见，例如学生与选修课之间的关系，一个学生可以选择多门选修课，而每个选修课又可以被多名学生选择。数据库中的多对多关联关系一般需采用中间表的方式处理，将多对多转化为两个一对多。学生：123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\"&gt;&lt;hibernate-mapping&gt; &lt;class name=\"com.suxiaolei.hibernate.pojos.Student\" table=\"student\"&gt; &lt;id name=\"id\" type=\"integer\"&gt; &lt;column name=\"id\"&gt;&lt;/column&gt; &lt;generator class=\"increment\"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=\"name\" column=\"name\" type=\"string\"&gt;&lt;/property&gt; &lt;set name=\"courses\" inverse=\"false\" cascade=\"save-update\" table=\"student_course\"&gt; &lt;key column=\"student_id\"&gt;&lt;/key&gt; &lt;many-to-many class=\"com.suxiaolei.hibernate.pojos.Course\" column=\"course_id\"&gt;&lt;/many-to-many&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 课程：123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\"&gt;&lt;hibernate-mapping&gt; &lt;class name=\"com.suxiaolei.hibernate.pojos.Course\" table=\"course\"&gt; &lt;id name=\"id\" type=\"integer\"&gt; &lt;column name=\"id\"&gt;&lt;/column&gt; &lt;generator class=\"increment\"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=\"name\" column=\"name\" type=\"string\"&gt;&lt;/property&gt; &lt;set name=\"students\" inverse=\"true\" cascade=\"save-update\" table=\"student_course\"&gt; &lt;key column=\"course_id\"&gt;&lt;/key&gt; &lt;many-to-many class=\"com.suxiaolei.hibernate.pojos.Student\" column=\"student_id\"&gt;&lt;/many-to-many&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 一对一 一对一关系就球队与球队所在地之间的关系，一支球队仅有一个地址，而一个地区也仅有一支球队（貌似有点勉强，将就下吧）。数据表间一对一关系的表现有两种，一种是外键关联，一种是主键关联。图示如下： 一对一外键关联：地址：123456789101112131415&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\"&gt;&lt;hibernate-mapping&gt; &lt;class name=\"com.suxiaolei.hibernate.pojos.Adress\" table=\"adress\"&gt; &lt;id name=\"id\" type=\"integer\"&gt; &lt;column name=\"id\"&gt;&lt;/column&gt; &lt;generator class=\"increment\"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=\"city\" column=\"city\" type=\"string\"&gt;&lt;/property&gt; &lt;one-to-one name=\"team\" class=\"com.suxiaolei.hibernate.pojos.Team\" cascade=\"all\"&gt;&lt;/one-to-one&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 球队：123456789101112131415&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\"&gt;&lt;hibernate-mapping&gt; &lt;class name=\"com.suxiaolei.hibernate.pojos.Team\" table=\"team\"&gt; &lt;id name=\"id\" type=\"integer\"&gt; &lt;column name=\"id\"&gt;&lt;/column&gt; &lt;generator class=\"increment\"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=\"name\" column=\"name\" type=\"string\"&gt;&lt;/property&gt; &lt;many-to-one name=\"adress\" class=\"com.suxiaolei.hibernate.pojos.Adress\" column=\"adress_id\" unique=\"true\"&gt;&lt;/many-to-one&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 一对一外键关联，其实可以看做是一对多的一种特殊形式，多方退化成一。多方退化成一只需要在标签中设置”unique”=”true”。 一对一主键关联在hbm文件中的配置信息：地址:12345678910111213&lt;hibernate-mapping&gt; &lt;class name=\"com.suxiaolei.hibernate.pojos.Adress\" table=\"adress\"&gt; &lt;id name=\"id\" type=\"integer\"&gt; &lt;column name=\"id\"&gt;&lt;/column&gt; &lt;generator class=\"increment\"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=\"city\" column=\"city\" type=\"string\"&gt;&lt;/property&gt; &lt;one-to-one name=\"team\" class=\"com.suxiaolei.hibernate.pojos.Team\" cascade=\"all\"&gt;&lt;/one-to-one&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 球队:123456789101112131415&lt;hibernate-mapping&gt; &lt;class name=\"com.suxiaolei.hibernate.pojos.Team\" table=\"team\"&gt; &lt;id name=\"id\" type=\"integer\"&gt; &lt;column name=\"id\"&gt;&lt;/column&gt; &lt;generator class=\"foreign\"&gt; &lt;param name=\"property\"&gt;adress&lt;/param&gt; &lt;/generator&gt; &lt;/id&gt; &lt;property name=\"name\" column=\"name\" type=\"string\"&gt;&lt;/property&gt; &lt;one-to-one name=\"adress\" class=\"com.suxiaolei.hibernate.pojos.Adress\" cascade=\"all\"&gt;&lt;/one-to-one&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 一对一主键关联，是让两张的主键值一样。要使两表的主键相同，只能一张表生成主键，另一张表参考主键。 123&lt;generator class=\"foreign\"&gt; &lt;param name=\"property\"&gt;adress&lt;/param&gt;&lt;/generator&gt; &quot;class&quot;=&quot;foreign&quot;就是设置team表的主键参照adress属性的主键值。 详情请看Hibernate关联关系配置","tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://super3h.me/tags/Hibernate/"},{"name":"J2EE","slug":"J2EE","permalink":"https://super3h.me/tags/J2EE/"}]},{"title":"J2EE-Hibernate-Session的缓存及对象的状态","date":"2017-01-25T09:25:26.034Z","path":"2017/01/25/J2EE-Hibernate-Session/","text":"Session的缓存Java是纯面向对象的语言，因此不可能像C语言那样直接操纵内存，例如声明一段可用的内存空间。在Java里面，缓存通常是指Java对象的属性占用的 内存空间，通常是一些集合类型的属性。在session接口的实现类SessionImpl中定义了一系列的Java集合，这些Java集合就构成了 Session的缓存。 使用缓存的一个很明显的好处就是可以减少数据库访问的频率，提高应用程序的性能，因为从内存中读取数据显然要比从数据库中查询快多了。 Hibernate中Java对象的状态在一个Hibernate应用中，Java对象可以处于以下三个状态之一： 瞬时状态(Transient)：也叫临时状态，处于这个状态的对象还被没有纳入Hibernate的缓存管理体系，跟任何session都不关联，在数据库中也没有对应的记录。超过作用域会被JVM垃圾回收器回收，一般是new出来且与session没有关联的对象。 持久化状态(Persistent)：处于这个状态的对象位于Session的缓存中，并且和数据库中的一条数据记录相对应。并且相关联的session没有关闭，事务没有提交，持久对象状态发生改变，在事务提交时会影响到数据库(hibernate能检测到)。 脱管状态(Detached)：也叫游离状态，处于这个状态的对象不再位于Session的缓存中，当前没有session与之关联；托管对象状态发生改变，hibernate不能检测到。它与临时对象的最大区别在于，游离对象在数据库中还可能存在一条与它对应的记录。上述3个状态之间是可以相互转化的，而且我们所说的状态都是针对某一个session实例而言的，比方说，对象A对于session1而言是处于持久化状态的，因为它处于session1的缓存中，但是对于session2而言对象A并不在它的缓存中，因此它是处于游离状态的。对于这几个状态的理解花费了我一定的时间，因为总是有一些稀奇古怪的念头在我脑海中产生。比如说，对于临时状态的定义，如果我新建一个对象，然后人为的让 它属性的值和数据库中的一条记录对应，包括id的取值都一样。此时它能否说是处于游离状态呢？因为它和一条记录想对应呀。实际上这些情况都是由于一些不和 规范的操作而产生的。在Hibernate应用中，&lt;font color=&apos;green&apos;&gt;无论Java对象处于临时状态、持久化状态还是游离状态，应用程序都不应该修改它的OID。&lt;/font&gt;&lt;font color=&apos;red&apos;&gt;OID（也就是实体类中的主键属性）&lt;/font&gt;的值应该由Hibernate来维护和负责，实际上Hibernate在同步缓存中的对象与数据库中的记录时，都是通过OID来进行关联和映射的，如果应用程序人为的修改了对象的OID，就会导致一些莫名其妙的错误，而且这样也不利于数据的同步。 至于对象之间的状态转化，如下图： 详情请看Hibernate持久化对象的生命周期","tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://super3h.me/tags/Hibernate/"},{"name":"J2EE","slug":"J2EE","permalink":"https://super3h.me/tags/J2EE/"}]},{"title":"J2EE-Hibernate的核心接口","date":"2017-01-25T09:02:35.871Z","path":"2017/01/25/J2EE-Hibernate的核心接口/","text":"简介 Hibernate作为持久成中间件，它的具体实现对与上层调用是透明的，即上层通过接口来调用Hibernate的具体实现，所以对于入门级别的讨论来说，自然应该先从接口开始了。 所有的Hibernate应用都会访问它的5个核心接口，分别如下： Configuration接口： SessionFactory接口： Session接口： Transaction接口： Configuration接口 Configuration用于配置并启动Hibernate。Hibernate应用通过Configuration的实例来指定对象-关系映射文件 ,或通过Configuration动态配置Hibernate的属性，然后通过Configuration来创建相应的SessionFactory实例。Configuration实例是什么时候指定ORM文件的地址的呢？我们可以查看Configuration的源代码，它的configure()方法是这样实现的： 1234public Configuration configure() throws HibernateException &#123; configure( \"/hibernate.cfg.xml\" );//此处指定了ORM文件的位置 return this; &#125; 原来它是在这里指定了ORM文件的位置，这就是为什么Hibernate总是默认到classpath下去寻找hibernate.cfg.xml 文件的原因了。 实际上我们还可以通过configure(String resource)来动态的指定配置文件，只不过通常我们都是采用的默认设置罢了。这样的话我们的配置文件就都被读取了，同时配置文件中通 过元素引入的映射文件也被读取了。 SessionFactory接口一个SessionFactory对应一个数据源，它是个重量级对象，不可随意生成多个实例。对于一般的单数据库应用来说，只需要一个 SessionFactory就足够了。当然如果有多个数据库的话，还是需要为每个数据库生成对应的SessionFactory？一般而言，一个SessionFactory对象就代表一个数据库存储源。它是线程安全的，同一 个实例可以被应用中的多个线程共享。由此我们看出SessionFactory具备如下两个特点： 线程安全。整个应用共用一个SessionFactory实例。 重量级。在SessionFactory中存放了Hibernate配置信息以及映射元素据信息，这些都需要很大的缓存。一般来说，SessionFactory的主要作用就是创建Session对象，所有的线程都是从SessionFactory中获取Session对象来处理客户请求的。 也许你会很好奇，SessionFactory为什么是重量级对象呢？我也同样好奇，通过查看Hibernate的源码，发现 SessionFactory存放了大量预定义的SQL语句以及映射元数据，所以自然需要很大的缓存了，同时需要一定的CPU时间来计算生成。想想 Hibernate的这个设计是很有意义的，因为有了Mapping文件，很多SQL语句就已经确定了，只需要动态生成一次就可以了，这个设计也是为了提 高持久化的效率。 Session接口从SessionFactory中可以获得Session实例。Session接口是Hibernate应用中使用最广泛的接口了，它是持久化管理器，提供添加、更新、删除、加载、查询对象。Session的每个方法都值得我们去研究和探讨，不过最常用的还是save、saveOrUpdate、update、delete、createQuery等方法了，关于Session是如何作用的以及它的工作原理在以后的实践中再一步一步的进行学习和探讨！！Session不是线程安 全的，所以应避免多个线程共享同一个Session实例。Session是轻量级对象，它的创建和销毁不需要太多资源，这意味着在应用中可以经常创建和销 毁Session对象。Session有一个缓存，称之为Hibernate的一级缓存，它存放当前工作单元加载的持久化对象，每个Session都有自己的缓存，缓存中的对象只能被当前工作单元访问。 Transaction接口Transaction是Hibernate的数据库事务接口，它对底层的事务接口进行了封装，底层事务接口包括: JDBC API JTA(Java Transaction API) CORBA(Common Object Requet Broker Architecture) APIHibernate应用可以通过一致Transaction接口来声明事务边界，这有助于应用可以在不同的环境或容器中移植。具体的事务实现使用在Hibernate.properties中进行指定。 Query和Criteria接口（也叫条件查询接口）这两个是Hibernate的查询接口，用于向数据库查询对象，以及控制执行查询的过程。Query实例包装了一个HQL(Hibernate Query Language)来查询。Criteria接口完全封装了基于字符串形式的查询语句，比Query更面向对象，Criteria更擅长执行动态查询。 标准化对象查询(Criteria Query)：以对象的方式进行查询，将查询语句封装为对象操作。优点：可读性好，符合Java 程序员的编码习惯。缺点：不够成熟，不支持投影（projection）或统计函数（aggregation） Hibernate语言查询（Hibernate Query Language，HQL）：它是完全面向对象的查询语句，查询功能非常强大，具备继承、多态和关联等特性 。Hibernate官方推荐使用HQL进行查询。 以上为5个核心接口，当然Hibernate不仅仅只有这5个接口了，还有回调接口、映射类型接口、可扩展的接口等等，但这些接口不同于以上的5个核心接口，因为这些接口在一般的Hibernate中不一定能用到，所以暂不提及，在以后的高级应用中再做详述吧。 原文链接请参考 Hibernate的核心接口","tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://super3h.me/tags/Hibernate/"},{"name":"J2EE","slug":"J2EE","permalink":"https://super3h.me/tags/J2EE/"}]},{"title":"J2EE-Hibernate数据源配置","date":"2017-01-25T08:42:03.679Z","path":"2017/01/25/J2EE-Hibernate数据源配置/","text":"c3p0连接池 c3p0连接池是Hibernate推荐使用的连接池，若需要使用该连接池时，需要将c3p0的jar包加入到classpath中。c3p0连接池的配置示例如下hibernate.cfg.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version=”1.0″ encoding=”UTF-8″?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC“-//Hibernate/Hibernate Configuration DTD 3.0//EN”“http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd“&gt;&lt;hibernate-configuration&gt;&lt;session-factory&gt;&lt;!– 显示实际操作数据库时的SQL –&gt;&lt;property name=”show_sql”&gt;true&lt;/property&gt;&lt;!– SQL方言，这边设定的是MySQL –&gt;&lt;property name=”dialect”&gt;net.sf.hibernate.dialect.MySQLDialect&lt;/property&gt;&lt;!–驱动程序，在后续的章节中将讲述mysql、sqlserver和Oracle数据库的配置 –&gt;&lt;property name=”connection.driver_class”&gt;……&lt;/property&gt;&lt;!– JDBC URL –&gt;&lt;property name=”connection.url”&gt;……&lt;/property&gt;&lt;!– 数据库用户名 –&gt;&lt;property name=”connection.username”&gt;user&lt;/property&gt;&lt;!– 数据库密码 –&gt;&lt;property name=”connection.password”&gt;pass&lt;/property&gt;&lt;property name=”c3p0.min_size”&gt;5&lt;/property&gt;&lt;property name=”c3p0.max_size”&gt;20&lt;/property&gt;&lt;property name=”c3p0.timeout”&gt;1800&lt;/property&gt;&lt;property name=”c3p0.max_statements”&gt;50&lt;/property&gt;&lt;!– 对象与数据库表格映像文件 –&gt;&lt;mapping resource=”com/amigo/pojo/User.hbm.xml”/&gt;&lt;mapping resource=”com/amigo/pojo/Org.hbm.xml”/&gt;&lt;/session-factory&gt;&lt;/hibernate-configuration&gt; MySql连接配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=”1.0″ encoding=”UTF-8″?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC“-//Hibernate/Hibernate Configuration DTD 3.0//EN”“http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd“&gt;&lt;hibernate-configuration&gt;&lt;session-factory&gt;&lt;!– 各属性的配置–&gt;&lt;!—为true表示将Hibernate发送给数据库的sql显示出来 –&gt;&lt;property name=”show_sql”&gt;true&lt;/property&gt;&lt;!– SQL方言，这边设定的是MySQL –&gt;&lt;property name=”dialect”&gt;net.sf.hibernate.dialect.MySQLDialect&lt;/property&gt;&lt;!– 一次读的数据库记录数 –&gt;&lt;property name=”jdbc.fetch_size”&gt;50&lt;/property&gt;&lt;!– 设定对数据库进行批量删除 –&gt;&lt;property name=”jdbc.batch_size”&gt;30&lt;/property&gt;&lt;!–驱动程序–&gt;&lt;property name=”connection.driver_class”&gt;com.mysql.jdbc.Driver&lt;/property&gt;&lt;!– JDBC URL –&gt;&lt;property name=”connection.url”&gt;jdbc:mysql://localhost/dbname?characterEncoding=gb2312&lt;/property&gt;&lt;!– 数据库用户名–&gt;&lt;property name=”connection.username”&gt;root&lt;/property&gt;&lt;!– 数据库密码–&gt;&lt;property name=”connection.password”&gt;root&lt;/property&gt;&lt;!—映射文件 –&gt;&lt;mapping resource=”com/amigo/pojo/User.hbm.xml”/&gt;&lt;mapping resource=”com/amigo/pojo/Org.hbm.xml”/&gt;&lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 上面使用的驱动类是com.mysql.jdbc.Driver。需要将MySql的连接器jar包(eg. mysql-connector-java-5.0.4-bin.jar)加入到classpath中。 更多配置请参考Hibernate配置各种数据源详解","tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://super3h.me/tags/Hibernate/"},{"name":"J2EE","slug":"J2EE","permalink":"https://super3h.me/tags/J2EE/"}]},{"title":"Hexo-github cards和微博秀的生成","date":"2017-01-24T14:07:21.413Z","path":"2017/01/24/Hexo-插件/","text":"搭建博客原文链接：请参考如下地址–&gt;我是怎么走向Github建立博客掉坑之路的？ 切记 里面的链接一定要都看完 过程虽然相同 但步骤不同，取其优点即可！！！ 问题 github-cards生成问题微博秀生成问题 解决问题由于github完整信息没填完整导致插件无法获取信息，所以名片显示不出来。方法如下： github-setting 完成后结果如下: github-cards HTTP和HTTPS交叉使用而产生跨域，使其没办法加载出来，解决方案如下：在jacman\\layout\\_partial路径下的head.ejs的文件中添加如下语句:&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;upgrade-insecure-requests&quot; /&gt;位置如下：1234567891011121314151617181920&lt;head&gt; &lt;meta http-equiv=\"Content-Security-Policy\" content=\"upgrade-insecure-requests\" /&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;% var title = page.title; if (is_archive())&#123; title = __('archive_a'); if (is_month())&#123; title += ': ' + page.year + '/' + page.month; &#125; else if (is_year())&#123; title += ': ' + page.year; &#125; &#125; else if (is_category())&#123; title = __('categories')+' : ' + page.category; &#125; else if (is_tag())&#123; title = __('tags')+' : ' + page.tag; &#125; %&gt; 最后表现为: weiboShow 本地图片无法再网上显示？？请参考链接—-&gt;hexo 中无痛使用本地图片 切记 文章名要和图片目录名一致！！！！ 更多详情请参考嘟嘟独立博客如何使用 Jacman 主题Markdown语法","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://super3h.me/tags/Hexo/"}]},{"title":"Java有关说明O的概念","date":"2017-01-24T04:11:31.277Z","path":"2017/01/24/Java-XO概念/","text":"POJO POJO（Plain Old Java Object）这种叫法是Martin Fowler、Rebecca Parsons和Josh MacKenzie在2000年的一次演讲的时候提出来的。按照Martin Fowler的解释是“Plain Old Java Object”，从字面上翻译为“纯洁老式的java对象”，但大家都使用“简单java对象”来称呼它。 POJO的内在含义是指那些: [x] 有一些private的参数作为对象的属性，然后针对每一个参数定义get和set方法访问的接口。没有从任何类继承、也没有实现任何接口，更没有被其它框架侵入的java对象。 123456789101112131415161718192021public class User &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; &#125; JavaBean JavaBean 是一种JAVA语言写成的可重用组件。JavaBean符合一定规范编写的Java类，不是一种技术，而是一种规范。大家针对这种规范，总结了很多开发技巧、工具函数。符合这种规范的类，可以被其它的程序员或者框架使用。它的方法命名，构造及行为必须符合特定的约定： [x] 1、所有属性为private。 [x] 2、这个类必须有一个公共的缺省构造函数。即是提供无参数的构造器。 [x] 3、这个类的属性使用getter和setter来访问，其他方法遵从标准命名规范。 [x] 4、这个类应是可序列化的。实现serializable接口。 [x] 因为这些要求主要是靠约定而不是靠实现接口，所以许多开发者把JavaBean看作遵从特定命名约定的POJO。 12345678910111213141516171819202122232425262728293031323334public class UserInfo implements java.io.Serializable&#123; //实现serializable接口。 private static final long serialVersionUID = 1L; private String name; private int age; //无参构造器 public UserInfo() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; //javabean当中可以有其它的方法 public void userInfoPrint()&#123; System.out.println(\"\"); &#125; &#125; 两者有什么区别？ [x] POJO其实是比javabean更纯净的简单类或接口。POJO严格地遵守简单对象的概念，而一些JavaBean中往往会封装一些简单逻辑。 [x] pojo的格式是用于数据的临时传递，它只能装载数据， 作为数据存储的载体，而不具有业务逻辑处理的能力。 [x] 而javabean虽然数据的获取与pojo一样，但是javabean当中可以有其它的方法。 DAO DAO（data access objects） [x] DAO是数据访问对象，DAO一般有接口和该接口的实现类，接口用于规范实现类。实现类一般用于操作数据库，如对数据库进行修改、添加、删除等操作，一般直接调用公共类DAO。 什么是DTO（data transfer object）、什么是VO（value object）、什么是PO（persistent object）？ [x] 我们通过DAO将POJO持久化为PO，用PO组装出来VO、DTO。 [x] 总结下，我认为一个对象究竟是什么O要看具体环境，在不同的层、不同的应用场合，对象的身份也不一样，而且对象身份的转化也是很自然的。就像你对老婆来说就是老公，对父母来说就是子女。设计这些概念的初衷不是为了唬人而是为了更好的理解和处理各种逻辑，让大家能更好的去用面向对象的方式处理问题。比如：我们一张表有100个字段，那么对应的PO就有100个属性。但是我们界面上只要显示10个字段，客户端用WEBservice来获取数据，没有必要把整个PO对象传递到客户端，这时我们就可以用只有这10个属性的DTO来传递结果到客户端，这样也不会暴露服务端表结构.到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO。 什么是BO（business object）？ [x] BO: POJO在业务层的体现，对于业务操作来说，更多的是从业务上来包装对象，如一个User的BO，可能包括name, age, sex, privilege, group等，这些属性在数据库中可能会在多张表中，因为每一张表对应一个PO，而我们的BO需要这些PO组合起来(或说重新拼装)才能成为业务上的一个完整对象。 EJB EJB(Enterprise JavaBean): [x] 我认为它是一组”功能JavaBean的集合。上面说了JavaBean是实现了一种规范的Java对象。这里说EJB是一组JavaBean，的意思是这一组JavaBean组合起来实现了某个企业组的业务逻辑。这里的一组JavaBean不是乱组合的，它们要满足能实现某项业务功能的搭配。找个比方，对于一身穿着来说，包括一顶帽子，一件衣服，一条裤子，两只鞋。这穿着就是EJB，其它的就是一个JavaBean 原文链接JAVABEAN EJB POJO区别","tags":[{"name":"J2EE","slug":"J2EE","permalink":"https://super3h.me/tags/J2EE/"}]},{"title":"Hibernate浅学","date":"2017-01-24T00:36:30.067Z","path":"2017/01/24/J2EE-Hibernate/","text":"简介 Hibernate是一种对JDBC做了轻量级封装的对象—关系映射工具，所谓轻量级封装，是指Hibernate并没有完全封装JDBC，Java应用即可以通过Hibernate API访问数据库，还可以绕过Hibernate API，直接通过JDBC API来访问数据库。 Hibernate官网下载地址Hibernate官网。现在最新的是： hibernate-release-5.2.5.Final 解压后的目录结构：Documentation: 该文件夹下是开发帮助文档Lib: 该文件夹是开发使用的库。以下包为必须的： required目录是开发时必须导入的JAR文件； optional\\c3p0目录为开源的JDBC连接池(与其相对应的为的dbcp,区别：dbcp没有自动回收空闲连接的功能||c3p0有自动回收空闲连接功能，一般都用c3p0) mysql-connector-javaJDBC驱动包Project: 该文件夹是项目源码文件 持久化JAVA类必须遵循的原则 A、为类的持久化字段声明访问方法（get/set），Hibernate对JavaBeans风格的属性实行持久化。B、实现一个默认的构造方法，这样的话Hibernate就可以使用Constructor.newInstance()方法来实例化对象。C、如果是集合类型的属性，它的类型必须定义为集合的接口，例如：List、SetD、提供一个标识属性（Identifier property )，如果没有该属性，一些功能不起作用，比如：级联更新，session.saveOrUpdate()。 开发步骤编写实体类UserInfor.java 实体类中的属性名有二个以上（含两个）的小写字母开头！！！！123456789101112131415import java.util.Date;public class UserInfor &#123; private int userId; private String userName; private int userAge; public UserInfor() &#123; // 一定要有一个无参的构造方法，因为Hibernate都是根据他生成对象的 &#125; public UserInfor(int userid) &#123;// 最好要有一个含主键的构造方法，因为在Hibernate中便于查询 this.userId = userid; &#125; //....下面都是get***（）set***()封装属性 &#125; 创建实体类的映射文件*.hbm.xml（与实体类同包，并且名字可以自定义） 技巧: 可以在上面解压后的Project文件夹中搜索*.hbm.xml，找到示例文在加以修改即可！！！ 123456789101112131415&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\"&gt;&lt;hibernate-mapping package=\"com.entity\"&gt; &lt;class name=\"UserInfor\" table=\"Wuser\" &gt; &lt;id name=\"userId\" &gt; &lt;generator class=\"native\"/&gt; &lt;/id&gt; &lt;property name=\"userName\"/&gt; &lt;property name=\"userAge\"/&gt; &lt;property name=\"userBirthday\"/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 具体hibernate详情请看详解 根元素：&lt;hibernate-mapping&gt; 每一个hbm.xml文件都有唯一的一个根元素，包含一些可选的属性 package：指定一个包前缀，即该xml文件的位置 &lt;class&gt;定义类 根元素的子元素，用以定义一个持久化类与数据表的映射关系,如下是该元素包含的一些可选的属性–&gt; name：持久化类(或者接口)的Java全限定名,如果这个属性不存在,则Hibernate将假定这是一个非POJO的实体映射；table：对应数据库表名 &lt;id&gt;定义主键 Hibernate使用OID(对象标识符)来标识对象的唯一性，OID是关系数据库中主键在Java对象模型中的等价物,在运行时,Hibernate根据OID来维持Java对象和数据库表中记录的对应关系 name：持久化类的标识属性的名字 column：数据库表的主键这段的名字 &lt;generator&gt;设置主键生成方式 increment：由hibernate自动递增生成标识符,用于为long, short或者int类型生成唯一标识。 identity：由底层数据库生成标识符(自动增长),返回的标识符是 long, short 或者int类型的。 sequence：hibernate根据底层数据库序列生成标识符,返回的标识符 是long, short或者 int类型的。 hilo：使用一个高/低位算法来高效的生成long, short 或者int类型的标识符。 uuid.hex：用一个128-bit的UUID算法生成32位字符串类型的标识符。 native :根据底层数据库的能力选择identity, sequence 或者hilo中的一个。推荐用这个 assigned：让应用程序在save()之前为对象分配一个标示符。 foreign：:使用另外一个相关联的对象的标识符。和联合一起使用。 详情：:Hibernate generator||关系映射文件*.hbm.xml详解 该元素的作用是指定主键的生成器，通过一个class属性指定生成器对应的类。(通常与元素结合使用)，–native是Hibernate主键生成器的实现算法之一，由Hibernate根据底层数据库自行判断采用identity、hilo、sequence其中一种作为主键生成方式。 &lt;property&gt;定义属性用于持久化类的属性与数据库表字段之间的映射,包含如下属性： name：持久化类的属性名，以小写字母开头 column：数据库表的字段名详细配置点此处 编写Hibernate的配置文件hibernate.cfg.xml（这里的名字是固定的）Hibernate配置的两种方法： 属性文件：hibernate.properties 调用代码：Configuration cfg=new Configuration(); XML文件：hibernate.cfg.xml 调用代码： Configuration cfg=new Configuration().configure();123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\" \"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd\"&gt;&lt;hibernate-configuration&gt; &lt;!-- 一个session-factory只能连接一个数据库 --&gt; &lt;session-factory&gt; &lt;!-- 数据库的用户名 --&gt; &lt;property name=\"connection.username\"&gt;root&lt;/property&gt; &lt;!-- 密码 --&gt; &lt;property name=\"connection.password\"&gt;root&lt;/property&gt; &lt;!-- url --&gt; &lt;property name=\"connection.url\"&gt; jdbc:mysql://localhost:3306/hibernateday02 &lt;/property&gt; &lt;!-- 作用：根据持久化类和映射文件生成表 validate: 每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。 create-drop: 每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。 create: 每次加载hibernate时都会删除上一次的生成的表，然后根据你的model类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。 update: 最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），以后加载hibernate时根据 model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等 应用第一次运行起来后才会。 --&gt; &lt;property name=\"hbm2ddl.auto\"&gt;update&lt;/property&gt; &lt;!-- 显示hibernate内部生成的sql语句 --&gt; &lt;property name=\"show_sql\"&gt;true&lt;/property&gt; &lt;mapping resource=\"hhh/domain/Person.hbm.xml\" /&gt; &lt;mapping resource=\"hhh/domain1/Clazz.hbm.xml\" /&gt; &lt;mapping resource=\"hhh/domain1/student.xml\" /&gt; &lt;mapping resource=\"hhh/Person.hbm.xml\" /&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 测试类操作1234567891011121314151617181920@Testpublic void test() &#123; // 读取Hibernate的配置文件 hibernamte.cfg.xml文件 Configuration configuration = new Configuration().configure(); // 创建会话工厂 SessionFactory sessionFactory = configuration.buildSessionFactory(); // 创建数据操作会话 Session session = sessionFactory.openSession(); // 开启事务并创建事物 Transaction transaction = session.beginTransaction(); // 创建对象 Person person = new Person(); person.setName(\"hhh\"); session.save(person); // 事务提交 transaction.commit(); // 关闭会话 session.close();&#125; configure解析 hibernate运行过程 数据库框架的比较 原文链接请点此处Hibernate初学 基础配置详解","tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://super3h.me/tags/Hibernate/"},{"name":"J2EE","slug":"J2EE","permalink":"https://super3h.me/tags/J2EE/"}]},{"title":"Eclipse-PyDev安装","date":"2017-01-23T10:24:47.288Z","path":"2017/01/23/Eclipse-PyDev/","text":"在Eclipse中安装pydev插件启动Eclipse, 点击Help-&gt;Install New Software… 在弹出的对话框中，点Add 按钮。 Name中填:Pydev, Location中填http://pydev.org/updates然后一步一步装下去。 如果装的过程中，报错了。 就重新装。 配置pydev解释器安装好pydev后， 需要配置Python解释器。在Eclipse菜单栏中，点击Windows -&gt;Preferences.在对话框中，点击pyDev-&gt;Interpreter - Python. 点击New按钮， 选择python.exe的路径, 打开后显示出一个包含很多复选框的窗口. 点OK如果是Mac系统， 点击“Auto Config” 按钮","tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"https://super3h.me/tags/Eclipse/"}]},{"title":"Python-web_project学习","date":"2017-01-21T09:43:05.015Z","path":"2017/01/21/Python-Project/","text":"原文链接flask文档 简单的包程序结构 项目最后得到的程序结构如下123456789101112/yourapplication /runserver.py /yourapplication /__init__.py /views.py /static /style.css /templates layout.html index.html login.html ... 由于原来的python yourapplication/__init__.py在/yourapplication里面不能再工作了，因此在项目最外层建立runserver.py，案例如下：12from yourapplication import appapp.run(debug=True) __init__.py作用是方便导入(不用再对应到文件导入了—-&gt;from flask.__init__ import app)例子如下1234from flask import Flaskapp = Flask(__name__)import yourapplication.views views.py案例如下：12345from yourapplication import app@app.route('/')def index(): return 'Hello World!' 循环导入 每个 Python 程序员都会讨厌他们，而我们反而还添加了几个进去: 循环导入(在两个模块相互依赖对方的时候，就会发生循环导入)。在这里 views.py 依赖于 __init__.py。通常这被认为是个不好的主意，但是在这里实际上不会造成问题。之所以如此，是因为我们实际上没有在 __init__.py 里使用这些视图，而仅仅是保证模块被导入了。并且，我们是在文件的结尾这么做的。 这种做法仍然有些问题，但是如果您想要使用修饰器，那么没有其他更好的方法了。检查 聚沙成塔 这一章来寻找解决问题的些许灵感吧 漏洞学习contextlib.closing()函数contextlib.closing()函数是实现在一个block之后自动关闭12345678with closing(&lt;module&gt;.open(&lt;arguments&gt;)) as f: &lt;block&gt;# 相当于f=&lt;module&gt;.open(&lt;arguments&gt;)try: &lt;block&gt;finally: f.close() flask数据库创建案例如下1234567def connect_db(): return sqlite3.connect(app.config['DATABASE']) #连接数据库with closing(connect_db()) as db: #连接数据库，并执行完下面的代码之后关闭 with app.open_resource('schema.sql') as f: #打开蓝本 db.cursor().executescript(f.read()) #用数据库指针执行蓝本 db.commit() #提交","tags":[{"name":"Python-Web","slug":"Python-Web","permalink":"https://super3h.me/tags/Python-Web/"}]},{"title":"python基础学习","date":"2017-01-20T07:15:59.489Z","path":"2017/01/20/Python-Base/","text":"format函数运用通过位置映射123456In [1]: '&#123;0&#125;,&#123;1&#125;'.format('kzc',18) Out[1]: 'kzc,18' In [2]: '&#123;&#125;,&#123;&#125;'.format('kzc',18) Out[2]: 'kzc,18' In [3]: '&#123;1&#125;,&#123;0&#125;,&#123;1&#125;'.format('kzc',18) Out[3]: '18,kzc,18' 通过关键字参数12In [5]: '&#123;name&#125;,&#123;age&#125;'.format(age=18,name='kzc') Out[5]: 'kzc,18' 通过对象属性12345class Person: def __init__(self,name,age): self.name,self.age = name,age def __str__(self): return 'This guy is &#123;self.name&#125;,is &#123;self.age&#125; old'.format(self=self) 12In [2]: str(Person('kzc',18)) Out[2]: 'This guy is kzc,is 18 old' 通过下标123In [7]: p=['kzc',18]In [8]: '&#123;0[0]&#125;,&#123;0[1]&#125;'.format(p)Out[8]: 'kzc,18' 格式限定符填充与对齐 填充常跟对齐一起使用^、&lt;、&gt;分别是居中、左对齐、右对齐，后面带宽度:号后面带填充的字符，只能是一个字符，不指定的话默认是用空格填充比如:123456In [15]: '&#123;:&gt;8&#125;'.format('189')Out[15]: ' 189'In [16]: '&#123;:0&gt;8&#125;'.format('189')Out[16]: '00000189'In [17]: '&#123;:a&gt;8&#125;'.format('189')Out[17]: 'aaaaa189' 精度与类型f 精度常跟类型f一起使用12In [44]: '&#123;:.2f&#125;'.format(321.33345)Out[44]: '321.33' 其他类型 主要就是进制了，b、d、o、x分别是二进制、十进制、八进制、十六进制。12345678In [54]: '&#123;:b&#125;'.format(17)Out[54]: '10001'In [55]: '&#123;:d&#125;'.format(17)Out[55]: '17'In [56]: '&#123;:o&#125;'.format(17)Out[56]: '21'In [57]: '&#123;:x&#125;'.format(17)Out[57]: '11' 用逗号还能用来做金额的千位分隔符12In [47]: '&#123;:,&#125;'.format(1234567890)Out[47]: '1,234,567,890'","tags":[{"name":"Python2","slug":"Python2","permalink":"https://super3h.me/tags/Python2/"}]},{"title":"Python-jinja 学习","date":"2017-01-20T07:01:08.223Z","path":"2017/01/20/Python-jinja/","text":"注册过滤器 如果你要在 Jinja2 中注册你自己的过滤器，你有两种方法。你可以把它们手动添加到应用的 jinja_env 或者使用 template_filter() 装饰器。下面两个例子作用相同，都是反转一个对象:123456789#第一种方法@app.template_filter('reverse')def reverse_filter(s): return s[::-1]#第二种方法def reverse_filter(s): return s[::-1]app.jinja_env.filters['reverse'] = reverse_filter 在使用装饰器的情况下，如果你想以函数名作为过滤器名，参数是可选的。注册之后， 你可以在模板中像使用 Jinja2 内置过滤器一样使用你的过滤器，请参考下面例子：12345&#123;% for x in [1,2,3] | reverse %&#125; &#123;&#123;x&#125;&#125;&#123;% endfor %&#125;#输出3 2 1 上下文处理器 Flask 上下文处理器自动向模板的上下文中插入新变量。上下文处理器在模板渲染之前运行，并且可以在模板上下文中插入新值。上下文处理器是一个返回字典的函数，这个字典的键值最终将传入应用中所有模板的上下文:123@app.context_processordef inject_user(): return dict(user=g.user) 上面的上下文处理器使得模板可以使用一个名为 user ，值为 g.user 的变量。 不过这个例子不是很有意思，因为 g 在模板中本来就是可用的，但它解释了上下文处理器是如何工作的。变量不仅限于值，上下文处理器也可以使某个函数在模板中可用（由于 Python 允许传递函数）:12345@app.context_processordef utility_processor(): def format_price(amount, currency=u'€'): return u'&#123;0:.2f&#125;&#123;1&#125;.format(amount, currency) return dict(format_price=format_price) 上面的上下文处理器使得 format_price 函数在所有模板中可用:123&#123;&#123; format_price(0.333333) &#125;&#125;#输出0.33","tags":[{"name":"Python2","slug":"Python2","permalink":"https://super3h.me/tags/Python2/"}]},{"title":"Python-sqlite3 学习","date":"2017-01-20T01:42:37.256Z","path":"2017/01/20/Python-sqlite3/","text":"安装与使用##导入Python SQLITE数据库模块1import sqlite3 创建/打开数据库 在调用connect函数的时候，指定库名称，如果指定的数据库存在就直接打开这个数据库，如果不存在就新创建一个再打开。1cx = sqlite3.connect(\"E:/test.db\") 也可以创建数据库在内存中。1con = sqlite3.connect(\":memory:\") 数据库连接对象 打开数据库时返回的对象cx就是一个数据库连接对象，它可以有以下操作： commit()–事务提交 rollback()–事务回滚 close()–关闭一个数据库连接 cursor()–创建一个游标关于commit()，如果isolation_level隔离级别默认，那么每次对数据库的操作，都需要使用该命令，你也可以设置isolation_level=None，这样就变为自动提交模式。 ROW 官方解释 案例如下12345678910111213141516171819202122232425&gt;&gt;&gt; conn.row_factory = sqlite3.Row&gt;&gt;&gt; c = conn.cursor()&gt;&gt;&gt; c.execute('select * from stocks')&lt;sqlite3.Cursor object at 0x7f4e7dd8fa80&gt;&gt;&gt;&gt; r = c.fetchone()&gt;&gt;&gt; type(r)&lt;class 'sqlite3.Row'&gt;&gt;&gt;&gt; tuple(r)('2006-01-05', 'BUY', 'RHAT', 100.0, 35.14)&gt;&gt;&gt; len(r)5&gt;&gt;&gt; r[2]'RHAT'&gt;&gt;&gt; r.keys()['date', 'trans', 'symbol', 'qty', 'price']&gt;&gt;&gt; r['qty']100.0&gt;&gt;&gt; for member in r:... print(member)...2006-01-05BUYRHAT100.035.14 更多内容请参考:一块努力的牛皮糖","tags":[{"name":"Python-Web","slug":"Python-Web","permalink":"https://super3h.me/tags/Python-Web/"},{"name":"sqlite3","slug":"sqlite3","permalink":"https://super3h.me/tags/sqlite3/"}]},{"title":"SQLAlchemy-学习","date":"2017-01-18T14:11:34.807Z","path":"2017/01/18/Python-SQLAlchemy/","text":"定义model12345678class User(Base): #表名 __tablename__='user' #表结构 id = Column(Integer,primary_key=True) name = Column(String(20)) username = Column(String(20)) password = Column(String(20)) 用法如下1user=User(name='hhh',username='cs781176645',password='123456') 不用再多此一举，创建一个User对象","tags":[{"name":"Python-Web","slug":"Python-Web","permalink":"https://super3h.me/tags/Python-Web/"},{"name":"SQLAlchemy","slug":"SQLAlchemy","permalink":"https://super3h.me/tags/SQLAlchemy/"}]},{"title":"flask学习","date":"2017-01-15T01:30:20.740Z","path":"2017/01/15/Python-flask/","text":"虚拟环境配置虚拟环境操作1234567#创建虚拟环境virtualenv envcd env\\Scripts#激活activate#退出deactivate 调试模式 有两种途径来启用调试模式。一种是直接在应用对象上设置:12app.debug = Trueapp.run() 另一种是作为 run 方法的一个参数传入:1app.run(debug=True) 静态文件相对路径问题问题引入123@app.route('/regist',methods=['POST'])def regist(): return render_template('signAndregist.html'） regist映射到html时，导致相对路径发生变化，致使html里的css等文件路径出错 解决方案 在如下图的对应位置新建一个static文件夹，将对应的文件移入static文件夹的里 并在html里加入以下配置1&lt;link href=\"&#123;&#123;url_for('static',filename='css/style.css')&#125;&#125;\" rel='stylesheet' type='text/css' /&gt; 唯一URL / 重定向行为1234567@app.route('/projects/')def projects(): return 'The project page'@app.route('/about')def about(): return 'The about page' 虽然它们看起来着实相似，但它们结尾斜线的使用在 URL 定义 中不同。 第一种情况中，指向 projects 的规范 URL 尾端有一个斜线。这种感觉很像在文件系统中的文件夹。访问一个结尾不带斜线的 URL 会被 Flask 重定向到带斜线的规范 URL 去。 然而，第二种情况的 URL 结尾不带斜线，类似 UNIX-like 系统下的文件的路径名。访问结尾带斜线的 URL 会产生一个 404 “Not Found” 错误。 这个行为使得在遗忘尾斜线时，允许关联的 URL 接任工作，与 Apache 和其它的服务器的行为并无二异。此外，也保证了 URL 的唯一，有助于避免搜索引擎索引同一个页面两次。 目录错误app.py没和templates同一目录12raise TemplateNotFound(template)TemplateNotFound: home.html 解决方案 编码问题1'gbk' codec can't decode bytes in position 52-53: illegal multibyte sequence 解决方案 编码的问题,最好都转化为unicode编码","tags":[{"name":"Python2","slug":"Python2","permalink":"https://super3h.me/tags/Python2/"},{"name":"flask","slug":"flask","permalink":"https://super3h.me/tags/flask/"}]},{"title":"having的用法","date":"2017-01-09T11:04:53.398Z","path":"2017/01/09/mysql-having/","text":"having和where的区别 having字句可以让我们筛选成组后的各种数据，where字句在聚合前先筛选记录，也就是说作用在group by和having字句前。而 having子句在聚合后对组记录进行筛选。 WHERE 子句作用于表和视图，HAVING 子句作用于组。用法错误1SELECT COUNT(*) FROM student GROUP BY dept HAVING gender='v' 错误原因HAVING 子句作用于组。当根据dept分组后无法再根据gender来查询了 解决方案1select dept,count(*) from student where gender='v' group by dept where字句在聚合前先筛选记录。所以在分组之前就查找出来","tags":[{"name":"SQL","slug":"SQL","permalink":"https://super3h.me/tags/SQL/"}]},{"title":"Java中反射机制","date":"2017-01-06T02:31:00.713Z","path":"2017/01/06/java-class/","text":"Java学习参考Java中反射机制和Class.forName、实例对象.class(属性)、实例对象getClass()的区别 博客参考地址","tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://super3h.me/tags/JavaSE/"},{"name":"反射","slug":"反射","permalink":"https://super3h.me/tags/反射/"}]},{"title":"Session与Cookie","date":"2017-01-02T12:44:14.817Z","path":"2017/01/02/Session与Cookie/","text":"两者的区别 Cookie是把用户的数据写给用户的浏览器。 Session技术把Cookie可以被用户禁用，但是session用户的数据写到用户独占的$_SESSION中,存在服务器的某个路径的文件中。 Session与cookie的详细区别 用处cookie的使用范围 保存上次登录时间等信息 保存用户名、密码，在一定时间不用 重新登录 记录用户访问网站的喜好(比如有无背景音乐、网页的背景色是什么 网站的个性化，比如定制网站的服务，内容。session的使用范围 网上商城中的购物车 保存登录用户的信息 将某些数据放入到Session中，供同一用户的各页面使用 防止用户非法登录 Java关于Session的实验会话管理之session技术","tags":[{"name":"Session","slug":"Session","permalink":"https://super3h.me/tags/Session/"},{"name":"Cookie","slug":"Cookie","permalink":"https://super3h.me/tags/Cookie/"}]},{"title":"input输入框","date":"2016-12-31T07:03:17.772Z","path":"2016/12/31/input输入框/","text":"input控制键盘文本框只能输入数字代码(小数点也不能输入)1&lt;input onkeyup=\"this.value=this.value.replace(/\\D/g,'')\" onafterpaste=\"this.value=this.value.replace(/\\D/g,'')\"&gt; 正则 /\\D/g /表达式内容/参数 如/\\D/g g :全局匹配 只能输入数字,能输小数点.12&lt;input onkeyup=\"if(isNaN(value))execCommand('undo')\" onafterpaste=\"if(isNaN(value))execCommand('undo')\"&gt; &lt;input name=txt1 onchange=\"if(/\\D/.test(this.value))&#123;alert('只能输入数字');this.value='';&#125;\"&gt; 数字和小数点方法二1&lt;input type=text tvalue=\"\" ovalue=\"\" onkeypress=\"if(!this.value.match(/^[\\+\\-]?\\d*?\\.?\\d*?$/))this.value=this.t_value;else this.tvalue=this.value;if(this.value.match(/^(?:[\\+\\-]?\\d+(?:\\.\\d+)?)?$/))this.ovalue=this.value\" onkeyup=\"if(!this.value.match(/^[\\+\\-]?\\d*?\\.?\\d*?$/))this.value=this.t_value;else this.tvalue=this.value;if(this.value.match(/^(?:[\\+\\-]?\\d+(?:\\.\\d+)?)?$/))this.ovalue=this.value\" onblur=\"if(!this.value.match(/^(?:[\\+\\-]?\\d+(?:\\.\\d+)?|\\.\\d*?)?$/))this.value=this.o_value;else&#123;if(this.value.match(/^\\.\\d+$/))this.value=0+this.value;if(this.value.match(/^\\.$/))this.value=0;this.ovalue=this.value&#125;\"&gt; 只能输入字母和汉字1&lt;input onkeyup=\"value=value.replace(/[\\d]/g,'') \"onbeforepaste=\"clipboardData.setData('text',clipboardData.getData('text').replace(/[\\d]/g,''))\" maxlength=10 name=\"Numbers\"&gt; 只能输入英文字母和数字,不能输入中文1&lt;input onkeyup=\"value=value.replace(/[^\\w\\.\\/]/ig,'')\"&gt; 只能输入数字和英文12&lt;font color=\"Red\"&gt;chun&lt;/font&gt; &lt;input onKeyUp=\"value=value.replace(/[^\\d|chun]/g,'')\"&gt; chun 小数点后只能有最多两位(数字,中文都可输入),不能输入字母和运算符号:1&lt;input onKeyPress=\"if((event.keyCode&lt;48 || event.keyCode&gt;57) &amp;&amp; event.keyCode!=46 || /\\.\\d\\d$/.test(value))event.returnValue=false\"&gt; 小数点后只能有最多两位(数字,字母,中文都可输入),可以输入运算符号1&lt;input onkeyup=\"this.value=this.value.replace(/^(\\-)*(\\d+)\\.(\\d\\d).*$/,'$1$2.$3')\"&gt; 只能是数字和小数点和加减乘除1onkeypress=\"return event.keyCode&gt;=4&amp;&amp;event.keyCode&lt;=57\"","tags":[{"name":"html","slug":"html","permalink":"https://super3h.me/tags/html/"}]},{"title":"python2.7 IndentationError","date":"2016-12-25T14:59:02.284Z","path":"2016/12/25/Python-IndentationError/","text":"错误- IndentationError: unexpected indent 原因- 你的文件里格式不对了，可能是tab和空格没对齐的问题，你需要检查下tab和空格了 解决方案 重新调整空格(4个空格) 方案二","tags":[{"name":"Python2","slug":"Python2","permalink":"https://super3h.me/tags/Python2/"}]},{"title":"python2.7 安装配置虚拟环境出错","date":"2016-12-25T14:46:29.485Z","path":"2016/12/25/Python-virtualenv/","text":"错误- virtualenv test_env- UnicodeDecodeError: ‘ascii’ codec can’t decode byte 0xbb in position 7: ordinal not in range(128) 解决方案修改编码为gbk，修改D:\\Python27\\Lib\\ntpath.py(位置由个人python安装目录决定)文件中的def join(path, *paths)函数，在函数内第一行加入 1234567891011121314151617181920212223242526272829303132# Join two (or more) paths. def join(path, *paths): \"\"\"Join two or more pathname components, inserting \"\\\\\" as needed.\"\"\" import sys reload(sys) sys.setdefaultencoding('gbk') result_drive, result_path = splitdrive(path) for p in paths: p_drive, p_path = splitdrive(p) if p_path and p_path[0] in '\\\\/': # Second path is absolute if p_drive or not result_drive: result_drive = p_drive result_path = p_path continue elif p_drive and p_drive != result_drive: if p_drive.lower() != result_drive.lower(): # Different drives =&gt; ignore the first path entirely result_drive = p_drive result_path = p_path continue # Same drive in different case result_drive = p_drive # Second path is relative to the first if result_path and result_path[-1] not in '\\\\/': result_path = result_path + '\\\\' result_path = result_path + p_path ## add separator between UNC and non-absolute path if (result_path and result_path[0] not in '\\\\/' and result_drive and result_drive[-1:] != ':'): return result_drive + sep + result_path return result_drive + result_path - 加了以下几行（注意缩进问题–&gt;4个空格） 123import sysreload(sys) sys.setdefaultencoding('gbk')","tags":[{"name":"Python2","slug":"Python2","permalink":"https://super3h.me/tags/Python2/"}]},{"title":"python2.7 安装MySQL-python报错","date":"2016-12-25T07:54:49.781Z","path":"2016/12/25/Python-Mysql_conn/","text":"错误- error: Microsoft Visual C++ 9.0 is required (Unable to find vcvarsall.bat). 解决方案1. 进这个网站Microsoft2. 下载Microsoft Visual C++ Compiler for Python 2.73. 完成安装即可 错误- Setup script exited with error: command ‘C:\\Users\\\\xbb\\xc6\\xbb\\xd4\\xbb\\xd4\\AppData\\Local\\Programs\\Common\\Microsoft\\Visual C++ for Python\\9.0\\VC\\Bin\\amd64\\cl.exe’ failed with exit status 2 解决方案- 下面网址下载安装：MySQL-python-1.2.3.win-amd64-py2.7.exe- 系统会自动找到python安装的路径，如下图 错误- Could not find a version that satisfies the requirement mysql-connector-python (from versions: )No matching distribution found for mysql-connector-python 解决方案- git clone git@github.com:mysql/mysql-connector-python.git- cd mysql-connector-python- python setup.py install","tags":[{"name":"Python2","slug":"Python2","permalink":"https://super3h.me/tags/Python2/"},{"name":"SQL","slug":"SQL","permalink":"https://super3h.me/tags/SQL/"}]},{"title":"python2.7 升级pip失败的原因","date":"2016-12-25T02:46:39.845Z","path":"2016/12/25/Python-pip/","text":"错误UnicodeDecodeError: ‘ascii’ codec can’t decode byte 0xbb in position 7: ordinal not in range(128) 错误原因 原因是pip安装python包会加载我的用户目录，我的用户目录恰好是中文的，ascii不能编码 解决方案python目录 Python27\\Lib\\site-packages 建一个文件sitecustomize.py内容写：import syssys.setdefaultencoding(‘gb2312’)python会自动运行这个文件。","tags":[{"name":"Python2","slug":"Python2","permalink":"https://super3h.me/tags/Python2/"},{"name":"pip","slug":"pip","permalink":"https://super3h.me/tags/pip/"}]}]