---
title: java错题总结
categories: JavaSE
---

# 错题分析
## Integer的考察
> 在jdk1.5的环境下，有如下4条语句：

``` java
Integer i01 = 59;
int i02 = 59;
Integer i03 =Integer.valueOf(59);
Integer i04 = new Integer(59)
```
- 以下输出结果为false的是：
![](java错题总结/1.png)
> 解析如下:

![](java错题总结/2.png)

## java类加载
> 以下哪项不属于java类加载过程？

![](java错题总结/3.png)
> 分析如下:

![](java错题总结/4.png)

## equals
> 列出`equals`的源码

``` java
public boolean equals(Object obj) {
        return (this == obj);
    }
```
> Object 中euqals的源码如上。没有重写equals时，是直接用==判断的，而String中重写了equals方法

## wait()方法和 sleep()方法的区别
> 这两个方法来自不同的类分别是，sleep来自Thread类，和wait来自Object类。

- sleep是Thread的静态类方法，谁调用的谁去睡觉，即使在a线程里调用了b的sleep方法，实际上还是a去睡觉，要让b线程睡觉要在b的代码中调用sleep。
- <font color='red'>**最主要是sleep方法没有释放锁，而wait方法释放了锁，使得敏感词线程可以使用同步控制块或者方法。**</font>sleep不出让系统资源；wait是进入线程等待池等待，出让系统资源敏感词线程可以占用CPU。一般wait不会加时间限制，因为如果wait线程的运行资源不够，再出来也没用，要等待敏感词线程调用notify/notifyAll唤醒等待池中的所有线程，才会进入就绪队列等待OS分配系统资源。sleep(milliseconds)可以用时间指定使它自动唤醒过来，如果时间不到只能调用interrupt()强行打断。
Thread.Sleep(0)的作用是“触发操作系统立刻重新进行一次CPU竞争”。

3、使用范围：wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用 
   synchronized(x){ 
      x.notify() 
     //或者wait() 
   }

4、sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常