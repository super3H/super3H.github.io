---
title: Spring 依赖注入(DI)
categories: spring
---

> 在Spring框架中，依赖注入(DI)的设计模式是用来定义对象彼此间的依赖。它主要有两种类型：
    - Setter方法注入
    - 构造器注入

> 这里两种方法共用的基本类如下:
``` java
package com.hhh.core;

public interface Music {
	
	void minYao();

}
```
``` java
package com.hhh.core.impl;

import com.hhh.core.Music;

public class MusicImpl implements Music {

	public void minYao() {
		System.out.println("民谣");
	}

}

```
#  Setter方法注入
> 这是最流行最简单的DI注入方法，通过设置方法注入依赖。

## 示例
> 帮助器类和指定的setter方法
``` java
package com.hhh.helper;

import com.hhh.core.Music;

public class MusicHelper {
	
	private Music music;

	public void getMusic() {
		music.minYao();
	}

	public void setMusic(Music music) {
		this.music = music;
	}
	
}

```
> 一个 bean 配置文件用来声明bean 和通过 setter 设置注入(property标签)的依赖
``` xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">
	
	<bean id="music" class="com.hhh.core.impl.MusicImpl"></bean>
	<bean id="musicHelper" class="com.hhh.helper.MusicHelper">
		<property name="music" ref="music"></property>
	</bean>
</beans>
```
> 测试类test
``` java
package com.hhh.test;

import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import com.hhh.helper.MusicHelper;

public class TestDI {

	@Test
	public void testSetter(){
		ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
		MusicHelper helper = (MusicHelper) context.getBean("musicHelper");
		helper.getMusic();
	}
}

```
> 结果:`民谣`

# 构造函数注入
> 此DI方法将通过构造函数注入依赖。

## 示例
> 一个辅助类的构造函数。
``` java
package com.hhh.helper;

import com.hhh.core.Music;

public class ConstructorHelper {
	
	public ConstructorHelper(Music music){
		music.minYao();
	}
}
```
> bean 配置文件来声明bean并通过构造函数(constructor-arg标签)设置注入依赖
``` xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">
	
	<bean id="music" class="com.hhh.core.impl.MusicImpl"></bean>
	<bean id="constructorHelper" class="com.hhh.helper.ConstructorHelper">
		<constructor-arg>
			<ref bean="music"/>
		</constructor-arg>
	</bean>

</beans>
```
> 测试类test
``` java
package com.hhh.test;

import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import com.hhh.helper.MusicHelper;

public class TestDI {
	@Test
	public void testConstructor(){
		ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
		MusicHelper helper = (MusicHelper) context.getBean("musicHelper");
		helper.getMusic();
	}
}

```
> 结果:`民谣`

## 构造方法注入类型歧义问题
### 问题
> 让我们来看看这个客户 bean 实例。它包含两个构造方法，均接受3个不同的数据类型参数。
``` java
package com.yiibai.common;

public class Customer 
{
	private String name;
	private String address;
	private int age;
	
	public Customer(String name, String address, int age) {
		this.name = name;
		this.address = address;
		this.age = age;
	}
	
	public Customer(String name, int age, String address) {
		this.name = name;
		this.age = age;
		this.address = address;
	}
	//getter and setter methods
	public String toString(){
		return " name : " +name + "\n address : "
               + address + "\n age : " + age;
	}

}
```
> 在`Spring bean` 的配置文件中，通过传递一个“yiibai' 的名字，地址为'188'，以及年龄为'28'
``` xml
<!--Spring-Customer.xml-->
<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<bean id="CustomerBean" class="com.yiibai.common.Customer">

		<constructor-arg>
			<value>yiibai</value>
		</constructor-arg>
		
		<constructor-arg>
			<value>188</value>
		</constructor-arg>
		
		<constructor-arg>
			<value>28</value>
		</constructor-arg>
        </bean>

</beans>
```
> 运行它，你期望的结果是什么？