---
title: Spring 依赖注入(DI)
categories: Spring
---

> 在Spring框架中，依赖注入(DI)的设计模式是用来定义对象彼此间的依赖。它主要有两种类型：
    - Setter方法注入
    - 构造器注入

> 这里两种方法共用的基本类如下:
``` java
package com.hhh.core;

public interface Music {
	
	void minYao();

}
```
``` java
package com.hhh.core.impl;

import com.hhh.core.Music;

public class MusicImpl implements Music {

	public void minYao() {
		System.out.println("民谣");
	}

}

```
#  Setter方法注入
> 这是最流行最简单的DI注入方法，通过设置方法注入依赖。

## 示例
> 帮助器类和指定的setter方法
``` java
package com.hhh.helper;

import com.hhh.core.Music;

public class MusicHelper {
	
	private Music music;

	public void getMusic() {
		music.minYao();
	}

	public void setMusic(Music music) {
		this.music = music;
	}
	
}

```
> 一个 bean 配置文件用来声明bean 和通过 setter 设置注入(property标签)的依赖
``` xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">
	
	<bean id="music" class="com.hhh.core.impl.MusicImpl"></bean>
	<bean id="musicHelper" class="com.hhh.helper.MusicHelper">
		<property name="music" ref="music"></property>
	</bean>
</beans>
```
> 测试类test
``` java
package com.hhh.test;

import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import com.hhh.helper.MusicHelper;

public class TestDI {

	@Test
	public void testSetter(){
		ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
		MusicHelper helper = (MusicHelper) context.getBean("musicHelper");
		helper.getMusic();
	}
}

```
> 结果:`民谣`

# 构造函数注入
> 此DI方法将通过构造函数注入依赖。

## 示例
> 一个辅助类的构造函数。
``` java
package com.hhh.helper;

import com.hhh.core.Music;

public class ConstructorHelper {
	
	public ConstructorHelper(Music music){
		music.minYao();
	}
}
```
> bean 配置文件来声明bean并通过构造函数(constructor-arg标签)设置注入依赖
``` xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">
	
	<bean id="music" class="com.hhh.core.impl.MusicImpl"></bean>
	<bean id="constructorHelper" class="com.hhh.helper.ConstructorHelper">
		<constructor-arg>
			<ref bean="music"/>
		</constructor-arg>
	</bean>

</beans>
```
> 测试类test
``` java
package com.hhh.test;

import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import com.hhh.helper.MusicHelper;

public class TestDI {
	@Test
	public void testConstructor(){
		ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
		MusicHelper helper = (MusicHelper) context.getBean("musicHelper");
		helper.getMusic();
	}
}

```
> 结果:`民谣`

## 构造方法注入类型歧义问题
### 问题
> 让我们来看看这个客户 bean 实例。它包含两个构造方法，均接受3个不同的数据类型参数。
``` java
package com.yiibai.common;

public class Customer 
{
	private String name;
	private String address;
	private int age;
	
	public Customer(String name, String address, int age) {
		this.name = name;
		this.address = address;
		this.age = age;
	}
	
	public Customer(String name, int age, String address) {
		this.name = name;
		this.age = age;
		this.address = address;
	}
	//getter and setter methods
	public String toString(){
		return " name : " +name + "\n address : "
               + address + "\n age : " + age;
	}

}
```
> 在`Spring bean` 的配置文件中，通过传递一个“yiibai' 的名字，地址为'188'，以及年龄为'28'
``` xml
<!--Spring-Customer.xml-->
<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<bean id="CustomerBean" class="com.yiibai.common.Customer">

		<constructor-arg>
			<value>yiibai</value>
		</constructor-arg>
		
		<constructor-arg>
			<value>188</value>
		</constructor-arg>
		
		<constructor-arg>
			<value>28</value>
		</constructor-arg>
        </bean>

</beans>
```
> 运行它，你期望的结果是什么？
``` java
package com.yiibai.common;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App 
{
    public static void main( String[] args )
    {
    	ApplicationContext context = 
    	  new ClassPathXmlApplicationContext(new String[] {"Spring-Customer.xml"});

    	Customer cust = (Customer)context.getBean("CustomerBean");
    	System.out.println(cust);
    }
}
```
> 输出结果
``` json
name : yiibai
 address : 28
 age : 188
```

> 其结果不是我们所期望的，第一个构造器不执行，而是第二构造函数运行。在Spring参数类型'188' 能够转换成int，所以Spring只是转换它，并采用第二个构造来执行，即使你认为它应该是一个字符串。

- 另外，如果Spring不能解决使用哪个构造函数，它会提示以下错误信息
``` java
constructor arguments specified but no matching constructor 
found in bean 'CustomerBean' (hint: specify index and/or 
type arguments for simple parameters to avoid type ambiguities)
```

### 解决方案
``` xml
<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<bean id="CustomerBean" class="com.yiibai.common.Customer">
	
		<constructor-arg type="java.lang.String">
			<value>yiibai</value>
		</constructor-arg>
		
		<constructor-arg type="java.lang.String">
			<value>188</value>
		</constructor-arg>
		
		<constructor-arg type="int">
			<value>28</value>
		</constructor-arg>
		
	</bean>

</beans>
```
> 再次运行它，现在得到你所期望的。
``` json
name : yiibai
 address : 188
 age : 28
```
> 这是一个很好的做法，显式声明每个构造函数参数的数据类型，以避免上述构造注入型歧义的问题。

# 原文链接
[Spring构造方法注入类型歧义](http://www.yiibai.com/spring/constructor-injection-type-ambiguities-in-spring.html)
[Spring依赖注入（DI）](http://www.yiibai.com/spring/spring-dependency-injection-di.html)