---
title: Spring MVC错误处理
categories: SpringMVC
---

# Spring MVC错误处理
以下示例将如何在使用Spring Web MVC框架的表单中使用错误处理和验证器

## 目录如下
![](Spring MVC错误处理/1.png)

## 相关代码
- Person.java
``` java
package com.hhh.domain;

public class Person {
	private Integer age;
	private String name;
	private Integer id;
	public Integer getAge() {
		return age;
	}
	public void setAge(Integer age) {
		this.age = age;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public Integer getId() {
		return id;
	}
	public void setId(Integer id) {
		this.id = id;
	}
	
}
```
- PersonValidator.java
``` java
package com.hhh.controller;

import org.springframework.validation.Errors;
import org.springframework.validation.ValidationUtils;
import org.springframework.validation.Validator;

import com.hhh.domain.Person;

public class PersonValidator implements Validator{

	public boolean supports(Class<?> clazz) {
		return Person.class.isAssignableFrom(clazz);
	}

	public void validate(Object obj, Errors errors) {
		ValidationUtils.rejectIfEmptyOrWhitespace(errors, "name", "name","Field name is required.");
	}

}

```
- `isAssignableFrom` 是用来**判断一个类Class1和另一个类Class2是否相同或是另一个类的超类或接口。**   
  通常调用格式是
``` java
//调用者和参数都是   java.lang.Class   类型。
Class1.isAssignableFrom (Class2)   
```
- `instanceof`   是用来**判断一个对象实例是否是一个类或接口的或其子类子接口的实例。  ** 
    格式是：
``` java
//第一个参数是对象实例名，第二个参数是具体的类名或接口名 
oo   instanceof   TypeName     
```
> 详情可看[Class.isAssignableFrom与 instanceof 区别](http://lucky16.iteye.com/blog/1631253)

- rejectIfEmptyOrWhitespace
``` java
/**
    Parameters:
    errors - 错误实例
    field - 被检验的字段
    errorCode - 错误代号
    defaultMessage - 出现错误时的提示消息
    */
rejectIfEmptyOrWhitespace(Errors errors,String field,String errorCode, String defaultMessage)
```
> 详情案例可看此处[使用Spring的Validator接口进行校验](http://www.shouce.ren/api/spring2.5/ch05s02.html)
- PersonController.java
``` java
package com.hhh.controller;

import java.util.Date;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.validation.BindingResult;
import org.springframework.validation.Validator;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.WebDataBinder;
import org.springframework.web.bind.annotation.InitBinder;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.servlet.ModelAndView;

import com.hhh.domain.Person;

@Controller
public class PersonController {
	
	public PersonController(){
		System.out.println(new Date().toString());
	}
	
	@Autowired
	@Qualifier("personValidator")
	private Validator validator;
	
	@InitBinder
	private void initBinder(WebDataBinder binder){
		binder.setValidator(validator);
	}
	
	@RequestMapping(value="/addPerson",method=RequestMethod.GET)
	public ModelAndView person(){
		return new ModelAndView("person","command",new Person());
	}
	
	@ModelAttribute("person")
    public Person createStudentModel() {   
		Person person = new Person();
		System.out.println(person);
       return person;
    }
	
	@RequestMapping(value="/showPerson",method=RequestMethod.POST)
	public String addPerson(@ModelAttribute("person") @Validated Person person,BindingResult bindingResult,Model model){
		if (bindingResult.hasErrors()) {
	         return "person";
		}
		model.addAttribute("name", person.getName());
	      model.addAttribute("age", person.getAge());
	      model.addAttribute("id", person.getId());

	      return "result";
	}
}
```
- ` @Qualifier` 注解和 `@Autowired` 注解通过指定哪一个真正的 bean 将会被装配来消除混乱。

- `WebDataBinder`是用来绑定请求参数到指定的属性编辑器.**由于前台传到controller里的值是String类型的，当往Model里Set这个值的时候，如果set的这个属性是个对象，Spring就会去找到对应的editor进行转换，然后再SET进去。**在需要日期转换的Controller中也会使用SpringMVC的注解@initbinder和Spring自带的WebDateBinder类来操作。可参考[SpringMVC注解@initbinder解决类型转换问题](http://www.cnblogs.com/aheizi/p/5440884.html)
- `Model` 是一个接口， **其实现类为ExtendedModelMap，继承了ModelMap类。** 
- `ModelMap`:ModelMap对象主要**用于传递控制方法处理数据到结果页面**，也就是说我们把结果页面上需要的数据放到ModelMap对象中即可，**他的作用类似于request对象的setAttribute方法的作用，用来在一个请求过程中传递处理的数据。**通过以下方法向页面传递参数：
`addAttribute(String key,Object value);`
在页面上可以通过el变量方式$key或者bboss的一系列数据展示标签获取并展示modelmap中的数据。**modelmap本身不能设置页面跳转的url地址别名或者物理跳转地址，那么我们可以通过控制器方法的返回值来设置跳转url地址别名或者物理跳转地址。**
- `ModelAndView`
ModelAndView对象有两个作用：
* 设置转向地址,如下所示（这也是ModelAndView和ModelMap的主要区别）
``` java
ModelAndView view = new ModelAndView("path:ok");
```
* 用于传递控制方法处理结果数据到结果页面，也就是说**我们把需要在结果页面上需要的数据放到ModelAndView对象中即可，他的作用类似于request对象的setAttribute方法的作用，用来在一个请求过程中传递处理的数据**。通过以下方法向页面传递参数：
``` java
addObject(String key,Object value);
```
在页面上可以通过el变量方式$key或者bboss的一系列数据展示标签获取并展示ModelAndView中的数据。

- `注意:`
``` java
@ModelAttribute("person")
    public Person createStudentModel() {   
        Person person = new Person();
        System.out.println(person);
       return person;
    }
```
这段代码必须配合前台jsp中的`commandName="person"`一起使用，否则会报错

> 以下这段错误处理，也必须配合以上的两者一起使用，否则会报错 
```
Neither BindingResult nor plain target object for bean name 'command' available as request attribute
```
``` java
if (bindingResult.hasErrors()) {
	         return "person";
}
```
> 通过实验发现

``` java
//@ModelAttribute("person")可改为@ModelAttribute，也能获取前台数据，和createStudentModel()方法无关
public String addPerson(@ModelAttribute("person") @Validated Person person,BindingResult bindingResult,Model model){
		if (bindingResult.hasErrors()) {
	         return "person";
		}
```

# 总结
## 单例
springmvc中控制器，即我们的`PersonController`为单例
## 运行过程
通过debug调试得知 当输入
![](Spring MVC错误处理/2.png)
先跳转到
![](Spring MVC错误处理/3.png)
在之后
![](Spring MVC错误处理/4.png)
设置我们的验证器，并获取`ServletRequestDataBinder`对象

![](Spring MVC错误处理/5.png)
![](Spring MVC错误处理/6.png)
当我们提交后：然后继续进入`createStudentModel`和`initBinder`，在之后进入:
![](Spring MVC错误处理/7.png)


