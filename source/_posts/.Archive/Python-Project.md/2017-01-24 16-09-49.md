---
title: Python-web_project学习
---
# 原文链接
[flask文档](http://docs.jinkan.org/docs/flask/patterns/packages.html)
# 简单的包
## 程序结构
> 项目最后得到的程序结构如下
``` shell
/yourapplication
    /runserver.py
    /yourapplication
        /__init__.py
        /views.py
        /static
            /style.css
        /templates
            layout.html
            index.html
            login.html
            ...
```
> 由于原来的` python yourapplication/__init__.py`在` /yourapplication`里面不能再工作了，因此在项目最外层建立`runserver.py`，案例如下：
``` python
from yourapplication import app
app.run(debug=True)
```
>  `__init__.py`作用是方便导入(不用再对应到文件导入了---->`from flask.__init__ import app`)例子如下
``` python
from flask import Flask
app = Flask(__name__)

import yourapplication.views
```
> ` views.py `案例如下：
``` python
from yourapplication import app

@app.route('/')
def index():
    return 'Hello World!'
```
## 循环导入
> 每个 `Python` 程序员都会讨厌他们，而我们反而还添加了几个进去: 循环导入(在两个模块相互依赖对方的时候，就会发生循环导入)。在这里 `views.py` 依赖于 `__init__.py`。通常这被认为是个不好的主意，但是在这里实际上不会造成问题。之所以如此，是因为我们实际上没有在 `__init__.py` 里使用这些视图，而仅仅是保证模块被导入了。并且，我们是在文件的结尾这么做的。

> 这种做法仍然有些问题，但是如果您想要使用修饰器，那么没有其他更好的方法了。检查 [聚沙成塔](http://docs.jinkan.org/docs/flask/becomingbig.html#becomingbig) 这一章来寻找解决问题的些许灵感吧

# 漏洞学习
## contextlib.closing()函数
`contextlib.closing()`函数是实现在一个block之后自动关闭
``` python
with closing(<module>.open(<arguments>)) as f:
    <block>
# 相当于
f=<module>.open(<arguments>)
try:
    <block>
finally:
    f.close()
```
`flask`数据库创建案例如下
``` python
def connect_db():
    return sqlite3.connect(app.config['DATABASE'])    #连接数据库

with closing(connect_db()) as db:    #连接数据库，并执行完下面的代码之后关闭
    with app.open_resource('schema.sql') as f:    #打开蓝本
        db.cursor().executescript(f.read())    #用数据库指针执行蓝本
    db.commit()    #提交
```