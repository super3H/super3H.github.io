---
title: Session的缓存及对象的状态
categories: J2EE-Hibernate
---
# Session的缓存
Java是纯面向对象的语言，因此不可能像C语言那样直接操纵内存，例如声明一段可用的内存空间。在Java里面，缓存通常是指Java对象的属性占用的 内存空间，通常是一些集合类型的属性。**在session接口的实现类SessionImpl中定义了一系列的Java集合，这些Java集合就构成了 Session的缓存。**
       使用缓存的一个很明显的好处就是可以减少数据库访问的频率，提高应用程序的性能，因为从内存中读取数据显然要比从数据库中查询快多了。

# Hibernate中Java对象的状态
在一个Hibernate应用中，Java对象可以处于以下三个状态之一：

- **瞬时状态(Transient)：**也叫临时状态，处于这个状态的对象还被没有纳入Hibernate的缓存管理体系，跟任何session都不关联，在数据库中也没有对应的记录。超过作用域会被JVM垃圾回收器回收，一般是new出来且与session没有关联的对象。
- **持久化状态(Persistent)：**处于这个状态的对象位于Session的缓存中，并且和数据库中的一条数据记录相对应。并且相关联的session没有关闭，事务没有提交，持久对象状态发生改变，在事务提交时会影响到数据库(hibernate能检测到)。
- **脱管状态(Detached)：**也叫游离状态，处于这个状态的对象不再位于Session的缓存中，当前没有session与之关联；托管对象状态发生改变，hibernate不能检测到。<font color='red'>它与临时对象的最大区别在于，游离对象在数据库中还可能存在一条与它对应的记录。</font>
上述3个状态之间是可以相互转化的，<font color='blue'>而且我们所说的状态都是针对某一个session实例而言的</font>，比方说，对象A对于session1而言是处于持久化状态的，因为它处于session1的缓存中，但是对于session2而言对象A并不在它的缓存中，因此它是处于游离状态的。
          对于这几个状态的理解花费了我一定的时间，因为总是有一些稀奇古怪的念头在我脑海中产生。比如说，对于临时状态的定义，如果我新建一个对象，然后人为的让 它属性的值和数据库中的一条记录对应，包括id的取值都一样。此时它能否说是处于游离状态呢？因为它和一条记录想对应呀。实际上这些情况都是由于一些不和 规范的操作而产生的。在Hibernate应用中，<font color='green'>无论Java对象处于临时状态、持久化状态还是游离状态，应用程序都不应该修改它的OID。</font><font color='red'>OID（也就是实体类中的主键属性）</font>的值应该由Hibernate来维护和负责，实际上Hibernate在同步缓存中的对象与数据库中的记录时，都是通过OID来进行关联和映射的，如果应用程序人为的修改了对象的OID，就会导致一些莫名其妙的错误，而且这样也不利于数据的同步。