---
title: hibernate中openSession()跟getCurrentSession()的区别
categories: J2EE-Hibernate
---

# openSession()与getCurrentSession()
1. 采用`getCurrentSession()`创建的Session会绑定到当前的线程中去、而采用`OpenSession()`则不会。**查询也需要开事务，否则会报错**
2. 采用`getCurrentSession()`创建的Session在commit或rollback后会自动关闭，采用`OpenSession()`必须手动关闭。
3. 采用`getCurrentSession()`需要在`Hibernate.cfg.xml`配置文件中加入如下配置：

> 如果是本地事物，及JDBC一个数据库：`<property name=”current_session_context_class”>thread</property>`
> 如果是全局事物，及jta事物、多个数据库资源或事物资源：`<property name=”current_session_context_class”>jta</property>`
> 使用spring的getHiberanteTemplate 就不需要考虑事务管理和session关闭的问题

# 补充
> `openSession`创建session时autoCloseSessionEnabled参数为false，即在事物结束后不会自动关闭session，需要手动关闭，如果不关闭将导致session关联的数据库连接无法释放，最后资源耗尽而使程序当掉。              

> `getCurrentSession`创建session时autoCloseSessionEnabled，flushBeforeCompletionEnabled都为true，并且session会同sessionFactory组成一个map以sessionFactory为主键绑定到当前线程。

> `getCurrentSession()`:从上下文（配置文件current_session_context_class: thread 使用Connection自动管理；jta(java transaction api) 由Application Server提供的分布式事务管理，Tomcat本身不具备此能力，JBoss、WebLogic具备）找，如果有，则用旧的，否则创建新的，**事务提交自动Close；**

# 本地事务和全局事务
- `全局事务：`资源管理器管理和协调的事务，可以跨越多个数据库和进程。资源管理器一般使用 XA 二阶段提交协议与“企业信息系统”(EIS) 或数据库进行交互。 
- `本地事务：`在单个 EIS 或数据库的本地并且限制在单个进程内的事务。本地事务不涉及多个数据来源。

## 在Hibernate配置文件中有这么两种配置方式:
1. 如果使用的是本地事务（jdbc事务）`<property name="hibernate.current_session_context_class">thread</property>`,这个是我们常用的选项,只针对一个数据库进行操作，也就是说只针对一个事务性资源进行操作.
2. 如果使用的是全局事务（jta事务）
`<property name="hibernate.current_session_context_class">jta</property>`
>  以前我们学习的事务类型都属于本地事务。 `JTA`(全局事务)和`thread`(本地事务)有什么区别呢？在某些应用场合，只能使用全局事务，比如： 有两个数据库：
> `mysql` 和 `oracle`  现在有个业务需求--转账 :
``` sql
step 1> update mysql_table set amount=amount-xx where id=aaa 
/*发生扣钱,假设是在mysql数据库扣钱的。 */
step 2> update oracle_table set amount=amount+xx where id=bbb
/* 加钱,假设是在oracle数据库扣钱的。 */
```
> 现在怎么确保两个语句在同一个事务里执行呢？ 
``` sql
/*以前在JDBC里是这样做 */
connection = mysql /*连接mysql */
connection.setAutoCommit(false);  /*不自动提交 */
1> update mysql_table set amount=amount-xx where id=aaa
 /*发生扣钱,假设是在mysql数据库扣钱的。 */
2> update oracle_table set amount=amount+xx where id=bbb 
 /*发生在oracle数据库 */
connection.commit(); 
```
> 执行这两条语句，然后通过`connection`对象提交事务.我们这样子做只能确保这两个语句在同一个数据库`mysql`里面实现在同一个事务里执行。 但是问题是我们现在是要连接到`oracle`数据库，是不是需要`connection2`啊？

``` sql
connection = mysql /*连接mysql */
connection2 = oracle /*连接oracle */
connection.setAutoCommit(false);  /*不自动提交 */
1> update mysql_table set amount=amount-xx where id=aaa /*发生扣钱,假设是在mysql数据库扣钱的。 */
2> update oracle_table set amount=amount+xx where id=bbb  /*发生在oracle数据库 /*
connection.commit(); 
connection2.setAutoCommit(false); 
connection2.commit();
```

> 事务只能在一个`connection`里打开，并且确保两条语句都在该`connection`里执行，这样才能让两条语句在同一事务里执行，现在问题就在于**connection2是连接到oracle数据库的，那么connection2再开事务有意义吗？它能确保吗？不能，所以在这种情况下就只能使用全局事务了。** 
这种情况下用普通JDBC操作是满足不了这个业务需求的，这种业务需求只能使用全局事务，本地事务是无法支持我们的操作的，因为这时候，**事务的生命周期不应该局限于connection对象的生命周期范围**


# 原文链接
[hibernate中openSession()跟getCurrentSession()方法之间的区别 ](http://www.cnblogs.com/Ant-soldier/p/5051478.html)
